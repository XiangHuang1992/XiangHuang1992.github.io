<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ferdinad_hx&#39;s Blog</title>
  
  <subtitle>Get busy living, or get busy dying.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.huangxiang666.com/"/>
  <updated>2018-01-26T15:51:46.141Z</updated>
  <id>http://www.huangxiang666.com/</id>
  
  <author>
    <name>ferdinand_hx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017年GitHub上新增的值得学习的Python开源库</title>
    <link href="http://www.huangxiang666.com/2017%E5%B9%B4GitHub%E4%B8%8A%E6%96%B0%E5%A2%9E%E7%9A%84%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0%E7%9A%84Python%E5%BC%80%E6%BA%90%E5%BA%93.html"/>
    <id>http://www.huangxiang666.com/2017年GitHub上新增的值得学习的Python开源库.html</id>
    <published>2018-01-26T15:49:25.000Z</published>
    <updated>2018-01-26T15:51:46.141Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4892949-b35794355388dcba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="python开源.jpg"></p><hr><p>截止到目前为止，在GitHub上当我们以Python为关键字进行搜索时，发现有者60+W的相关搜索结果，近年来，Python越来越热门，在GitHub上的开源项目也井喷式的发展，那么在众多的开源项目中，哪些非常优秀的项目是非常值得我们去学习的呢？下面就为大家来介绍在GitHub上非常热门的开源项目。</p><p><img src="http://upload-images.jianshu.io/upload_images/4892949-66098f8cba2abc30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="github上Pythonp项目数量.png"></p><h3 id="Home-Assistant"><a href="#Home-Assistant" class="headerlink" title="Home Assistant"></a>Home Assistant</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-f73f4b65f81026d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="home-siisistant简介.png"><br><img src="http://upload-images.jianshu.io/upload_images/4892949-fc5e138d5848d00e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="home-saaistant.png"><br>Home Assistant是一个开源的家庭智能控制系统，它有着非常友好的基于Web的可自定义UI，可以连接灯、开关、音响设备、安放设备等，可以集中管理并追踪他们的状态。可以在一个界面上控制来自于不同厂家的不同智能设备，并且这些行为都是可以自定义的，让智能化的家庭有着更多的可能性。目前在美国市场上的大多数智能设备都兼容HomeAssostant。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Github地址：https://github.com/home-assistant/home-assistant</span><br></pre></td></tr></table></figure><h3 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-448295144b86427e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pytorch.png"></p><p>Pytorch是Facebook针对机器学习和科学基础上发布的一个机器学习工具包，具有高度的灵活性，前身是使用lua语言编写的torch，主要提供了以下两个功能：</p><ul><li>具备强GPU加速的张力计算（比如numpy）。</li><li>建立在基于磁带的自动调整基础上的深层神经网络。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Github地址：https://github.com/pytorch/pytorch</span><br></pre></td></tr></table></figure><h3 id="Grumpy"><a href="#Grumpy" class="headerlink" title="Grumpy"></a>Grumpy</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-da67e9542e1f1e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="grumpy.png"></p><p>grumpy是Google开源的一个使用Go开发的Python运行时，它将Python代码编译成Go代码，然后将其编译成本地文件，而不是字节码文件，grumpy是没有虚拟机（vm）的。编译后的Go代码是对grumpy的一系列调用。在Google公司里，运行并维护着大量的Python代码，比如Youtube的前端服务器和API就大多是使用Python编写的，这种巨型应用需要大量的工作来优化它的运行时，而Cpython中，GLI的存在，制约来Python的并发能力。grumpy就由此应运而生了。感兴趣的朋友可以复制下面的github链接去详细了解一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/google/grumpy</span><br></pre></td></tr></table></figure><h3 id="Sanic"><a href="#Sanic" class="headerlink" title="Sanic"></a>Sanic</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-0757cd52048875eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sanic.png"></p><p>sanic是一个基于Python 3.5+的一个web框架，与flask类似。特点就如上图中的“gotta to fast”说的那样，就是一个字：快。相对与flask，它使用async/await愈发编写，使用异步特性，所以它的速度有时非常明显，但由于它出现但时间还不够长，issues还不够多，所以建议新手刚上手Python的话，还是先使用flask，解决方案比较完善。但是sanic在可遇见的未来，必定会成为一个主流框架，有必要进行学习。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/channelcat/sanic</span><br></pre></td></tr></table></figure><h3 id="Python-fire"><a href="#Python-fire" class="headerlink" title="Python-fire"></a>Python-fire</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-47342c6fc37a6972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="python fire.png"></p><p>python-fire是谷歌开源的一个能够将任何的python代码自动生成命令行界面（CLI）的一个工具。</p><ul><li>Python Fire是Python中创建CLI的一个非常简单的方法。</li><li>Python Fire是开发和调试Python代码一个非常有用的工具。</li><li>Python Fire有助于我们探索现有代码或者将其他人的代码转换成CLI。</li><li>Python Fire使Bash和Dash之间的转换变得更加容易。</li><li>Python Fire通过使用您需要导入和创建的的模版和变量设置REPL，使得Python REPL更加容易使用。</li></ul><p>通过使用这个开源库，不但可以生成CLI，并且可以用来调试我们的Python程序。更多的作用，可以自行去发掘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/google/python-fire</span><br></pre></td></tr></table></figure><h3 id="spaCy"><a href="#spaCy" class="headerlink" title="spaCy"></a>spaCy</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-60d55a3651c765cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="spacy.png"></p><p>spacy是一个Python自然语言处理工具包。它建立于最新的研究基础之上，从诞生之初就用来解决实际问题，用于实际产品。spacy带有预先训练的统计模型和单词向量，目前支持20多种语言的标记，它具有世界上最快的句法分析器，用于标签的神经网络模型。如今人工智能概念非常火热，而自然语言的处理是人工智能的主要领域之一，而spacy是自然语言处理（NLP）中一个非常强大的工具包，所以对于想进入人工智能领域的童鞋们来说，这个开源库非常有必要学习。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/explosion/spaCy</span><br></pre></td></tr></table></figure><h3 id="Pipenv"><a href="#Pipenv" class="headerlink" title="Pipenv"></a>Pipenv</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-ede2f686da126831.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pipenv.png"></p><p>pipenv是Python官方正式推荐的Python打包工具。它可以帮助我们在不建立虚拟环境的情况下非常方便的安装和管理依赖，为我们的项目自动的创建和管理一个虚拟环境。有了它之后：</p><ul><li>不需要再单独使用pip和virtualenv去创建虚拟环境，pipenv帮你创建，并且它们将一起工作。</li><li>管理一个requirements.txt文件可能会产生问题，pipenv使用Pipfile和Pipfile.lock代替了requirements.txt，更加适用。</li><li>使用hash，非常安全，可以自动曝光安全漏洞。</li><li>让我们清晰明了的了解依赖图（$pipenv图）。</li><li>通过加载.env文件简化开发流程。</li></ul><p>有了上述一大堆优点，还等什么？赶紧复制下方的链接开始宅起来学吧！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/pypa/pipenv</span><br></pre></td></tr></table></figure><h3 id="MicroPython"><a href="#MicroPython" class="headerlink" title="MicroPython"></a>MicroPython</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-1ae4f2bfdb97151d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="micropyhon.jpg"></p><p>micropython是微型控制器和受控制系统精简高效的Python实现。通过micropython，我们完全可以通过Python语言来实现对硬件底层的访问可控制，就如图片所示的一样。目前该项目还在测试阶段，完整的实现来Python3.4的语法。感兴趣的同学可以通过下面的链接去了解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/micropython/micropython</span><br></pre></td></tr></table></figure><h3 id="Prophet"><a href="#Prophet" class="headerlink" title="Prophet"></a>Prophet</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-436b03cc65f8d2fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="prophet.png"></p><p>profhet是由Facebook Core Data Science team发布的开源软件，可以在CRAN和PYPI上下载。该框架可以使开发人员专注于金融策略模型、项目组合管理和分析上。对金融领域内的数据进行科学性的预测分析，对趋势、粒度等进行预测。profhet对于丢失的数据、趋势的转变、和大量的异常值具有强大的预测分析功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/facebook/prophet</span><br></pre></td></tr></table></figure><h3 id="SerpentAI"><a href="#SerpentAI" class="headerlink" title="SerpentAI"></a>SerpentAI</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-2f32b27d9b5adcf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="serpentAI.png"></p><p>serpentAI是一个简单却又非常强大的开源软件，可以帮助开发人员创建游戏代理。将所有的游戏视频转换成适合实验的沙盒环境。该工具对机器学习和人工智能具有非常强大的作用。</p><p>serpentAI有着大量的支持模块，为使用视频游戏的环境以及使用CLI加速开发时常见的开发场景提供解决方案。</p><p>serpentAI的设计是完全基于插件的。可以方便共享给他人。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/SerpentAI/SerpentAI</span><br></pre></td></tr></table></figure><h3 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-3faf76cd2f79b25d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="![dash-demo.gif](http://upload-images.jianshu.io/upload_images/4892949-c9d3d246f201f0fe.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"></p><p>在Dash的项目主页上，有一句这样的介绍：“Dash is a Python framework for building analytical web applications. No JavaScript required.”是plotly在GitHub发布的一个企业级解决方案和开源工具。它基于flask、plotly.js、React.js构建。通过它可以非常简单的构建一个强大的交互式仪表板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/plotly/dash</span><br></pre></td></tr></table></figure><h3 id="Apistar"><a href="#Apistar" class="headerlink" title="Apistar"></a>Apistar</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-2afdea7dac815891.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="apistar.gif"></p><p>apistar是一个专门为Python3开发的一个web api框架：</p><ul><li>API文档——交互式API文档，始终与代码库保持同步。</li><li>客户端库——由API Star生成的类型系统驱动的Javascript和Python客户端库。</li><li>生成模式——支持生成Swagge或RAML API类型系统。</li><li>表达式——类型注释视图，代码可测试。</li><li>性能——确定如何运行每个视图的动态行为使得API Star非常的高效。</li><li>吞吐量——支持asyncio，允许构建高吞吐量的非阻塞应用程序。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/encode/apistar</span><br></pre></td></tr></table></figure><h3 id="Faiss"><a href="#Faiss" class="headerlink" title="Faiss"></a>Faiss</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-fa08e41ec784afb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="faiss.png"></p><p>faiss是密集向量的高效相似搜索和聚合类的库。它包含搜索任意大小的向量集的算法，还包含评估和参数调整的的支持代码。由Facebook开源。用于解决在用户日常搜索过程中所返回的网站拥有完全一样或者相似度过高的内容，应用类相似性搜索的相似引擎可以为用户返回最合适的结果，并且隐藏或者丢弃那些相同的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/facebookresearch/faiss</span><br></pre></td></tr></table></figure><h3 id="Better-exceptions"><a href="#Better-exceptions" class="headerlink" title="Better-exceptions"></a>Better-exceptions</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-e090c2c8c7aab0c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="better-exceoptions.png"></p><p>Better-exceptions是GitHub上一个Python中自动提示异常的一个非常漂亮和有用的开源小工具。非常简单实用。如图所示，使用之后代码的错误提示是不是看起来非常漂亮呢？喜欢的话就赶紧复制下面的链接安装试试吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/Qix-/better-exceptions</span><br></pre></td></tr></table></figure><h3 id="Flashtext"><a href="#Flashtext" class="headerlink" title="Flashtext"></a>Flashtext</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-ebec228636097c06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flashtext.png"></p><p>flashtext是一个基于FlashText算法，用于替换句子中的关键词或者从句子中提取关键字的一个开源库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/vi3k6i5/flashtext</span><br></pre></td></tr></table></figure><h3 id="Maya"><a href="#Maya" class="headerlink" title="Maya"></a>Maya</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-8edc38a404d97300.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="maya.jpeg"></p><p>maya是一款Python的时间日期的开源库。在Python中，使用时间日期让人感到非常的沮丧，特别在处理不同操作系统上的不同环境语言的实惠。这个开源库就是为了解决这个问题。</p><p>maya大多是围绕解析来自网站日期数据，所有时区代数在所有机器上的行为是相同的，不管系统区域设置如何。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/kennethreitz/maya</span><br></pre></td></tr></table></figure><h3 id="Tangent"><a href="#Tangent" class="headerlink" title="Tangent"></a>Tangent</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-bf145b4f1c3cf6de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tagent.png"></p><p>tangent是谷歌开源的一个免费的用于自动分化的Python库。现有的库通过跟踪程序的执行或者通过分段动态数据流图然后区分图来实现自动分化，而tangent在Python源代码本身上执行提前autodiff，并生成Python源代码作为其输出，正好填补来机器学习工具空间中的独特位置。</p><p>tangent可以在Python庞大且不断增长的子集上工作，提供其他Python ML库没有的额外的autodiff特性，具有合理的性能，并且与TensorFlow和NumPy兼容。</p><p>tangent当前还只是一个实验版本，还在持续构建开发当中。有兴趣的可以通过下方的链接进去学习并反馈意见。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub地址：https://github.com/google/tangent</span><br></pre></td></tr></table></figure><hr><p>好了，关于Python 2017年值得关注和学习的开源库今天就给大家分享总结到这里。其实我只是在github上搜集了一部分，在github上还有许许多多的优秀库值得我们去学习和探索。最后，生命不止，编程不息！为自己加油。</p><hr><p>注明：本文首发于今日头【<a href="https://www.toutiao.com/i6513690243382641166/】。作者：新农民的编程生涯" target="_blank" rel="noopener">https://www.toutiao.com/i6513690243382641166/】。作者：新农民的编程生涯</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;开源项目对于我们在软件开发的过程中有着非常重大的作用，我们可以阅读学习开源项目的源码并在它的基础上建立我们自己的项目，通过他人造的轮子我们可以节省很多非常宝贵的时间并少走许多的弯路，所以对于开源项目的学习是很有必要的。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.huangxiang666.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.huangxiang666.com/tags/Python/"/>
    
      <category term="GitHub" scheme="http://www.huangxiang666.com/tags/GitHub/"/>
    
      <category term="开源库" scheme="http://www.huangxiang666.com/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Python真的比其他语言慢吗</title>
    <link href="http://www.huangxiang666.com/Python%E7%9C%9F%E7%9A%84%E6%AF%94%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E6%85%A2%E5%90%97.html"/>
    <id>http://www.huangxiang666.com/Python真的比其他语言慢吗.html</id>
    <published>2018-01-26T15:21:52.000Z</published>
    <updated>2018-01-26T15:46:19.807Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xt7l1.com1.z0.glb.clouddn.com/python.jpeg" alt="python"></p><h3 id="为什么Python会比其它语言慢？"><a href="#为什么Python会比其它语言慢？" class="headerlink" title="为什么Python会比其它语言慢？"></a>为什么Python会比其它语言慢？</h3><h4 id="Python是动态类型语言而不是静态类型语言。"><a href="#Python是动态类型语言而不是静态类型语言。" class="headerlink" title="Python是动态类型语言而不是静态类型语言。"></a>Python是动态类型语言而不是静态类型语言。</h4><p>这意味着在程序执行的时候，解释器不知道被定义的变量的类型。下图总结了一个C变量（我使用C作为编译语言的替代品）和一个Python变量之间的区别：</p><p><img src="http://7xt7l1.com1.z0.glb.clouddn.com/C%E5%92%8CPython.png" alt="c和python"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* c代码实例 */</span></span><br><span class="line"><span class="keyword">int</span> a =<span class="number">1</span>; <span class="comment">// 将整型数1赋值给a</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>; <span class="comment">// 将整型数2赋值给b</span></span><br><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">// 调用binary_add&lt;int,int&gt;(a,b)，并将结果分配给c</span></span><br></pre></td></tr></table></figure><p>C编译器一开始就知道a和b是整数，直接调用两个整数添加的方法，返回C这个整数存到内存当中。整个代码就运行 完毕了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python代码实例</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = a + b</span><br></pre></td></tr></table></figure><p>如上代码所示，Python运行完上述代码需要经过以下几个步骤：</p><ul><li>将1分配给a：设置a的a-&gt;PyObject_HEAD-&gt;typecode为整型，然后设置a的值为1。</li><li>将2分配给b：设置b的b-&gt;PyObject_HEAD-&gt;typecode为整型，然后设置b的值为2。</li><li>调用binary_add(a,b)：在a-&gt;PyObject_HEAD找到typecode，a是整数，值为1；在b&gt;PyObject_HEAD找到typecode，b是整数，值为2。调用binary_add<int,int>(a-&gt;val,b-&gt;val)，返回结果，是一个整数。</int,int></li><li>创建一个Python对象c：设置c-&gt; PyObject_HEAD -&gt;typecode为整数，将c-&gt;val设置为3步骤中返回的结果。</li></ul><p>大家从上述步骤不难看出，动态类型语言，任何操作都涉及到很多的操作，这是Python对数值操作比C慢的主要原因。</p><h4 id="Python是解释型语言而不是编译型语言。"><a href="#Python是解释型语言而不是编译型语言。" class="headerlink" title="Python是解释型语言而不是编译型语言。"></a>Python是解释型语言而不是编译型语言。</h4><p>从上面我们看到了解释代码和编译代码之间的一个区别。优秀的编译器可以优化重复和不需要的操作，这使得它速度快。</p><h4 id="Python的对象模型会导致内存效率较低"><a href="#Python的对象模型会导致内存效率较低" class="headerlink" title="Python的对象模型会导致内存效率较低"></a>Python的对象模型会导致内存效率较低</h4><p>当我们想存储若干整数时，Python可能会使用list对象，而在C中，会使用基于某种缓冲区的数组。</p><p>比如最简单形式的NumPy数组是围绕C数组构建的Python对象，也就是说，它有一个指向值的连续缓冲数据区的指针，每一个指针指向一个Python对象，该对象又饮用其数据，如图所示：</p><p><img src="http://7xt7l1.com1.z0.glb.clouddn.com/Python.3png.png" alt=""></p><p>从上图不难看出，如果进行顺序执行数据的操作，那么numpy将比python在存储和访问上更有效率。</p><h3 id="Python效率这么低，为什么我们还要使用它？"><a href="#Python效率这么低，为什么我们还要使用它？" class="headerlink" title="Python效率这么低，为什么我们还要使用它？"></a>Python效率这么低，为什么我们还要使用它？</h3><ul><li><p>Python的动态类型使得Python比C更加容易使用，它非常的灵活，这种灵活性可以有效的利用我们的开发时间，在真正需要优化的时候，我们可以使用Python内置的库对其进行优化，这就是为什么在科学研究中，Python的使用率一直在不断增长，Python是用代码进行科学研究的一门非常有效的语言。</p></li><li><p>许多Python程序慢，是没有利用Python及其标准库中提供的功能，在数学和统计科学运算方面可以使用NumPy和Pandas等库提升速度，PyPy运行时（解释器的一种，默认解释器是CPython，是一个Python的JIT实现，只需通过用PyPy替换CPython）可以为许多Python程序提供数量级的加速。比如为我们长时间运行的Web服务器加速。</p></li><li><p>在我们开发的程序中，一个程序90%的运算往往在10%的代码中，所以针对这10%的代码进行优化可以大大提高我们程序的运行效率。在Python中，我们可以选择将这10%的代码通过Cython或Numba等项目转换成C或者若干程序集。</p></li><li><p>Cython是Python的超集，几乎是Python和C的合并，是一种渐进式语言，任何Python代码都是有效的Cython代码。Cython代码编译成C代码，使用Cython，我们可以编写一个模块或方法，让其具有C的类型和性能。混合使用C类型和Python类型。通过Cython，我们可以让我们的程序进行进一步的优化，并且具有Python的优点。</p></li></ul><p>开发人员的时间效率，一个py程序可能需要6s时间，而C可能只需要1s。但开发人员使用Python可能只需要10分钟就能完成这个程序。而使用C语言你可能需要1个小时或者更多。</p><hr><p>从上面不难看出，可能对于吞吐量比较大，并发需求较低但软件，Python不太适合。但从系统管理到目前非常火热的机器学习领域，Python显然是非常合适的语言。当要求应用开发速度以及开发人员时间有限的情况下，使用Python无疑是非常好的一个选择！</p><p>好了，本篇文章就给大家介绍到这里，喜欢我到文章的朋友可以点击【关注】。欢迎大家留言交流。最后放上：</p><p><img src="http://7xt7l1.com1.z0.glb.clouddn.com/python%E4%B9%8B%E7%A6%85.png" alt="Python之禅"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;随着人工智能和机器学习的热门，Python也成为了最热门的开发语言之一了。众所周知，Python相对于其它编程语言，其速度是比较慢的，那么它为什么会比较慢呢？为什么这么慢还会这么热门呢？本篇文章就为大家简单解释一下。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.huangxiang666.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.huangxiang666.com/tags/Python/"/>
    
      <category term="C" scheme="http://www.huangxiang666.com/tags/C/"/>
    
      <category term="编程语言" scheme="http://www.huangxiang666.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>在学习Python之前你必须知道的</title>
    <link href="http://www.huangxiang666.com/%E5%9C%A8%E5%AD%A6%E4%B9%A0Python%E4%B9%8B%E5%89%8D%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.html"/>
    <id>http://www.huangxiang666.com/在学习Python之前你必须知道的.html</id>
    <published>2018-01-26T06:24:10.000Z</published>
    <updated>2018-01-26T15:37:51.059Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着人工智能的兴起和机器学习领域的进步，人工智能已经在潜移默化中改变着我们的生活。</p><p>在2017年里，人工智能和机器学习呈现出了爆炸式的增长态势，与此同时，Python也在这几年中变得越来越火热。</p><p>伴随着人工智能的发展和机器学习的火热，许多程序开发人员开始改变方向拥抱人工智能，该培训机构也纷纷开始开设Python课程，许多其它行业的人也想以Python为契机转行进入程序开发行业，甚至连小学课程都加入连Python！</p><p>本文将从Python的介绍以及目前的市场行情来告诉广大即将入行的同学们在选择之前你应该知道的一些东西。</p><h2 id="什么是Python"><a href="#什么是Python" class="headerlink" title="什么是Python"></a>什么是Python</h2><ul><li>Python是一种后端程序语言，非常适合初学者入门。</li><li>Python在许多方面和Ruby类似，但和其他编程语言相比比较冗长，稍微啰嗦一点。</li><li>Python是一门高级编程语言，这意味着你不必把太多经历放在程序的底层实现上，你不需要太多的其他基础也能使用它写一些工具。</li><li>Python可以用于编写脚本、网页抓取和创建数据集。在科学计算领域非常受欢迎。有一些库在科学计算领域非常好用。</li><li>Python是一种网络编程语言，可以用于Web开发。</li></ul><h3 id="Python的起源"><a href="#Python的起源" class="headerlink" title="Python的起源"></a>Python的起源</h3><p><img src="http://7xt7l1.com1.z0.glb.clouddn.com/python%E4%B9%8B%E7%88%B6.jpeg" alt="Python之父"></p><p>1982年，荷兰人Guido van Rossum正在开发一个教育项目：开发一个名为ABC的语言。从那以后，Rossum开始从事Python语言的开发，在Python中有着ABC语言的深刻印记。</p><h3 id="Python是最适合初学者的编程语言？"><a href="#Python是最适合初学者的编程语言？" class="headerlink" title="Python是最适合初学者的编程语言？"></a>Python是最适合初学者的编程语言？</h3><ul><li>Python的语法非常直观，非常容易理解。</li><li>Python非常易读。可能在许多公司里面项目代码不是使用Python写的，但是也会使用Python写一些工具和自动化脚本。</li><li>Web编程。Python中的flask框架很简单就可以编写出一个动态响应式的网站。这无疑对初学者来讲可以鼓舞他们，因为这种网站和我们平时的网站看起来并没什么区别。</li><li>Python的社区比较成熟。</li></ul><h3 id="Python能用来做什么？"><a href="#Python能用来做什么？" class="headerlink" title="Python能用来做什么？"></a>Python能用来做什么？</h3><ul><li>Web后端开发。django，flask等非常优秀的web框架。</li><li>数据科学。Python在数据分析和数据科学领域应用非常广泛。numpy，scipy等库是机器学习和数据科学处理方面非常优秀等库。大数据分析、金融分析、科学分析等领域都大量使用了数据分析。</li><li>人工智能，TensorFlow。人工智能的一些常见应用也使用来Python技术。</li><li>Python还能用于嵌入式系统编程（micropython）</li><li>自动化运维。使用Python进行自动化运维工作。</li><li><p>Python作为一门胶水语言，对于那些一次性的管理任务，都可以使用Python来解决。可能在许多公司里没用使用Python作为主力后端语言，但他们可能会使用Python为部署和其它开发工作任务构建脚本，管理自动化进程，清理数据或者迁移数据。</p></li><li><p>其他。还有许多Python能够做的事情，如SEO等。Python能做的事情绝对不仅仅是爬虫，当然绝大多数人都是从Python开始的。随着互联网的发展，Python能做的事情将越来越多。</p></li></ul><h3 id="Python的不足之处"><a href="#Python的不足之处" class="headerlink" title="Python的不足之处"></a>Python的不足之处</h3><p>Python作为一门解释型语言，它的运行速度比其它的编译语言慢。这意味着有时代码运行速度会低于你的预期。</p><h3 id="通过Python你能从事什么样的工作？"><a href="#通过Python你能从事什么样的工作？" class="headerlink" title="通过Python你能从事什么样的工作？"></a>通过Python你能从事什么样的工作？</h3><ul><li>你可以从事Web开发。如Google、Facebook、Spotify、Netflix等知名的大公司都维护着大量的Python代码。</li><li>从事自动化运维工作。</li><li>从事目前非常热门的人工智能和机器学习的相关工作。</li></ul><h3 id="Python目前的市场情况"><a href="#Python目前的市场情况" class="headerlink" title="Python目前的市场情况"></a>Python目前的市场情况</h3><p>得益于人工智能和机器学习的兴起，目前Python在市场上非常火热，需求量非常大。这意味着你想通过Python切入到IT行业去找一份工作是可行的。但热门的同时也意味着涌入者非常多，你可能会面对很多的竞争者。并且互联网发展日新月异，你永远不知道下一刻会发生什么。所以，切入该领域，得思考清楚，一旦做出来选择，那么就赶紧努力，付出行动，不然也是白搭。</p><h3 id="如何学习Python？"><a href="#如何学习Python？" class="headerlink" title="如何学习Python？"></a>如何学习Python？</h3><p>加入你已经决定来要学习Python，那么作为一个新手，你又该如何学习Python呢？</p><p>希望从事一份Python相关的工作，这意味着你要学习的绝不仅仅是Python这门语言的语法以及学几个热门的框架就足够了的。</p><ul><li>你需要掌握Python基础</li><li>学完这些之后，你需要去学习一些比较流行的框架（django，flask，TensorFlow，Numpy等等许多，根据你想从事的方向去写），这些框架可能就是日后就职的公司的项目使用的，所以你得会。</li><li>Linux操作的基本知识。Python应用基本都部署在Linux系统上，所以你需要掌握一定的Linux只是，不需要你会很多，但常用但操作你得会，文件操作，进程管理等。</li><li>数据结构和算法的知识。可能你在工作中并不需要自己去写算法。但掌握常见的数据结构和算法是非常有必要的，这样你可以更加理解Python中的list，dict的原理，也有利于你写出优秀的代码。</li><li>计算机网络相关的知识也必须掌握。</li><li>除此之外，还有许多更具你工作的需要你得去学习的知识，这个因人而异，每个人遇到的项目和困难不一样。</li></ul><hr><p>是不是觉得要学习的东西太多了？确实，程序员学习的东西确实非常多，但不用紧张，一步一个脚印，编程需要积累和沉淀，在不知不觉中，或许你就成长为一个大神了。我正在努力，也是在自己学习Python。入行也才三年不到。</p><hr><p>好吧，这篇文章就写到这里吧，其实感觉自己什么都没写，写了一堆废话。很想贴代码的，但排版不好。下面贴一波资料吧。</p><p><img src="http://7xt7l1.com1.z0.glb.clouddn.com/python%E8%B5%84%E6%96%991.png" alt="Python资料1"></p><p><img src="http://7xt7l1.com1.z0.glb.clouddn.com/python%E8%B5%84%E6%96%992.png" alt="python资料2"></p><p><img src="http://7xt7l1.com1.z0.glb.clouddn.com/python%E8%B5%84%E6%96%993.png" alt="Python资料3"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Python是编程最好的语言吗？Python是最适合入门的语言吗？Python能用来做什么？学完Python你可以找到什么样子的工作？&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.huangxiang666.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.huangxiang666.com/tags/Python/"/>
    
      <category term="机器学习" scheme="http://www.huangxiang666.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python入门" scheme="http://www.huangxiang666.com/tags/Python%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>程序员的职业生涯如何规划</title>
    <link href="http://www.huangxiang666.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92.html"/>
    <id>http://www.huangxiang666.com/程序员的职业生涯如何规划.html</id>
    <published>2018-01-25T16:06:04.000Z</published>
    <updated>2018-01-26T16:14:38.861Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4892949-4241ca465c5c2eb3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="职业选择.jpeg"></p><h3 id="毛毛匆匆这两三年"><a href="#毛毛匆匆这两三年" class="headerlink" title="毛毛匆匆这两三年"></a>毛毛匆匆这两三年</h3><p>大学毕业近三年，三年时间说短不短，说长也不长，我是一名程序员。这两三年经历了许多，也成长了许多。</p><p>作者是一名程序员，从业年龄不长，三年不到的时间，但时常都能感觉到自己身上有着巨大的压力，来源于生活上的，也有来源于对工作未来的些许担忧，或许自己还未曾明确自己的职业规划。</p><p>相信很多人都曾今对自己的职业生涯有过迷茫，本篇文章也只是想带着自己这两三年的经历来说一说，作为一名程序员，我们的职业生涯应该如何的进行规划，从事其它行业人也可以看一看，或许也能触类旁通，有所收获。（PS：工作年限不长，说的不妥之处，请多多指教）。</p><h3 id="专业技能方向的规划"><a href="#专业技能方向的规划" class="headerlink" title="专业技能方向的规划"></a>专业技能方向的规划</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-c885a8b4f19849bb.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="zhuanye.jpeg"></p><p>这是我个人对于程序员职业生涯规划的一些想法。在我大学接触程序员这个行业的时候，就经常听许多人说，程序员是个青春饭，30岁之后你没有转行管理你就只能改行了之类的。当时我心里还有些担忧，我对于转岗管理非常的抵触，我非常喜欢敲一辈子键盘（我没啥大志-_—）。知道我工作后看到我40多岁的老大还在敲代码，我的心又放下来了，同时也告诉自己，我要努力，以后也这样。</p><p>在这日新月异的互联网时代，作为一名互联网从业者，首先我们得树立终身学习，终究就业的心。生命不止，奋斗不息。</p><ul><li><p>程序员只是一个笼统的称呼，在程序员里，又分了许许多多的工种，首先，不论我们是从事哪方面的工作，我们都不能把自己局限在某一个领域，一定要有意识的去开阔自己的视野，整个计算机领域是如何发展的、互联网时代的演化方向和趋势（就像之前多PC时代到移动互联网时代再到现如今非常火热的人工智能大数据时代）,我门需要去了解不同的编程语言和不同领域的基础知识。触类旁通，才能不断提高自己。</p></li><li><p>其次，我们得提高自己的专业知识水平，算法和数据结构是我们必须得会的，这是基础，你的基础有多好，决定你日后能站的多高。不要让自己在大楼已经建了一半之后再回头去补这些基础知识，这会让你得补偿失得。</p></li><li><p>除了上述基础理论的沉淀之外，我们还需要去不断的实践，写代码光靠读（读资料书，读别人博客，读别人代码）是远远不够的，程序是写出来的，只有经过大量的实践，我们才能验证这些理论，再能更加深刻的体会到为什么是这样，知道了为什么是这样，我们才能做的更好。就像刚开始完成一个功能需要100行代码，而两年之后你也许10行代码就搞定了。因为我们写到多了，不断了抽象、优化了。</p></li></ul><h3 id="职场上的选择"><a href="#职场上的选择" class="headerlink" title="职场上的选择"></a>职场上的选择</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-b66440acd8da19ca.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="zhichang.jpeg"></p><blockquote><p>在职场上，每个人都有着自己的想法，我们应该如何去选择一个公司，我们应该多久跳一次槽呢？经常能在群里看到有人问，我面试了几家公司，有几家公司愿意要我，我去哪一家好之类的问题。</p></blockquote><p>每个人都想找一个钱多活少离家近的工作，但是这只是最美好的想法，现实总是会有各种各样的因素来制约我们，当生活上有事情的时候，我们或许需要选择一个活少离家近的，当我们经济上压力比较大的时候（房贷、车贷）时，或许钱多才是我们第一考虑的因素。当我们还是刚出社会的时候，我们的专业技能和工作经验不足的时候，我们可能就需要选择活多机会多的工作。</p><h4 id="30岁之后我们时继续做技术还是继续做管理呢？"><a href="#30岁之后我们时继续做技术还是继续做管理呢？" class="headerlink" title="30岁之后我们时继续做技术还是继续做管理呢？"></a>30岁之后我们时继续做技术还是继续做管理呢？</h4><p>这是许许多多多程序员都想过的问题，也是许许多多多程序员面临过的问题，目前的我还没面临这个问题，但我也曾经想过这些。最后，我得出结论：</p><ul><li><p>我们都有着自己最终的目标，万变不离其宗，跟着自己内心的想法时什么，我门只要心里想着自己最终要得到什么，那就可以了。不论是管理还是技术，都能达成我们的最终目标。毕竟我们都是希望能够让自己在工作的非常开心的同时还能够不为柴米油盐发愁罢了。</p></li><li><p>好马配好鞍。如果你是一个偏向于管理，或者你的能力和你的性格适合在管理岗位上，那么你就可以往这个方向走，因为这样可以能让你比较舒服的实现自己的目标。如果你是一个偏向于潜心研究的人，那么技术方向获取是你不错的选择，你可以专攻技术向，成为一个技术专家。</p></li></ul><h4 id="成为自由职业者或者创业？"><a href="#成为自由职业者或者创业？" class="headerlink" title="成为自由职业者或者创业？"></a>成为自由职业者或者创业？</h4><p>除了选择在公司就职之外，我们还有其它的选择：自由职业者或者创业。两者都需要你积累人脉。（如何积累人脉？将在后面的换工作板块中阐述）</p><ul><li><p>自由职业者：当你的专业技术水平比较高并且人际口碑很不错时，你可以选择成为一名自由职业者，与公司合作，单独接项目去开发。</p></li><li><p>创业：创业也是许多人在职场上摸爬滚打许多年之后的选择。当你认为自己有机会并且有一定的资本时，你可以选择去创业，创业这条路，有着无限可能。自己做好思想准备即可。</p></li></ul><h3 id="关于换工作"><a href="#关于换工作" class="headerlink" title="关于换工作"></a>关于换工作</h3><p><img src="http://upload-images.jianshu.io/upload_images/4892949-5b31d131516ae962.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lizhi.jpeg"></p><blockquote><p>在我们职业生涯中，换工作是正常的，我们需要通过换工作来提高自己（能力和金钱）。我们经常在想，我们什么时候该换工作呢？如果我辞职了，我多久才能找到一份满意的工作呢。</p></blockquote><p>在我看来，我们每一份工作的时间不能太长，也不能太短，频繁的换工作绝对不利于自己的职业生涯发展。</p><blockquote><p>给大家算一笔换工作的账：换工作意味着今年可能没有年终奖，然后离职到下一份工作又一个空闲期，这段时间你只能吃老本，进入新公司你有几个月的试用期，这几个月试用期你可能会只有80%的薪水，还没有五险一金。你还需要面临没通过试用期的风险。所以每次离职都是成本挺大的。</p></blockquote><h4 id="为什么需要换工作？"><a href="#为什么需要换工作？" class="headerlink" title="为什么需要换工作？"></a>为什么需要换工作？</h4><ul><li><p>在一家新公司，我们不仅会接触到其它编程语言，还会接触到其它的工作方式和新的同事。跟不同的人合作，我们总是能学到不同的东西。并且，我们会积累人脉，这对于我们以后找另一份工作，也是有帮助的。</p></li><li><p>改变工作的另外一个原因是避免感到无聊，如果5年甚至10年我们一直在做同样的事情，那么可能我们不会在学习了，太安逸了。改变工作，我们将学习新的东西，迎接新的挑战，同时也会增加我们的就业能力。</p></li><li><p>在同一家公司里，我们也可以变换自己的角色，我们可以从开发人员变成测试人员，也可以变成产品经理，岗位的流动可以让扩大我们的技能包。</p></li></ul><p>不管怎么样，我们都要有意思的去改变自己的工作，我们不能只停留在原地，等待着被迫改变，我们应该化被动为主动，抓住主动权，我们才能更好的把握自己的命运。</p><h4 id="为什么不能在一份工作上做太久的时间呢？"><a href="#为什么不能在一份工作上做太久的时间呢？" class="headerlink" title="为什么不能在一份工作上做太久的时间呢？"></a>为什么不能在一份工作上做太久的时间呢？</h4><p>在同一家公司呆了10年，15年甚至20年的人，那么他找另一份工作相对于五年左右换工作的人的机会和竞争力将大大减少。就像去年华为辞退老员工引发大议论一样，根源在于他们下一份工作的收入和机会将远远低于现在的。因为和他的专业知识对口的公司太少了。而其它方面的技术他们又不如别人。更重要的是他们已经不再年轻，思维留下了太多以前公司的烙印，再想改变已经没有那么容易了，欢聚换来讲，他们没有太大的竞争力了。</p><h4 id="为什么不能在一份工作上做太短的时间呢？"><a href="#为什么不能在一份工作上做太短的时间呢？" class="headerlink" title="为什么不能在一份工作上做太短的时间呢？"></a>为什么不能在一份工作上做太短的时间呢？</h4><p>换工作的弊端在前面已经阐述过了，所以一份工作我们需要一段时间。每一份工作我们都能在其中学到不少东西。我们需要积累和沉淀，频繁的换工作，会有以下不良的影响：</p><ul><li><p>在职业圈内给人留下不安分，不忠诚的印象，在这个互联网时代，世界那么小，培养自己的职业道德和人际口碑将会给你带你很大的影响，是好是坏，全在于你自己怎么做。</p></li><li><p>在一个公司我们会接触到公司的业务，短时间你接触不到核心的业务，那么你学的东西肯定价值没那么大，在一个公司我们需要花时间去研究、接触这家公司的业务，这样才能培养自己的能力，才能在简历上写着自己负责了什么项目。其次，每个公司都是一个社会，我们融入这个社会，把这里面的人际关系处理好也需要时间。</p></li></ul><hr><p>好了，这篇文章就给大家分享到这里，由于作者自身工作经历也不是很长，所以观点难免有偏颇之处，文字排版也做的不是很好，能看到这里的都是很有耐心的人了。非常感谢您的阅读。觉得作者写的还不错的话，就点个赞或关注下吧。</p><p>PS：本文首发于今日头条：<a href="https://www.toutiao.com/c/user/5927349530/#mid=1590183488410628" target="_blank" rel="noopener">新农民的编程之旅</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;life is like a box of chocolates，you never know what you‘re going to get —— 《阿甘正传》生活就像一盒巧克力，你永远不知道下一颗是什么味道。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.huangxiang666.com/categories/Python/"/>
    
    
      <category term="程序员" scheme="http://www.huangxiang666.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="职业生涯" scheme="http://www.huangxiang666.com/tags/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS下使用pyenv管理Python版本</title>
    <link href="http://www.huangxiang666.com/Mac-OS%E4%B8%8B%E4%BD%BF%E7%94%A8pyenv%E7%AE%A1%E7%90%86Python%E7%89%88%E6%9C%AC.html"/>
    <id>http://www.huangxiang666.com/Mac-OS下使用pyenv管理Python版本.html</id>
    <published>2017-12-19T09:41:45.000Z</published>
    <updated>2017-12-20T08:22:43.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题的由来"><a href="#问题的由来" class="headerlink" title="问题的由来"></a>问题的由来</h2><p>在开发过程中，可能会遇到多个版本同时部署的情况。</p><ul><li>Mac OS自带的Python版本是2.x，自己开发需要Python3.x</li><li>系统自带的是2.6.x，开发环境是2.7.x</li><li>由于Mac机器系统保护的原因，默认的Python无法对PIP一些包升级，需要组建新的Python环境</li><li>此时需要在系统中安装多个版本的Python，但又不能影响系统自带的Python，即需要实现Python的多版本共存。<code>pyenv</code>就是这样一个Python版本管理器。</li></ul><a id="more"></a><h2 id="Pyenv"><a href="#Pyenv" class="headerlink" title="Pyenv"></a>Pyenv</h2><p><code>pyenv</code>是Python版本管理工具。<code>pyenv</code>可以改变全局的Python版本，安装多个版本的Python，设置目录级别的Python版本，还能创建和管理vitual python enviroments。所有的设置都是用户级别的操作，不需要<code>sudo</code>命令。</p><p><code>pyenv</code>主要用来管理Python的版本，比如一个项目需要Python2.x，一个项目需要Python3.x。而virtualenv主要用来管理Python包的依赖。不同项目需要依赖的包版本不同，则需要使用虚拟环境。</p><p><code>pyenv</code>通过系统修改环境变量来实现Python不同版本的切换。而vitualenv通过Python包安装到一个目录来作为Python虚拟包环境，通过切换目录来实现不同包环境间的切换。</p><p><code>pyenv</code>的美好之处在于，它并没有使用将不同的 PATH植入不同的shell这种高耦合的工作方式，而是简单地在PATH植入不同的shell这种高耦合的工作方式，而是简单地在PATH 的最前面插入了一个垫片路径（shims）：~/.pyenv/shims:/usr/local/bin:/usr/bin:/bin。所有对 Python 可执行文件的查找都会首先被这个 shims 路径截获，从而使后方的系统路径失效。</p><h2 id="安装之前"><a href="#安装之前" class="headerlink" title="安装之前"></a>安装之前</h2><p>不同系统请参考 <a href="https://github.com/pyenv/pyenv/wiki/Common-build-problems" target="_blank" rel="noopener">Common build problems</a>，安装必须的工具。</p><h2 id="pyenv安装"><a href="#pyenv安装" class="headerlink" title="pyenv安装"></a>pyenv安装</h2><h3 id="安装homebrew"><a href="#安装homebrew" class="headerlink" title="安装homebrew"></a>安装homebrew</h3><p><a href="https://brew.sh/" target="_blank" rel="noopener">如何安装homebrew？</a></p><h3 id="安装pyenv"><a href="#安装pyenv" class="headerlink" title="安装pyenv"></a>安装pyenv</h3><h4 id="使用homebrew安装"><a href="#使用homebrew安装" class="headerlink" title="使用homebrew安装"></a>使用homebrew安装</h4><p>Mac下安装了<code>homebrew</code>之后使用<code>homebrew</code>安装<code>pyenv</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install pyenv</span><br><span class="line">brew upgrade pyenv #之后如果需要更新pyenv</span><br></pre></td></tr></table></figure><p>在安装成功之后需要在<code>.bashrc</code>或者<code>.bash_profile</code>中添加三行来开启自动补全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br><span class="line">eval &quot;$(pyenv virtualenv-init -)&quot;</span><br></pre></td></tr></table></figure><h4 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h4><p><code>pyenv</code>提供了自动安装的工具，执行命令安装即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure><p>需要保证系统又<code>git</code>，否则需要安装<code>git</code>。</p><h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>也可以采用手动安装的方式，将<code>pyenv</code>检出到你想安装的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">git clone git://github.com/yyuu/pyenv.git .pyenv</span><br><span class="line">echo &apos;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&apos; &gt;&gt; ~/.bashrc</span><br><span class="line">echo &apos;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&apos; &gt;&gt; ~/.bashrc</span><br><span class="line">echo &apos;eval &quot;$(pyenv init -)&quot;&apos; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>添加环境变量。<code>PYENV_ROOT</code> 指向 <code>pyenv</code> 检出的根目录，并向 <code>$PATH</code> 添加 <code>$PYENV_ROOT/bin</code> 以提供访问 <code>pyenv</code>命令的路径。</p><p>这里的 shell 配置文件<code>（~/.bash_profile）</code>依不同 Linux 而需作修改，如果使用 Zsh 则需要相应的配置 ~/.zshrc</p><p>在使用 <code>pyenv</code> 之后使用 <code>pip</code> 安装的第三方模块会自动安装到当前使用 python 版本下，不会和系统模块产生冲突。使用 pip 安装模块之后，如果没有生效，记得使用 <code>pyenv rehash</code> 来更新垫片路径。</p><h3 id="pyenv常用命令"><a href="#pyenv常用命令" class="headerlink" title="pyenv常用命令"></a>pyenv常用命令</h3><p>使用<code>pyenv commands</code>可以查看所有pyenv命令。</p><h4 id="查看已安装Python版本"><a href="#查看已安装Python版本" class="headerlink" title="查看已安装Python版本"></a>查看已安装Python版本</h4><ul><li><code>pyenv versions</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ferdinand@ferdinanddeMacBook-Pro  ~  pyenv versions</span><br><span class="line">  system</span><br><span class="line">* 3.6.3 (set by /Users/ferdinand/.python-version)</span><br></pre></td></tr></table></figure><p>带*号的是当前路径下所使用的Python版本。</p><h4 id="查看可安装的Python版本"><a href="#查看可安装的Python版本" class="headerlink" title="查看可安装的Python版本"></a>查看可安装的Python版本</h4><ul><li><code>pyenv install -l</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">erdinand@ferdinanddeMacBook-Pro  ~  pyenv install -l</span><br><span class="line">Available versions:</span><br><span class="line">  2.1.3</span><br><span class="line">  2.2.3</span><br><span class="line">  2.3.7</span><br><span class="line">  2.4</span><br><span class="line">  2.4.1</span><br><span class="line">  2.4.2</span><br><span class="line">  2.4.3</span><br><span class="line">  2.4.4</span><br><span class="line">  2.4.5</span><br><span class="line">  2.4.6</span><br><span class="line">  2.5</span><br><span class="line">  2.5.1</span><br><span class="line">  2.5.2</span><br><span class="line">  2.5.3</span><br><span class="line">  2.5.4</span><br><span class="line">  2.5.5</span><br><span class="line">  2.5.6</span><br><span class="line">  2.6.6</span><br><span class="line">  2.6.7</span><br><span class="line">  2.6.8</span><br><span class="line">  2.6.9</span><br><span class="line">  2.7-dev</span><br><span class="line">  2.7</span><br><span class="line">  2.7.1</span><br><span class="line">  2.7.2</span><br><span class="line">  2.7.3</span><br><span class="line">  …………</span><br></pre></td></tr></table></figure><h4 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install &lt;version&gt; # version为版本号</span><br></pre></td></tr></table></figure><h4 id="Python版本管理"><a href="#Python版本管理" class="headerlink" title="Python版本管理"></a>Python版本管理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyenv global &lt;version&gt;  # 全局设置python版本为指定版本，设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。</span><br><span class="line">pyenv local &lt;version&gt;   # 设置当前路径下python版本为指定版本，设置 Python 本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。</span><br><span class="line">pyenv shell &lt;version&gt;   # 设置当前shell窗口使用的python版本为指定版本，设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。这个版本的优先级比 local 和 global 都要高。–unset 参数可以用于取消当前 shell 设定的版本。</span><br></pre></td></tr></table></figure><p>使用pyenv切换Python 版本之后可以通过<code>which python</code>或者是<code>python --version</code>来查看是否生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ferdinand@ferdinanddeMacBook-Pro  ~  which python</span><br><span class="line">/Users/ferdinand/.pyenv/shims/python</span><br><span class="line">ferdinand@ferdinanddeMacBook-Pro  ~  python --version</span><br><span class="line">Python 3.6.3</span><br></pre></td></tr></table></figure><ul><li>Python版本的优先级</li></ul><blockquote><p>shell &gt; local &gt; global</p><p>pyenv会从当前目录开始向上逐级查找<code>.python-versiob</code>文件，直到根目录为止，若找不到，则使用global版本。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv rehash  # 创建垫片路径（为所有已安装的可执行文件创建 shims，如：~/.pyenv/versions/*/bin/*，因此，每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令）</span><br></pre></td></tr></table></figure><h4 id="Python卸载"><a href="#Python卸载" class="headerlink" title="Python卸载"></a>Python卸载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyenv isntall &lt;version&gt; # 安装版本号为&lt;version&gt;的Python</span><br><span class="line">pyenv uninstall &lt;version&gt; #卸载版本号为&lt;version&gt;的Python</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;在Python开发中，会遇到多个版本进行开发部署的情况，本文记录在Mac OS下多个版本Python如何进行管理。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.huangxiang666.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.huangxiang666.com/tags/Python/"/>
    
      <category term="Pyenv" scheme="http://www.huangxiang666.com/tags/Pyenv/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下关于将普通用户权限提升为root的问题</title>
    <link href="http://www.huangxiang666.com/Ubuntu%E4%B8%8B%E5%85%B3%E4%BA%8E%E5%B0%86%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E4%B8%BAroot%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>http://www.huangxiang666.com/Ubuntu下关于将普通用户权限提升为root的问题.html</id>
    <published>2017-12-11T09:17:47.561Z</published>
    <updated>2017-12-20T09:16:05.086Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="问题的由来"><a href="#问题的由来" class="headerlink" title="问题的由来"></a>问题的由来</h3><ul><li>博主一个好奇就想把自己的那个用户提升为root级别的，所以进行了如下操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">vi etc/passwd</span><br><span class="line">然后将自己创建的那个用户（博主的用户名为lucas），对应的值</span><br><span class="line">lucas:x:1000:0:lucas,,,:/home/lucas:/bin/bash</span><br><span class="line">中的1000修改成了和root用户一样的0.</span><br><span class="line"></span><br><span class="line">好吧，这下lucas确实成了root用户了，但是问题就来了，你下次登录的适合界面上只剩下客人会话了。其它会话都没了。</span><br></pre></td></tr></table></figure></li></ul><h3 id="解决措施"><a href="#解决措施" class="headerlink" title="解决措施"></a>解决措施</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在用户登录界面，按下 `ctrl+alt+f7`进入命令行界面。</span><br><span class="line">按照如下操作进行：</span><br><span class="line">输入用户名：lucas（博主的）</span><br><span class="line">输入密码：xxxxxx</span><br><span class="line">然后使用vi命令打开我们修改过的文件：/etc/passwd</span><br><span class="line">将0修改成原来的数值。这样我们的登录界面又会出现用户登录啦！</span><br><span class="line">好吧。。至此，问题解决。</span><br></pre></td></tr></table></figure><p>PS：博主的Linux系统的Ubuntu kylin 15.10 的版本。具体的原因是ubuntu从12.04开始，添加了额外的root保护，不允许直接开启root账户，强制使账户改为root账户会被屏蔽。所以以后不能再继续作死了。老老实实的用sudo吧。%&gt;_&lt;%。</p><p>记录时间：2015年12月10日19:05:05。下班吃饭。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;由于博主刚刚接触linux，所以喜欢瞎琢磨。现在记录一下在将普通用户提升为root用户时出现的问题 &lt;/blockquote&gt;
    
    </summary>
    
      <category term="错误收集" scheme="http://www.huangxiang666.com/categories/%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="ubuntu" scheme="http://www.huangxiang666.com/tags/ubuntu/"/>
    
      <category term="root权限" scheme="http://www.huangxiang666.com/tags/root%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>浏览器是如何工作的</title>
    <link href="http://www.huangxiang666.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84.html"/>
    <id>http://www.huangxiang666.com/浏览器是如何工作的.html</id>
    <published>2017-03-29T03:10:38.000Z</published>
    <updated>2017-12-20T09:14:44.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="why？"><a href="#why？" class="headerlink" title="why？"></a>why？</h2><ul><li>Web浏览器是世界上使用最广泛的软件。</li><li>浏览器提供web资源并创建可以允许web应用程序的沙箱环境。</li><li>浏览器实现这一点的方式非常复杂，并且由许多不同的标准决定。</li><li>浏览器的一些机制其实是具有着欺骗性和反直觉性。</li><li>了解浏览器的工作原理为我们提高网站/网页类应用程序的效率和代码的组织结构提供了理论依据。</li></ul><a id="more"></a><h2 id="复杂"><a href="#复杂" class="headerlink" title="复杂"></a>复杂</h2><ul><li>这里无法讲解浏览器工作原理的所有细节。</li><li>每个浏览器都有自己的实现方式。</li></ul><h2 id="一般和模块化的方法"><a href="#一般和模块化的方法" class="headerlink" title="一般和模块化的方法"></a>一般和模块化的方法</h2><ul><li>浏览器遵循相同的标准</li><li>大多数浏览器有着相同的总体结构和同样的模块</li></ul><p><strong>本文将讨论这些共同行为。</strong></p><h2 id="浏览器的两个主要模块"><a href="#浏览器的两个主要模块" class="headerlink" title="浏览器的两个主要模块"></a>浏览器的两个主要模块</h2><ul><li>渲染引擎（也成为布局引擎）</li><li>Javascript解释器</li></ul><h3 id="不同浏览器使用的渲染引擎不一样"><a href="#不同浏览器使用的渲染引擎不一样" class="headerlink" title="不同浏览器使用的渲染引擎不一样"></a>不同浏览器使用的渲染引擎不一样</h3><ul><li>Mozilla Firefox 使用 <code>Gecko</code></li><li>Safari 和 Google Chrome（version 27之前）使用<code>Webkit</code>。</li><li>Chrome使用<code>Blink</code>在version 27之后</li></ul><h3 id="一个web页面的组成"><a href="#一个web页面的组成" class="headerlink" title="一个web页面的组成"></a>一个web页面的组成</h3><ul><li>HTML：应用程序的内容</li><li>CSS： 内容的样式</li><li>Javascript： 应用程序的逻辑部分，有时也是一些动画(animations)等等。</li><li>其它</li></ul><h3 id="渲染引擎（rendering-engine）的工作"><a href="#渲染引擎（rendering-engine）的工作" class="headerlink" title="渲染引擎（rendering engine）的工作"></a>渲染引擎（rendering engine）的工作</h3><p>从HTML,CSS,JS开始，将网页呈现在用户屏幕上，大概需要经过四个阶段：</p><ol><li>处理HTML构建DOM，处理CSS构建CSSOM</li><li>将DOM和CSSOM合并到一个渲染树中</li><li>布局渲染树（render tree）,通过几何计算</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;why？&quot;&gt;&lt;a href=&quot;#why？&quot; class=&quot;headerlink&quot; title=&quot;why？&quot;&gt;&lt;/a&gt;why？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Web浏览器是世界上使用最广泛的软件。&lt;/li&gt;
&lt;li&gt;浏览器提供web资源并创建可以允许web应用程序的沙箱环境。&lt;/li&gt;
&lt;li&gt;浏览器实现这一点的方式非常复杂，并且由许多不同的标准决定。&lt;/li&gt;
&lt;li&gt;浏览器的一些机制其实是具有着欺骗性和反直觉性。&lt;/li&gt;
&lt;li&gt;了解浏览器的工作原理为我们提高网站/网页类应用程序的效率和代码的组织结构提供了理论依据。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.huangxiang666.com/categories/web/"/>
    
    
      <category term="web" scheme="http://www.huangxiang666.com/tags/web/"/>
    
      <category term="浏览器" scheme="http://www.huangxiang666.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器从请求发出到返回经历了什么</title>
    <link href="http://www.huangxiang666.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%AF%B7%E6%B1%82%E5%8F%91%E5%87%BA%E5%88%B0%E8%BF%94%E5%9B%9E%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88.html"/>
    <id>http://www.huangxiang666.com/浏览器从请求发出到返回经历了什么.html</id>
    <published>2017-03-22T03:11:07.000Z</published>
    <updated>2017-12-20T09:14:08.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个最简单的http请求，没有代理，ipv4和以下任何步骤都没有问题的情况下："><a href="#一个最简单的http请求，没有代理，ipv4和以下任何步骤都没有问题的情况下：" class="headerlink" title="一个最简单的http请求，没有代理，ipv4和以下任何步骤都没有问题的情况下："></a>一个最简单的http请求，没有代理，ipv4和以下任何步骤都没有问题的情况下：</h2><ol><li>浏览器检查缓存，如果请求的对象在缓存中并且是新的，跳到步骤9。</li><li>浏览器从OS获取服务器的ip地址。</li><li>OS进行DNS查找，并将IP地址返回给浏览器。<a id="more"></a></li><li>浏览器打开到服务器的TCP连接（如果是https则步骤更复杂点,后面再分析）。</li><li>浏览器通过TCP连接发送HTTP请求。</li><li>浏览器接受http响应，并可能关闭TCP连接或将其重新用于另一个请求。</li><li>浏览器检查响应是重定向还是条件响应（3xx的状态码）,授权请求（401），错误（4xx或5xx）等。这些与正常响应（2xx）的处理方式不同。</li><li>如果允许缓存，响应将存储在缓存中。</li><li>浏览器解码响应（比如响应是gzip的需要解压缩）</li><li>浏览器决定如何处理响应（它可能是一个HTML页面，可能是一张图片，也可能是一个声音片段）。</li><li>浏览器渲染响应，或者提示无法识别的类型弹出框警告。</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一个最简单的http请求，没有代理，ipv4和以下任何步骤都没有问题的情况下：&quot;&gt;&lt;a href=&quot;#一个最简单的http请求，没有代理，ipv4和以下任何步骤都没有问题的情况下：&quot; class=&quot;headerlink&quot; title=&quot;一个最简单的http请求，没有代理，ipv4和以下任何步骤都没有问题的情况下：&quot;&gt;&lt;/a&gt;一个最简单的http请求，没有代理，ipv4和以下任何步骤都没有问题的情况下：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;浏览器检查缓存，如果请求的对象在缓存中并且是新的，跳到步骤9。&lt;/li&gt;
&lt;li&gt;浏览器从OS获取服务器的ip地址。&lt;/li&gt;
&lt;li&gt;OS进行DNS查找，并将IP地址返回给浏览器。
    
    </summary>
    
      <category term="web" scheme="http://www.huangxiang666.com/categories/web/"/>
    
    
      <category term="web" scheme="http://www.huangxiang666.com/tags/web/"/>
    
      <category term="浏览器" scheme="http://www.huangxiang666.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate学习教程（二）----ORM 概述</title>
    <link href="http://www.huangxiang666.com/Hibernate%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89-ORM-%E6%A6%82%E8%BF%B0.html"/>
    <id>http://www.huangxiang666.com/Hibernate学习教程（二）-ORM-概述.html</id>
    <published>2017-03-17T09:52:32.000Z</published>
    <updated>2017-03-28T08:39:39.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是JDBC"><a href="#什么是JDBC" class="headerlink" title="什么是JDBC"></a>什么是JDBC</h3><ul><li><p>JDBC:Java Database Connectivity，提供一组Java API，用于java程序中访问关系数据库。通过这些API，Java程序能够执行SQL语句并与任何SQL兼容的数据库进行交互。</p></li><li><p>JDBC提供了一种灵活的架构，可以编写一个独立于数据库的应用程序，该应用程序可以在不同的平台上并与不同的DBMS进行修改。</p></li></ul><h3 id="JDBC的优点和缺点"><a href="#JDBC的优点和缺点" class="headerlink" title="JDBC的优点和缺点"></a>JDBC的优点和缺点</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>简洁的SQL处理</td><td>用于大型应用程序时比较复杂</td></tr><tr><td>处理大量数据有着良好的性能</td><td>资源占用开销比较大</td></tr><tr><td>非常适用于小型应用程序</td><td>没有进行封装抽象</td></tr><tr><td>语法简单，学习成本较低</td><td>很难用于MVC模式开发</td></tr><tr><td></td><td>只能用于DBMS查询</td></tr></tbody></table><h3 id="为什么要进行ORM关系映射-Object-Relational-Mapping"><a href="#为什么要进行ORM关系映射-Object-Relational-Mapping" class="headerlink" title="为什么要进行ORM关系映射(Object Relational Mapping)"></a>为什么要进行ORM关系映射(Object Relational Mapping)</h3><p>当我们使用面向对象的系统时，对象模型与关系数据库之间存在不匹配。RDBMS以表格形式表示数据，而面向对象的语言（如Java和C#）将其表现为对象的互联图。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String first_name; </span><br><span class="line">   <span class="keyword">private</span> String last_name;   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.first_name = fname;</span><br><span class="line">      <span class="keyword">this</span>.last_name = lname;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> first_name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> last_name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> salary;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的对象需要被存储和检索到下面的RDBMS表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> EMPLOYEE (</span><br><span class="line">   <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">   first_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">   last_name  <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">   salary     <span class="built_in">INT</span>  <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>那么就会存在以下两个问题：</p><ul><li>如果我们需要在开发了几个页面之后或在应用程序中修改数据库的设计时，应该怎么处理？</li><li>在关系数据库加载和存储对象会暴露以下不匹配问题：</li></ul><table><thead><tr><th>不匹配问题</th><th>描述</th></tr></thead><tbody><tr><td>Granularity（粒度）</td><td>有时，您将有一个对象模型，它具有比数据库中对应表数量更多的类。</td></tr><tr><td>Inheritance（继承）</td><td>RDBMS不定义类似于继承的任何东西，它是面向对象编程语言中的自然范例。</td></tr><tr><td>Identity（对象同一性）</td><td>RDBMS正好定义了“同一性”的一个概念：主键。然而，Java定义了对象标识（a == b）和对象相等（a.equals（b））</td></tr><tr><td>Associations</td><td>面向对象语言使用对象引用表示Associations，RDBMS使用外键列表示</td></tr><tr><td>Navigation</td><td>在Java和RDBMS中访问对象的方式是完全不同的</td></tr></tbody></table><p>对象关系映射（ORM）是处理所有上述不匹配问题的解决方案。</p><h4 id="粒度问题"><a href="#粒度问题" class="headerlink" title="粒度问题"></a>粒度问题</h4><ul><li>粒度：是指你正在使用的类型的大小。</li></ul><h4 id="继承（子类型问题）"><a href="#继承（子类型问题）" class="headerlink" title="继承（子类型问题）"></a>继承（子类型问题）</h4><ul><li>在Java中，使用超类(superclass)和子类(subclass)来实现继承模型。</li><li>在Java中，继承是类型继承(type Inheritance)，而数据库表并不是一种类型。</li><li>数据库产品一般不实现类型或者表继承。而且即使实现了，我们也会遇到数据完整性的问题（对可更新视图的有限完整性规则）。</li><li>一旦把继承进入到模型当中，就有了<code>多态(polymorphism)</code>的可能。SQL数据库缺乏一种明显的表示多态关联的方式，一个外键约束精确的引用一张目标表，定义一个引用多表的外键并不容易。必须编写一个程序化的约束来加强这种完整性规则。</li></ul><p><strong>子类型的这种不匹配的结果是：模型中的继承结构必须在一个不提供继承策略的SQL数据库中被持久化。</strong></p><h3 id="对象同一性"><a href="#对象同一性" class="headerlink" title="对象同一性"></a>对象同一性</h3><p>如果当我们需要检查两个对象是否为同一个对象的时候。解决方法有三种：</p><ul><li><p>在java中：</p><ul><li>对象同一性（粗略等同于内存位置，用a==b检查）</li><li>等同性，通过equals()方法（也成为值等同）的实现来确定。</li></ul></li><li><p>数据库的同一性用主键值来表达。如果使用java中的方法来判断，那么主键值必然会不相等。</p><h3 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h3></li></ul><p>ORM（对象关系映射），是一种用于关系数据库和面向对象编程语言（如Java、C#）之间转换数据的编程技术。相对于JDBC，ORM具有以下优点：</p><table><thead><tr><th>序号</th><th>优点</th></tr></thead><tbody><tr><td>1</td><td>允许业务逻辑代码访问对象而不是数据库表</td></tr><tr><td>2</td><td>从面向对象的角度考虑隐藏SQL查询的详细信息</td></tr><tr><td>3</td><td>底层基于JDBC</td></tr><tr><td>4</td><td>无需处理数据库实现</td></tr><tr><td>5</td><td>基于业务概念而不是数据库结构的实体</td></tr><tr><td>6</td><td>事务管理和秘钥自动生成</td></tr><tr><td>7</td><td>应用快速开发</td></tr></tbody></table><p>ORM解决方案由以下四个模块组成：</p><table><thead><tr><th>序号</th><th>解决方案</th></tr></thead><tbody><tr><td>1</td><td>用于对持久化类的对象进行基本CRUD操作的API</td></tr><tr><td>2</td><td>用于指定引用类的类和属性的查询的语言或API</td></tr><tr><td>3</td><td>用于指定映射元数据的可配置工具</td></tr><tr><td>4</td><td>用于实现ORM的一项技术，与事务对象交互，执行脏检查、延迟关联抓取以及其它优化功能</td></tr></tbody></table><h3 id="Java中的ORM框架"><a href="#Java中的ORM框架" class="headerlink" title="Java中的ORM框架"></a>Java中的ORM框架</h3><p>Java中有几个持久化框架和ORM选项。持久化框架是一种将对象存储和检索到关系数据库中的ORM服务。</p><ul><li>Enterprise JavaBeans Entity Beans</li><li>Java Data Objects</li><li>Castor</li><li>TopLink</li><li>Spring DAO</li><li>Hibernate</li><li>……. etc.</li></ul><h3 id="ORM和Hibernate的一些好处"><a href="#ORM和Hibernate的一些好处" class="headerlink" title="ORM和Hibernate的一些好处"></a>ORM和Hibernate的一些好处</h3><h4 id="生产力"><a href="#生产力" class="headerlink" title="生产力"></a>生产力</h4><p>与持久化相关的代码可能会是java中最冗长的一部分代码，Hibernate除去了许多琐碎的工作，让我们可以把更多的精力集中于业务问题的处理上。<br>无论我们喜欢哪一种应用程序开发策略——自上而下，从一个领域模型开始；或者自底而上，从一个现有的数据库Schema开始——Hibernate与适当的工具一起使用，将明显减少开发时间。</p><h4 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h4><p>更少的代码行使得系统更易于理解，因为它强调业务逻辑甚于那些费力的基础性工作。更重要的是，系统包含的代码越少则越利于重构。自动的对象/关系持久化充分减少了代码行。</p><p>Hibernate更易于维护还有其它原因，在手工编码的持久化系统中，关系表示法和对象模型实现领域之间存在一种必然的压力。改变一个，通常都要改变另一个，并且一个表示法设计通常需要妥协以便适应另一个的存在。ORM提供了两个模型之间的一个缓冲，允许面向对象在Java方面进行更优雅的利用，并且每个模型的微小变化都不会传递到另一个模型。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>手工编码的持久化和自动的持久化相比总是可以一样快，并且经常更快。这是事实。但是在实际开发中，会受到时间和预算的约束。</p><p>在有限时间的项目中，手工编码的持久化通常允许你进行一些优化；Hibernate始终允许使用更多的优化。</p><p>自动的持久化能够大大提高开发人员的工作效率，使得开发人员能够花更多的时间对其它少数瓶颈进行手工优化。</p><p>实现ORM框架的人，可能在性能优化方面比我们做的更好。</p><h4 id="供应商独立性"><a href="#供应商独立性" class="headerlink" title="供应商独立性"></a>供应商独立性</h4><p>ORM从底层的SQL数据库和SQL方言中把应用程序抽象出来。如果这个工具支持不同的数据库，这会给我们的应用程序带来一定程度的可移植性。可以帮我们减少一些被供应商锁定的风险。</p><p>数据库的独立性使得我们可以在开发时选择一些轻量级的数据库，在部署时，将实际的产品部署在不同的数据库上。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Hibernate是一个ORM框架，这里主要介绍了一下ORM的必要性以及ORM的一些相关概念&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Hibernate" scheme="http://www.huangxiang666.com/categories/Hibernate/"/>
    
    
      <category term="Hibernate" scheme="http://www.huangxiang666.com/tags/Hibernate/"/>
    
      <category term="ORM框架" scheme="http://www.huangxiang666.com/tags/ORM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="javaweb" scheme="http://www.huangxiang666.com/tags/javaweb/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate教程（一）---Hibernate简介</title>
    <link href="http://www.huangxiang666.com/Hibernate%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>http://www.huangxiang666.com/Hibernate教程（一）.html</id>
    <published>2017-03-17T03:14:02.000Z</published>
    <updated>2017-03-17T09:44:28.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hibernate简介"><a href="#Hibernate简介" class="headerlink" title="Hibernate简介"></a>Hibernate简介</h2><ul><li><p>Hibernate是一个Java对象映射关系的解决方案的ORM（Object-Relational Mapping）框架，是一个开源持久框架，由<code>Gavin King</code>于2001年创建。为Java应用提供强大的、高性能对象持久化和查询服务。</p></li><li><p>Hibernate将Java类映射到数据库表，将Java数据类型映射到SQL数据类型，减轻了开发人员95%的数据持久性相关的编程任务。</p></li><li><p>Hibernate位于传统的Java对象和数据库服务器之间，基于适当的<code>O/R机制和模式</code>来处理持久化这些对象的所有工作。</p></li></ul><p><img src="http://7xt7l1.com1.z0.glb.clouddn.com/hibernate_position.jpg" alt="Hibernate-position"></p><h3 id="Hibernate的优势"><a href="#Hibernate的优势" class="headerlink" title="Hibernate的优势"></a>Hibernate的优势</h3><ul><li>Hibernate通过XML配置文件将Java类映射到数据库表，而不需要编写任何代码。</li><li>提供简单的API,用于直接存储和检索数据库中的Java对象。</li><li>如果数据库或任何表中有更改，只需要修改XML文件。</li><li>提取我们不熟悉的SQL类型，并提供我们熟悉的Java对象。</li><li>Hibernate不需要应用府服务器来操作。</li><li>操作复杂关联的数据库对象。</li><li>使用智能抓取策略简化数据库操作。</li><li>提供简单的数据查询。</li></ul><h3 id="Hibernate支持的数据库"><a href="#Hibernate支持的数据库" class="headerlink" title="Hibernate支持的数据库"></a>Hibernate支持的数据库</h3><p>Hibernate几乎支持所有的关系型数据库管理系统(RDBMS),支持的数据库如下所示：</p><ul><li>HSQL Database Engine</li><li>DB2/NT</li><li>MySQL</li><li>PostgreSQL</li><li>FrontBase</li><li>Oracle</li><li>Microsoft SQL Server Database</li><li>Sybase SQL Server</li><li>nformix Dynamic Server</li></ul><h3 id="Hibernate架构"><a href="#Hibernate架构" class="headerlink" title="Hibernate架构"></a>Hibernate架构</h3><p>Hibernate架构是分层的，所以我们不需要知道底层的API，Hibernate利用数据库和配置数据向我们的应用程序提供持久性服务（和持久性对象）。</p><p>下图是Hibernate应用结构体系简要视图：<br><img src="http://7xt7l1.com1.z0.glb.clouddn.com/hibernate_high_level.jpg" alt="Hibernate-hign-level"></p><p>下图是Hibernate应用结构体系详细视图，包含了几个重要的核心类：<br><img src="http://7xt7l1.com1.z0.glb.clouddn.com/hibernate_architecture.jpg" alt="Hibernate架构"></p><ul><li>Hibernate使用各种现有的Java API，如<code>JDBC</code>,<code>JTA</code>,<code>JNDI</code>。<blockquote><p><code>JDBC</code>提供了关系数据库通用的功能抽象层，所有具有<code>JDBC</code>驱动程序的数据库都被<code>Hibernate</code>支持。<br><code>JTA</code>和<code>JNDI</code>允许<code>Hibernate</code>与J2EE服务器集成。</p></blockquote></li></ul><h2 id="Hibernate应用结构体系主要类对象"><a href="#Hibernate应用结构体系主要类对象" class="headerlink" title="Hibernate应用结构体系主要类对象"></a>Hibernate应用结构体系主要类对象</h2><h3 id="Configuration-Object"><a href="#Configuration-Object" class="headerlink" title="Configuration Object"></a>Configuration Object</h3><p><code>Configuration Object</code>是我们在Hibernate应用程序中创建的第一个Hibernate对象，通常在应用程序初始化时且只创建一次。它是Hibernate所需要的配置和属性文件。Configuration对象提供两个关键组件：</p><ul><li><strong>Database Connection:</strong>通过Hibernate支持的一个或多个配置文件来处理。<code>hibernate.properties</code>,<code>hibernate.cfg.xml</code>。</li><li><strong>Class Mapping Setup:</strong>这个组件用于Java类和数据库表之间创建连接。</li></ul><h3 id="SessionFactory-Object"><a href="#SessionFactory-Object" class="headerlink" title="SessionFactory Object"></a>SessionFactory Object</h3><p><code>Configuration Object</code>用于创建一个<code>SessionFactory Obejct</code>，该对象使用提供的配置文件为应用程序配置<code>Hibernate</code>，并允许实例化一个<code>Session</code>对象。<code>SessionFactory</code>是<code>线程安全对象</code>,供应用程序的所有线程使用。</p><p><code>SessionFactory</code>是重量级对象。因此通常在应用程序启动期间创建并保留供以后使用。</p><p>每个数据库都需要使用一个单独的配置文件创建一个<code>SessionFactory</code>对象。如果使用多个数据库，则必须创建多个<code>SessionFactory</code>对象。</p><h3 id="Session-会话-Object"><a href="#Session-会话-Object" class="headerlink" title="Session(会话) Object"></a>Session(会话) Object</h3><p><code>Session（会话）</code>用于获取与数据库的物理连接，Session对象是轻量级的，并且是每当需要与数据库进行交互时才会被实例化。持久化对象通过Session对象进行保存和检索。</p><p>Session对象不应该长时间保持打开，因为他们通常不是线程安全的，所以应该根据业务需求创建和销毁它们。</p><h3 id="Transaction（事务）-Object"><a href="#Transaction（事务）-Object" class="headerlink" title="Transaction（事务） Object"></a>Transaction（事务） Object</h3><p>事务<code>Transaction</code>代表与数据库的工作单元，大多数关系型数据库都支持事务功能。Hibernate中的事务由底层事务管理器和事务（来自JDBC和JTA）处理。</p><p>这是一个可选对象，Hibernate应用程序可以选择不使用此接口，而选择在自己的应用程序代码中管理事务。</p><h3 id="Query-Object"><a href="#Query-Object" class="headerlink" title="Query Object"></a>Query Object</h3><p>查询<code>Query</code>对象使用SQL或者Hibernate查询语言(<code>Hibernate Query Language,HQL</code>)字符串从数据库检索数据并创建对象。Query实例用于绑定查询参数，限制查询返回的结果数量，最后执行查询。</p><h3 id="Criteria-Object"><a href="#Criteria-Object" class="headerlink" title="Criteria Object"></a>Criteria Object</h3><p>条件对象用于创建和执行面向对象的标准查询以检索对象。</p><h2 id="Hibernate-环境配置"><a href="#Hibernate-环境配置" class="headerlink" title="Hibernate 环境配置"></a>Hibernate 环境配置</h2><p>该章主要介绍如何安装Hibernate以及其它相关包来为Hibernate应用程序准备一个开发环境。本文将使用Mysql数据库来演示Hibernate实例。</p><h3 id="Hibernate下载"><a href="#Hibernate下载" class="headerlink" title="Hibernate下载"></a>Hibernate下载</h3><ul><li>在windows上下载<code>.zip</code>文件，在Unix上下载<code>.tz</code>文件。</li><li>从<a href="http://www.hibernate.org/downloads" title="hibernate下载链接" target="_blank" rel="noopener">http://www.hibernate.org/downloads</a>下载最新版的Hibernate。</li><li>下载完成之后进行解压。</li></ul><h3 id="安装Hibernate"><a href="#安装Hibernate" class="headerlink" title="安装Hibernate"></a>安装Hibernate</h3><p>下载完Hibernate之后，只需要执行以下两个简单的步骤即可。请确保正确的配置了<code>CLASSPATH</code>环境变量，否则在编译应用程序时会出现问题。</p><h3 id="Hibernate的依赖包"><a href="#Hibernate的依赖包" class="headerlink" title="Hibernate的依赖包"></a>Hibernate的依赖包</h3><table><thead><tr><th>S.N.</th><th>Packages/Libraries</th></tr></thead><tbody><tr><td>1</td><td>dom4j - XML parsing www.dom4j.org/</td></tr><tr><td>2</td><td>Xalan - XSLT Processor <a href="http://xml.apache.org/xalan-j/" target="_blank" rel="noopener">http://xml.apache.org/xalan-j/</a></td></tr><tr><td>3</td><td>Xerces - The Xerces Java Parser <a href="http://xml.apache.org/xerces-j/" target="_blank" rel="noopener">http://xml.apache.org/xerces-j/</a></td></tr><tr><td>4</td><td>cglib - Appropriate changes to Java classes at runtime <a href="http://cglib.sourceforge.net/" target="_blank" rel="noopener">http://cglib.sourceforge.net/</a></td></tr><tr><td>5</td><td>log4j - Logging Faremwork <a href="http://logging.apache.org/log4j" target="_blank" rel="noopener">http://logging.apache.org/log4j</a></td></tr><tr><td>6</td><td>Commons - Logging, Email etc. <a href="http://jakarta.apache.org/commons" target="_blank" rel="noopener">http://jakarta.apache.org/commons</a></td></tr><tr><td>7</td><td>SLF4J - Logging Facade for Java <a href="http://www.slf4j.org" target="_blank" rel="noopener">http://www.slf4j.org</a></td></tr></tbody></table><h3 id="Hibernate配置"><a href="#Hibernate配置" class="headerlink" title="Hibernate配置"></a>Hibernate配置</h3><p>Hibernate需要提前知道在哪里可以找到定义的Java类和数据库表相关联的映射信息。Hibernate还需要一组与数据库和其它相关参数相关的配置设置。所有这些信息通常作为标准java属性文件<code>hibernate.properties</code>或者名为<code>hibernate.cfg.xml</code>的XML文件提供。</p><h3 id="Hibernate属性"><a href="#Hibernate属性" class="headerlink" title="Hibernate属性"></a>Hibernate属性</h3><p>以下是在独立情况下为一个数据库配置所需要的重要属性列表：</p><table><thead><tr><th>S.N.</th><th>Properties and Description</th></tr></thead><tbody><tr><td>1</td><td><code>hibernate.dialect</code>:此属性使Hibernate为选定的数据库生成适当的SQL</td></tr><tr><td>2</td><td><code>hibernate.connection.driver_class</code>:JDBC驱动程序类</td></tr><tr><td>3</td><td><code>hibernate.connection.url</code>:数据库实例的JDBC URL</td></tr><tr><td>4</td><td><code>hibernate.connection.username</code>:数据库用户名</td></tr><tr><td>5</td><td><code>hibernate.connection.password</code>:数据库密码</td></tr><tr><td>6</td><td><code>hibernate.connection.pool_size</code>:限制在Hibernate数据库连接池中的等待连接数</td></tr><tr><td>7</td><td><code>hibernate.connection.autocommit</code>:允许JDBC连接自动提交</td></tr></tbody></table><p>如果随着应用服务器和JNDI使用同一个服务器，则还需要配置以下属性：</p><table><thead><tr><th>S.N.</th><th>Properties and Description</th></tr></thead><tbody><tr><td>1</td><td><code>hibernate.connection.datasource</code>:在应用服务器中定义的JNDI名称</td></tr><tr><td>2</td><td><code>hibernate.jndi.class</code>:JNDI的InitialContext类</td></tr><tr><td>3</td><td><code>hibernate.jndi.&lt;JNDIpropertyname&gt;</code>:</td></tr><tr><td>4</td><td><code>hibernate.jndi.url</code>:提供JNDI的url</td></tr><tr><td>5</td><td><code>hibernate.connection.username</code>:数据库用户名</td></tr><tr><td>6</td><td><code>hibernate.connection.password</code>:数据库密码</td></tr></tbody></table><h3 id="Hibernate和Mysql数据库"><a href="#Hibernate和Mysql数据库" class="headerlink" title="Hibernate和Mysql数据库"></a>Hibernate和Mysql数据库</h3><p><code>MySQL</code>是目前最流行的开源数据库系统之一，下面我们创建一个<code>hibernate.cfg.xml</code>配置文件，并将其放置于应用程序类路径的根目录下，必须确保已经安装<code>MySQL</code> 并保证已经保证创建了可用的测试数据库。<br>XML配置文件必须符合Hibernate 3 Configuration DTD，该文件可从<a href="http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd获得。" target="_blank" rel="noopener">http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd获得。</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration SYSTEM </span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span></span><br><span class="line">      org.hibernate.dialect.MySQLDialect</span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span></span><br><span class="line">      com.mysql.jdbc.Driver</span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- Assume test is the database name --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span></span><br><span class="line">      jdbc:mysql://localhost/test</span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span></span><br><span class="line">      root</span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span></span><br><span class="line">      root123</span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- List of XML mapping files --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"Employee.hbm.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>下表是各类数据库的属性类型(<code>Dialect Property</code>)列表：</p><table><thead><tr><th>Database</th><th>Dialect Property</th></tr></thead><tbody><tr><td>DB2</td><td>org.hibernate.dialect.DB2Dialect</td></tr><tr><td>HSQLDB</td><td>org.hibernate.dialect.HSQLDialect</td></tr><tr><td>HypersonicSQL</td><td>org.hibernate.dialect.HSQLDialect</td></tr><tr><td>Informix</td><td>org.hibernate.dialect.InformixDialect</td></tr><tr><td>Ingres</td><td>org.hibernate.dialect.IngresDialect</td></tr><tr><td>Interbase</td><td>org.hibernate.dialect.InterbaseDialect</td></tr><tr><td>Microsoft SQL Server 2000</td><td>org.hibernate.dialect.SQLServerDialect</td></tr><tr><td>Microsoft SQL Server 2005</td><td>org.hibernate.dialect.SQLServer2005Dialect</td></tr><tr><td>Microsoft SQL Server 2008</td><td>org.hibernate.dialect.SQLServer2008Dialect</td></tr><tr><td>MySQL</td><td>org.hibernate.dialect.MySQLDialect</td></tr><tr><td>Oracle (any version)</td><td>org.hibernate.dialect.OracleDialect</td></tr><tr><td>Oracle 11g</td><td>org.hibernate.dialect.Oracle10gDialect</td></tr><tr><td>Oracle 10g</td><td>org.hibernate.dialect.Oracle10gDialect</td></tr><tr><td>Oracle 9i</td><td>org.hibernate.dialect.Oracle9iDialect</td></tr><tr><td>PostgreSQL</td><td>org.hibernate.dialect.PostgreSQLDialect</td></tr><tr><td>Progress</td><td>org.hibernate.dialect.ProgressDialect</td></tr><tr><td>SAP DB</td><td>org.hibernate.dialect.SAPDBDialect</td></tr><tr><td>Sybase</td><td>org.hibernate.dialect.SybaseDialect</td></tr><tr><td>Sybase Anywhere</td><td>org.hibernate.dialect.SybaseAnywhereDialect</td></tr></tbody></table><h2 id="Hibernate实例"><a href="#Hibernate实例" class="headerlink" title="Hibernate实例"></a>Hibernate实例</h2><h3 id="创建POJO类"><a href="#创建POJO类" class="headerlink" title="创建POJO类"></a>创建POJO类</h3><ul><li>首先，我们创建<code>Java POJO类</code>，这取决于将被持久化到数据库的应用程序，生成<code>getXXX()</code>和<code>setXXX()</code>方法，使其成为<code>JavaBeans</code>兼容类。</li><li>POJO（java普通对象）是一种java对象，它不扩展或实现一些EJB框架分别需要的一些专门的类或接口。所有正常的Java对象都是POJO。</li><li>当你设计一个要被Hibernate持久化的类时，提供符合JavaBeans的代码以及一个在Employee类中像id属性一样用作索引的属性很重要。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String firstName; </span><br><span class="line">   <span class="keyword">private</span> String lastName;   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = fname;</span><br><span class="line">      <span class="keyword">this</span>.lastName = lname;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">( <span class="keyword">int</span> id )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">( String first_name )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = first_name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">( String last_name )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.lastName = last_name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> salary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">( <span class="keyword">int</span> salary )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><p>第二步，我们需要在数据库中创建一张表，将表对应我们需要持久化的每一个对象，根据上面的java类我们创建下面这样一个表“</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> EMPLOYEE (</span><br><span class="line">   <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">   first_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">   last_name  <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">   salary     <span class="built_in">INT</span>  <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="创建配置映射文件"><a href="#创建配置映射文件" class="headerlink" title="创建配置映射文件"></a>创建配置映射文件</h3><p>接下来我们需要创建一个配置文件，说明Hibernate如何将定义的类映射至数据库表。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta"> "-//Hibernate/Hibernate Mapping DTD//EN"</span></span><br><span class="line"><span class="meta"> "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Employee"</span> <span class="attr">table</span>=<span class="string">"EMPLOYEE"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">attribute</span>=<span class="string">"class-description"</span>&gt;</span></span><br><span class="line">         This class contains the employee detail. </span><br><span class="line">      <span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"firstName"</span> <span class="attr">column</span>=<span class="string">"first_name"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lastName"</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"salary"</span> <span class="attr">column</span>=<span class="string">"salary"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们应该把映射文件保存为<code>&lt;classname&gt;.hbm.xml</code>格式的文件。上面文件保存为<code>Employee.hbm.xml</code>。</p><ul><li>映射文件是一个XML格式的文档。<code>&lt;hibernate-mapping&gt;</code>作为包含所有<code>&lt;class&gt;</code>元素的根元素。</li><li><code>&lt;class&gt;</code>元素用于定义从java类到数据库表的特定映射。<code>java类名称</code>使用使用类元素的<code>name属性</code>指定，并且使用<code>table</code>属性指定数据库表名称。</li><li><code>&lt;meta&gt;</code>元素是可选元素，用于创建类描述。</li><li><code>&lt;id&gt;</code>是将类中的唯一ID元素映射到数据库表的主键。id元素中的name属性引用类中的属性，cloumn属性引用数据库表中的列。type属性保存hibernate映射类型，此映射类型将从Java转换成SQL数据类型。</li><li>id元素中的<code>&lt;generator&gt;</code>属性用于自动生成主键值，设置class的属性值为<code>native</code>，让hibernate选择<code>identity</code>，<code>sequence</code>,<code>hilo</code>算法来创建主键，这取决于底层数据库的能力。</li><li><code>&lt;property&gt;</code>元素用于将Java类属性映射到数据库表中的列。元素的name属性引用类中的属性，cloumn属性引用数据库表中的列。type属性保存hibernate映射类型，此映射类型将从Java类型转换成SQL数据类型。</li></ul><h3 id="创建应用类-java-class"><a href="#创建应用类-java-class" class="headerlink" title="创建应用类(java class)"></a>创建应用类(java class)</h3><p>完成了以上步骤后，我们来创建一个应用文件来测试一下我们的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List; </span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.hibernate.HibernateException; </span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session; </span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManageEmployee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SessionFactory factory; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         factory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Throwable ex) &#123; </span><br><span class="line">         System.err.println(<span class="string">"Failed to create sessionFactory object."</span> + ex);</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(ex); </span><br><span class="line">      &#125;</span><br><span class="line">      ManageEmployee ME = <span class="keyword">new</span> ManageEmployee();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 添加一些employee对象到数据库表中*/</span></span><br><span class="line">      Integer empID1 = ME.addEmployee(<span class="string">"Zara"</span>, <span class="string">"Ali"</span>, <span class="number">1000</span>);</span><br><span class="line">      Integer empID2 = ME.addEmployee(<span class="string">"Daisy"</span>, <span class="string">"Das"</span>, <span class="number">5000</span>);</span><br><span class="line">      Integer empID3 = ME.addEmployee(<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 列出所有employee对象 */</span></span><br><span class="line">      ME.listEmployees();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 修改 */</span></span><br><span class="line">      ME.updateEmployee(empID1, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 从数据库中删除 */</span></span><br><span class="line">      ME.deleteEmployee(empID2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 列出所有对象s */</span></span><br><span class="line">      ME.listEmployees();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 向数据库中添加employee对象的方法 */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">addEmployee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> salary)</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      Integer employeeID = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         Employee employee = <span class="keyword">new</span> Employee(fname, lname, salary);</span><br><span class="line">         employeeID = (Integer) session.save(employee); </span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> employeeID;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 列出所有employee对象的方法 */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listEmployees</span><span class="params">( )</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         List employees = session.createQuery(<span class="string">"FROM Employee"</span>).list(); </span><br><span class="line">         <span class="keyword">for</span> (Iterator iterator = </span><br><span class="line">                           employees.iterator(); iterator.hasNext();)&#123;</span><br><span class="line">            Employee employee = (Employee) iterator.next(); </span><br><span class="line">            System.out.print(<span class="string">"First Name: "</span> + employee.getFirstName()); </span><br><span class="line">            System.out.print(<span class="string">"  Last Name: "</span> + employee.getLastName()); </span><br><span class="line">            System.out.println(<span class="string">"  Salary: "</span> + employee.getSalary()); </span><br><span class="line">         &#125;</span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 修改employee对象的方法 */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateEmployee</span><span class="params">(Integer EmployeeID, <span class="keyword">int</span> salary )</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         Employee employee = </span><br><span class="line">                    (Employee)session.get(Employee.class, EmployeeID); </span><br><span class="line">         employee.setSalary( salary );</span><br><span class="line"> session.update(employee); </span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 删除employee对象的方法 */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteEmployee</span><span class="params">(Integer EmployeeID)</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         Employee employee = </span><br><span class="line">                   (Employee)session.get(Employee.class, EmployeeID); </span><br><span class="line">         session.delete(employee); </span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译和执行"><a href="#编译和执行" class="headerlink" title="编译和执行"></a>编译和执行</h3><p>编译和执行的步骤（请确保正确配置了环境变量）：</p><ul><li>创建<code>hibernate.cfg.xml</code>配置文件。</li><li>创建<code>Employee.hbm.xml</code>映射文件。</li><li>创建<code>Employee.java</code>文件，并编译它。</li><li>创建如上所示的<code>ManageEmployee.java</code>文件，并执行编译。</li><li>执行<code>ManageEmployee.class</code>文件，运行程序。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Hibernate是一个java对象映射关系的解决方案的ORM（Object-Relational Mapping）框架，是一个开源持久框架，由`Gavin King`于2001年创建。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Hibernate" scheme="http://www.huangxiang666.com/categories/Hibernate/"/>
    
    
      <category term="ORM框架" scheme="http://www.huangxiang666.com/tags/ORM%E6%A1%86%E6%9E%B6/"/>
    
      <category term="javaweb" scheme="http://www.huangxiang666.com/tags/javaweb/"/>
    
      <category term="hibernate" scheme="http://www.huangxiang666.com/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>《Java解惑》读书笔记</title>
    <link href="http://www.huangxiang666.com/%E3%80%8AJava%E8%A7%A3%E6%83%91%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>http://www.huangxiang666.com/《Java解惑》读书笔记.html</id>
    <published>2017-03-06T08:50:16.000Z</published>
    <updated>2017-12-20T09:13:10.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="表达式之谜"><a href="#表达式之谜" class="headerlink" title="表达式之谜"></a>表达式之谜</h2><h3 id="奇数性"><a href="#奇数性" class="headerlink" title="奇数性"></a>奇数性</h3><p>奇数：被2整除余1的数。表达式i%2是计算i除以2时所产生的余数。这个表达式其实是错误的。<br>在所有的int数值中，有一半的值为负数，当值为负数时，无论该值为奇数还是偶数，结果都会返回false。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hx.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(isOdd(-<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">//return i % 2 == 1;  // 这个表达式是错误的。</span></span><br><span class="line"><span class="comment">//return i % 2 != 0; // 正确</span></span><br><span class="line"><span class="keyword">return</span> (i &amp; <span class="number">1</span>) != <span class="number">0</span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="找零时刻"><a href="#找零时刻" class="headerlink" title="找零时刻"></a>找零时刻</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hx.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="number">2.00</span> - <span class="number">1.10</span>);  <span class="comment">// 输出结果0.8999999999999999</span></span><br><span class="line">System.out.println((<span class="number">200</span>-<span class="number">110</span>)+<span class="string">"cents"</span>); <span class="comment">//输出结果 90 cents</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> BigDecimal(<span class="string">"2.00"</span>).subtract(<span class="keyword">new</span> BigDecimal(<span class="string">"1.10"</span>))); <span class="comment">//输出结果0.9</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要使用精确数值的地方，要避免使用<code>float</code>和<code>double</code>，对于货币计算，要使用<code>int</code>,<code>long</code>,<code>BigDecimal</code>。</p><h3 id="长整除"><a href="#长整除" class="headerlink" title="长整除"></a>长整除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hx.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> MICROS_PRE_DAY = <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>*<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> MILLS_PRE_DAY = <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//final long MICROS_PRE_DAY = 24L*60*60*1000*1000;</span></span><br><span class="line"><span class="comment">//final long MILLS_PRE_DAY = 24L*60*60*1000;</span></span><br><span class="line"></span><br><span class="line">System.out.println(MICROS_PRE_DAY/MILLS_PRE_DAY); <span class="comment">// 为什么结果会打印5？？？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当操作很大的数字时，千万要提防溢出。即便用来保存结果的变量足够大，也并不意味着要产生结果的计算具有正确的类型。当拿不准的时候，就使用<code>long</code>运算来执行整个计算。</p><h3 id="十六进制的趣事"><a href="#十六进制的趣事" class="headerlink" title="十六进制的趣事"></a>十六进制的趣事</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hx.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(Long.toHexString(<span class="number">0x100000000L</span> + <span class="number">0xcafebabe</span>));  <span class="comment">// cafebabe</span></span><br><span class="line">System.out.println(Long.toHexString(<span class="number">0x100000000L</span> + <span class="number">0xcafebabeL</span>)); <span class="comment">// 1cafebabe</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混合类型的计算可能产生混淆，尤其需要注意的是十六进制和八进制字面常量无需显式的减号符号就可以表示负的数值，为了避免这种窘境，通常最好避免混合类型的计算。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;本片文章主要记录《Java解惑》的一些收获。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.huangxiang666.com/categories/Java/"/>
    
    
      <category term="java解惑" scheme="http://www.huangxiang666.com/tags/java%E8%A7%A3%E6%83%91/"/>
    
      <category term="表达式" scheme="http://www.huangxiang666.com/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>windows下的cmd神器:Cmder介绍及其设置</title>
    <link href="http://www.huangxiang666.com/windows%E4%B8%8B%E7%9A%84cmd%E7%A5%9E%E5%99%A8-Cmder.html"/>
    <id>http://www.huangxiang666.com/windows下的cmd神器-Cmder.html</id>
    <published>2017-02-28T08:22:22.000Z</published>
    <updated>2017-02-28T08:22:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xt7l1.com1.z0.glb.clouddn.com/%E8%BD%AF%E4%BB%B6%E4%B8%BB%E7%95%8C%E9%9D%A2.jpg" alt="Cmder主界面"></p><a id="more"></a><h2 id="Cmder的安装"><a href="#Cmder的安装" class="headerlink" title="Cmder的安装"></a>Cmder的安装</h2><p>cmder官网： <a href="http://cmder.net/" title="官网" target="_blank" rel="noopener">http://cmder.net/</a><br>Github：<a href="https://github.com/cmderdev/cmder" title="github地址" target="_blank" rel="noopener">https://github.com/cmderdev/cmder</a></p><ol><li><p>官网安装<br><img src="http://7xt7l1.com1.z0.glb.clouddn.com/cmder%E5%AE%98%E7%BD%91.jpg" alt="Cmder官网截图"><br><img src="http://7xt7l1.com1.z0.glb.clouddn.com/cmder%E5%AE%98%E7%BD%91%E6%88%AA%E5%9B%BEdownload.jpg" alt="cmder官网截图download"><br>在官网上,我们可以看到<code>Download</code>模块，分为min版和full版，两者的区别在于：full版集成了<code>msysgit</code>工具，是<code>Git for Windows</code>的标准配置，除了git本身这个命令之外，里面还有大量的linux命令，比如 grep, curl(没有 wget)； 像vim, grep, tar, unzip, ssh, ls, bash, perl 对于爱折腾的Coder更是痛点需求。</p><ul><li>将下载的压缩包解压到你想放置的目录。</li><li>点击Cmder.exe即可运行。</li></ul></li></ol><h2 id="Cmder配置及相关设置"><a href="#Cmder配置及相关设置" class="headerlink" title="Cmder配置及相关设置"></a>Cmder配置及相关设置</h2><h3 id="乱码和文字重叠"><a href="#乱码和文字重叠" class="headerlink" title="乱码和文字重叠"></a>乱码和文字重叠</h3><p>当我们使用<code>ls</code>命令查看文件目录时，发现，中文被显示成了一些奇怪的乱码，将以下几行代码配置在<code>cmder/config/user-aliases</code>下即可解决问题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l=ls --show-control-chars</span><br><span class="line">la=ls -aF --show-control-chars</span><br><span class="line">ll=ls -alF --show-control-chars</span><br><span class="line">ls=ls --show-control-chars -F</span><br></pre></td></tr></table></figure></p><p>如果进行了以上配置还存在乱码问题时，还能尝试进行如下配置：<br><img src="http://7xt7l1.com1.z0.glb.clouddn.com/cmder%E7%9A%84win+alt+p%E7%95%8C%E9%9D%A2.jpg" alt="cmder乱码设置"></p><h3 id="启动Cmder"><a href="#启动Cmder" class="headerlink" title="启动Cmder"></a>启动Cmder</h3><p>前文已经说过，Cmder无需安装，解压即可运行。<code>Cmder</code>点击<code>Cmder.exe</code>即可运行，显然，这样打开是非常不方便的，所以，我们可以进行如下配置：</p><ol><li><p>将cmder添加入环境变量<br>将<code>cmder.exe</code>所在的目录添加至系统环境变量。添加完之后，使用<code>win+r</code>输入<code>cmder</code>即可运行<code>Cmder</code>。<br>右键点击<code>我的电脑---&gt;属性</code>,然后如下图所示进行配置即可：<br><img src="http://7xt7l1.com1.z0.glb.clouddn.com/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE.jpg" alt="cmder环境变量设置"></p></li><li><p>添加cmser至右键菜单<br>能不能将cmder添加到右键，让我们可以在任意文件目录下打开<code>cmder</code>呢？如果能这样使用那么简直是不能太赞了！！答案是完全可以的，因为在上一步骤我们已经将<code>cmder</code>加入了环境变量，所以我们只需要进行如下配置即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 以系统管理员权限打开cmd窗口，输入以下代码，回车即可。</span><br><span class="line">Cmder.exe /REGISTER ALL</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://7xt7l1.com1.z0.glb.clouddn.com/cmder%20here.jpg" alt="cmder here"></p><h3 id="默认开启设置"><a href="#默认开启设置" class="headerlink" title="默认开启设置"></a>默认开启设置</h3><p>作为强大的存在，必然支持私人定制。输入<code>win + alt + p</code> 或者 在底部右击点击 <code>settings</code>, 进入设置页面；可以根据自己的所需进行各种配置(字体，皮肤等等等等)。</p><p>目前游走在前端，Gulp已离不开，<code>Cmder+PowerShell</code>这个组合无疑是运行<code>gulp</code>的利器。如下图所示，可以设置<code>PowerShell</code>作为默认开启的选项；也可以更改默认开启是所在目录。<br><img src="http://7xt7l1.com1.z0.glb.clouddn.com/cmder%20powershell.jpg" alt="cmder powershell"></p><h2 id="Cmder常用功能介绍"><a href="#Cmder常用功能介绍" class="headerlink" title="Cmder常用功能介绍"></a>Cmder常用功能介绍</h2><p>Cmder功能非常强大，也有许多功能：</p><ol><li><p>Cmder常用快捷键</p><ul><li><code>Tab</code>：自动路径补全</li><li><code>ctrl+T</code>:建立新页签</li><li><code>ctrl+W</code>：关闭页签</li><li><code>ctrl+tab</code>：切换页签</li><li><code>alt_f4</code>:关闭所有页签</li><li><code>alt+shift+1</code>:开启cmd.exe</li><li><code>alt+shift+2</code>:开启powershell.exe</li><li><code>alt+shift+3</code>:开启powershell.exe（系统管理员权限）</li><li><code>ctrl+1</code>:快速切换到第一个页签</li><li><code>ctrl+n</code>:快速切换到第n个页签</li><li><code>alt+enter</code>:切换到全屏状态</li><li><code>ctrl+r</code>:历史命令搜索</li></ul></li><li><p>可在视窗内搜寻画面上曾经出现过的任意字</p></li><li>新增页签按钮，可透过滑鼠新增页签</li><li>切换页签按钮，可透过滑鼠切换页签</li><li>锁定视窗，让视窗无法再输入</li><li>切换视窗是否提供卷轴功能，启动时可查询之前显示过的内容</li><li>按下滑鼠左键可开启系统菜单，滑鼠右键可开启工具选项视窗，<code>win+alt+p</code>开启工具选项视窗。</li></ol><h2 id="cmder元件组成"><a href="#cmder元件组成" class="headerlink" title="cmder元件组成"></a>cmder元件组成</h2><p><code>Cmder</code>集成了多套软体，其中最重要的是<code>msysgit</code>、<code>ConEmu</code>、<code>Clink</code>。</p><ul><li>msysgit除了提供git for windows相关工具之外，还提供了多套Unix/linux环境下常用的指令工具，例如：less、ls、tar、grep等。</li><li>ConEmu体验不如cmder</li><li>Clink将GNU Readline 函式库整合进原生的Windows 命令提示字元视窗，提供命令列模式下强大的编辑与输入能力，这也是用了cmder 之后会这么像在Linux 环境下使用的感觉。</li></ul><h3 id="Chocolatey软件包管理系统"><a href="#Chocolatey软件包管理系统" class="headerlink" title="Chocolatey软件包管理系统"></a>Chocolatey软件包管理系统</h3><p>在 Linux 下，大家喜欢用<code>apt-get(mac下用brew)</code>来安装应用程序，如今在 windows 下，大家可以使用<code>Chocolatey</code>来快速下载搭建一个开发环境。<code>Chocolatey</code>的哲学就是完全用命令行来安装应用程序， 它更像一个包管理工具（背后使用<code>Nuget</code>）<br>另外需要说明的是，<code>Chocolatey</code>只是把官方下载路径封装到了<code>Chocolatey</code>中，所以下载源都是其官方路径，所以下载的一定是合法的，但是如果原软件是需要 Licence 注册的话，那么<code>Chocolatey</code>下载安装好的软件还是需要你去购买注册。不过<code>Chocolatey</code>一般还是会选用免费 Licence 可用的软件。</p><p>安装chocolatey , 运行如下命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin</span><br></pre></td></tr></table></figure></p><p>安装软件命令<code>choco install softwareName</code>, 短写是<code>cinst softwareName</code><br>可安装的应用程序，可以参见其 Package列表<br>以下是window下开发常用的开发环境应用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">choco install autohotkey.portable    #安装 AutoHotkey (Portable)</span><br><span class="line">choco install nodejs.install  #安装 node</span><br><span class="line">choco install git.install     #安装 git</span><br><span class="line">choco install ruby            #安装 ruby</span><br><span class="line">choco install python          #安装 python</span><br><span class="line">choco install jdk8            #安装 JDK8</span><br><span class="line">choco install googlechrome    #安装 Chrome</span><br><span class="line">choco install google-chrome-x64 #Google Chrome (64-bit only)</span><br><span class="line">choco install firefox         #安装 firefox</span><br><span class="line">choco install notepadplusplus.install #安装 notepad++</span><br><span class="line">choco install Atom                    #安装 Atom</span><br><span class="line">choco install SublimeText3            #安装 SublimeText3</span><br></pre></td></tr></table></figure></p><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ul><li><code>Cmder</code>还增加了<code>alias</code>功能;他让你用短短的指令执行一些常见但指令超长又难以记忆的语法;比如 <code>ls</code> <code>cls</code>等等；在其控制台输入<code>alias</code>可以查看。</li><li>主控台文字自动放大缩小功能，你只要按下Ctrl+滑鼠滚轮就可以办到;果你用支援两点触控的笔电，也可以在触控板上用两指放大的手势调整文字大小。还有：up，向上翻历史命令;</li><li>Cmder有极为简单的复制粘贴操作。Ctr+V直接粘贴;用鼠标选中你想拷贝的内容，自动就复制到剪切板；天神，这悉数的美感;点赞!</li><li>自定义aliases:打开Cmder目录下的config文件夹，里面的aliases文件就是我们可以配置的别名文件，只需将里面ls命令的别名按下列方式修改就可以在ls命令下显示中文。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;**Cmder**是windows系统环境下的命令行工具。对于使用过linux系统的人来说，windows下的cmd工具简直让我无法忍受，不过`Cmder`这款工具对于由于某些原因不得不在windows下进行工作的人来说，确实是一个福音。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="常用工具" scheme="http://www.huangxiang666.com/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="cmder" scheme="http://www.huangxiang666.com/tags/cmder/"/>
    
      <category term="cmd.linux" scheme="http://www.huangxiang666.com/tags/cmd-linux/"/>
    
      <category term="shell" scheme="http://www.huangxiang666.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下jdk环境变量的配置</title>
    <link href="http://www.huangxiang666.com/ubuntu%E4%B8%8Bjdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE.html"/>
    <id>http://www.huangxiang666.com/ubuntu下jdk环境变量配置.html</id>
    <published>2017-02-28T08:21:21.000Z</published>
    <updated>2017-02-28T08:21:21.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Linux下jdk环境变量的配置"><a href="#Linux下jdk环境变量的配置" class="headerlink" title="Linux下jdk环境变量的配置"></a>Linux下jdk环境变量的配置</h2><p>PS:博主的系统版本是 ubuntu kylin 15.10。</p><h3 id="下载、及安装"><a href="#下载、及安装" class="headerlink" title="下载、及安装"></a>下载、及安装</h3><ul><li>下载:<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li><li>下载完成之后就是解压了：</li></ul><blockquote><ol><li>进入到文件目录下执行该指令<code>sudo tar zxvf ./jdk-8u65-linux-x64.tar.gz</code></li><li>安装完成之后就是配置环境变量啦<br>2.1 打开/etc/profile文件：<code>sudo gedit /etc/profile</code><br>2.2 添加如下环境变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#set java environment  </span><br><span class="line">  </span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk版本 </span><br><span class="line">  </span><br><span class="line">export JRE_HOME=/usr/local/java/jdk版本/jre  </span><br><span class="line">  </span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH  </span><br><span class="line">  </span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH</span><br></pre></td></tr></table></figure></li></ol><p>2.3 使得修改生效：一种是使用重启的方式使得修改生效，另一种则是使用<code>source /etc/profile</code>也可以使修改生效。</p><ol><li>输入<code>java -version</code>测试是否配置成功。<br>3.1 出现以下代码表示配置成功：</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lucas@lucas-ThinkPad-PC:~/java$ java -version</span><br><span class="line">java version &quot;1.8.0_65&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_65-b17)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.65-b01, mixed mode)</span><br></pre></td></tr></table></figure><blockquote><p>3.2 如出现如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">程序 &apos;java&apos; 已包含在下列软件包中：</span><br><span class="line"> * default-jre</span><br><span class="line"> * gcj-4.6-jre-headless</span><br><span class="line"> * gcj-4.7-jre-headless</span><br><span class="line"> * openjdk-7-jre-headless</span><br><span class="line"> * openjdk-6-jre-headless</span><br><span class="line">请尝试：sudo apt-get install &lt;选定的软件包&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>则可以通过以下方式来解决：</p><ul><li>在终端输入如下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 这里是输入你的jdk安装目录以及版本号，具体的根据自己的设置去配。</span><br><span class="line">sudo update-alternatives --install /usr/bin/java java /home/lester/develop/jdk1.6.0_37/bin/java 300</span><br><span class="line"></span><br><span class="line">sudo update-alternatives --install /usr/bin/javac javac /home/lester/develop/jdk1.6.0_37/bin/javac 300</span><br></pre></td></tr></table></figure></li></ul><p>在配置完以上信息之后，再去<code>java -version</code> 进行测试。就能看到成功配置的信息啦！～</p><p>好了，初次接触linux下的开发，确实会遇到许多的问题，博主会将这些常见的问题一一记录下来，以便自己查看，也为了让其他和我一样刚入门的新手一些参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;由于博主刚刚接触linux，记录一下ubuntu下jdk环境变量的配置过程。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.huangxiang666.com/categories/java/"/>
    
    
      <category term="ubuntu" scheme="http://www.huangxiang666.com/tags/ubuntu/"/>
    
      <category term="java环境变量" scheme="http://www.huangxiang666.com/tags/java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
      <category term="jdk" scheme="http://www.huangxiang666.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下Apache2服务器的搭建</title>
    <link href="http://www.huangxiang666.com/Ubuntu%E4%B8%8BApache2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA.html"/>
    <id>http://www.huangxiang666.com/Ubuntu下Apache2服务器的搭建.html</id>
    <published>2017-02-28T08:21:02.000Z</published>
    <updated>2017-12-20T09:16:14.771Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Apache服务器的下载与安装"><a href="#Apache服务器的下载与安装" class="headerlink" title="Apache服务器的下载与安装"></a>Apache服务器的下载与安装</h2><p>博主选择的是使用apt-get开发包打包的方式安装的。下面是安装步骤：</p><ul><li><p>安装apache，在命令行终端中输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install apache2</span><br></pre></td></tr></table></figure></li><li><p>如果网络连接正常的话，应该是会顺利安装好的，在安装完成之后，需要重启apache服务，在命令行终端中输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/apache2 restart</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt;  如果重启之后出现如下提示，则表示服务器已经启动成功了。</span><br></pre></td></tr></table></figure></li></ul><p>lucas@lucas-ThinkPad-PC:~$ sudo /etc/init.d/apache2 restart<br>[ ok ] Restarting apache2 (via systemctl): apache2.service.<br>```</p><blockquote><p>可能出现的问题1： NameVirtualHost * :80 has no VirtualHost.</p><blockquote><p>出现上述问题的原因：定义了多个NameVirtualHost，我们只需要将/etc/apahce2/ports.conf 中的NameVirtualHost * :80注释掉即可。</p></blockquote><p>可能出现的问题2： Could not reliably determine the server’s fully qualified domain name, using 127.0.1.1 for ServerName </p><ol><li>原因：根据提示，无法可靠的确定服务器的有效域名，使用127.0.1.1作为服务器域名。因此在下面的测试中，应该使用127.0.1.1，而不是127.0.0.1。</li><li>解决方法：终端输入<code>vim /etc/apache2/httpd.conf</code>，在文件中添加ServerName localhost:80 ，再次restart apache2,就可以使用127.0.0.1来访问web服务器了。</li></ol></blockquote><h2 id="Apache服务器的测试"><a href="#Apache服务器的测试" class="headerlink" title="Apache服务器的测试"></a>Apache服务器的测试</h2><p>既然已经安装好了，name我们当然应该测试一下了。</p><p>在浏览器中输入<code>http://localhost</code>或者<code>http://127.0.0.1</code>，如果看到了It works，那么就说明服务器成功安装了。Apache的默认安装，会在<code>var/www/</code>的目录，这个就是我们的web目录了，所有需要能够浏览器访问的web文件都要放在这个目录里。</p><p>下面是楼主的测试结果：<br><img src="http://7xt7l1.com1.z0.glb.clouddn.com/apache2%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87.jpg" alt="apahce服务器测试结果"></p><p>PS:好了。至此Ubuntu下Apache服务器的安装就已经完成，下面的文章中，我将继续Apache服务器配置文件的详解。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;刚接触服务器端的开发，今天上班头要求在unbuntu下先搭建一个服务器，于是乎，博主又开始摸索了。嗯～进入正题，楼主选择的是Apache服务器。楼主的系统版本是：Ubuntu Kylin 15.10.&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.huangxiang666.com/categories/web/"/>
    
    
      <category term="ubuntu" scheme="http://www.huangxiang666.com/tags/ubuntu/"/>
    
      <category term="Apache2" scheme="http://www.huangxiang666.com/tags/Apache2/"/>
    
      <category term="服务器" scheme="http://www.huangxiang666.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="linux" scheme="http://www.huangxiang666.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Bower:Additional error details:Name must be lowercase, can contain digits, dots, dashes, &quot;@&quot; or spaces</title>
    <link href="http://www.huangxiang666.com/bower%20error.html"/>
    <id>http://www.huangxiang666.com/bower error.html</id>
    <published>2017-02-28T08:20:29.000Z</published>
    <updated>2017-02-28T08:20:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在运行<code>bower install</code>安装第三方JS的时候，遇到以下错误提示：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E:\nginx-<span class="number">1.10</span>.2\html\parkhero2.0\master&gt;bower install</span><br><span class="line">bower                         EINVALID Failed to read E:\nginx-<span class="number">1.10</span>.2\html\parkhero2.0\master\bower.json</span><br><span class="line"></span><br><span class="line">Additional error details:</span><br><span class="line">Name must be lowercase, can contain digits, dots, dashes, <span class="string">"@"</span> or spaces</span><br></pre></td></tr></table></figure><p>看到这个错误有点懵比，因为一直是可以正常运行的，突然遇到这个错误，然后去检查了一下<code>bower.json</code>文件，发现错误的原因是：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">"name": "Park", // 错误就在这里，上面提示了name必须小写，可以包含数字、点、破折号、@和空格</span><br><span class="line">"version": "2.0.0",</span><br></pre></td></tr></table></figure></p><p>好吧，至此问题就解决了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;name&quot;: &quot;park&quot;, // 改成小写</span><br><span class="line">&quot;version&quot;: &quot;2.0.0&quot;,</span><br></pre></td></tr></table></figure></p><p>修改完之后运行<code>bower install</code>,正常运行了。这是个小错误，记录一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Bower:Additional error details:Name must be lowercase, can contain digits, dots, dashes, &quot;@&quot; or spaces&lt;/blockquote&gt;
    
    </summary>
    
      <category term="错误收集" scheme="http://www.huangxiang666.com/categories/%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="Bower" scheme="http://www.huangxiang666.com/tags/Bower/"/>
    
      <category term="web" scheme="http://www.huangxiang666.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>使用Crypto-JS进行加密，以及使用angular的方式进行封装调用</title>
    <link href="http://www.huangxiang666.com/%E4%BD%BF%E7%94%A8Crypto-JS%E8%BF%9B%E8%A1%8CAES%E5%8A%A0%E5%AF%86.html"/>
    <id>http://www.huangxiang666.com/使用Crypto-JS进行AES加密.html</id>
    <published>2017-02-28T08:18:50.000Z</published>
    <updated>2017-12-20T09:14:57.686Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><center><br>## 使用Crypto-JS进行AES加密<br></center><p></p><p>在最近的项目中，调用登录接口，需要对账号密码数据进行AES加密后再进行传输，使用的是<em><code>AES/ECB/PKCS5Padding</code></em>,我前端部分使用选择了<em><code>CryptoJS</code></em>,现在把使用的过程记录如下。</p><hr><h4 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h4><ul><li>Crypto-JS的encrypt函数不会返回字符串，需要调用对象的toString方法，或者通过Crypto-js转码才能得到真实的结果。</li></ul><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol><li><p>引入<code>Crypto-JS</code>中的 <code>aes.js</code>及相关模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;bower_components/cryptojs/aes.js&quot;,</span><br><span class="line">&quot;bower_components/cryptojs/enc-utf8.js&quot;,</span><br><span class="line">&quot;bower_components/cryptojs/pad-pkcs7.js&quot;,</span><br><span class="line">&quot;bower_components/cryptojs/mode-ecb.js&quot;</span><br></pre></td></tr></table></figure></li><li><p>调用CryptoJS.AES</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 官方示例, 每次输出的密文都不一样,这样使用的话是错误的</span></span><br><span class="line">CryptoJS.AES.encrypt(<span class="string">"Message"</span>, <span class="string">"Secret Passphrase"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 正确的使用姿势！！ */</span></span><br><span class="line"><span class="comment">// 使用用户名进行MD5，32位，作为key</span></span><br><span class="line"><span class="keyword">var</span> key_str = md5.createHash(username);</span><br><span class="line"><span class="comment">// 将key转换成128 bit</span></span><br><span class="line"><span class="keyword">var</span> key = CryptoJS.enc.Utf8.parse(key_str);</span><br><span class="line"><span class="comment">// 对password进行AES加密</span></span><br><span class="line"><span class="keyword">var</span> AESPass = CryptoJS.AES.encrypt(password, key, &#123;</span><br><span class="line">      mode: CryptoJS.mode.ECB,  <span class="comment">//补齐方式 CBC,ECB,etc.</span></span><br><span class="line">      padding: CryptoJS.pad.Pkcs7 <span class="comment">// 偏移规则设定  pack5，pkcs7，nopadding,etc.</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// CryptoJS 的 encrypt函数不会直接返回字符串，需要toString或者Crypto-JS进行转码才能得到真实的结果。</span></span><br><span class="line"><span class="keyword">var</span> pass = AESPass.toString();</span><br><span class="line"><span class="keyword">var</span> authData = Base64.encode(username + <span class="string">':'</span> + pass).replace(<span class="regexp">/[\r\n]/g</span>, <span class="string">''</span>); <span class="comment">// 去除回车换行符</span></span><br></pre></td></tr></table></figure><h3 id="使用AngularJS的方式调用CryptoJS-AES"><a href="#使用AngularJS的方式调用CryptoJS-AES" class="headerlink" title="使用AngularJS的方式调用CryptoJS.AES"></a>使用AngularJS的方式调用CryptoJS.AES</h3><ol><li>使用Angular将<code>AES</code>封装成一个<code>provider</code></li><li><p>提供两种方式设置key</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 一种为在angular.module('xxxx').config中进行设置，此种方式适用于key为一个固定值的情况</span></span><br><span class="line">CryptoKeyProvider.setCryptofraphyKey(<span class="string">'key'</span>) <span class="comment">// 在config中设置key</span></span><br><span class="line">$crypto.encrypto(<span class="string">'plaintext'</span>) <span class="comment">// 在业务逻辑处直接传入需要加密的明文进行调用</span></span><br><span class="line"><span class="comment">// 2. 第二种方式,每次都设置不同的key</span></span><br><span class="line">$crypto.encrypto(<span class="string">'plaintext'</span>,<span class="string">'key'</span>)</span><br></pre></td></tr></table></figure></li><li><p>具体源码如下：</p><blockquote><p>注意：解密时，需要先将密文转换成<code>Base64</code>的编码的格式。</p><blockquote><ol><li>使用<code>CryptoJS.enc.Hex.parse</code>转换成十六进制</li><li>使用<code>CryptoJS.enc.Base64.stringify</code>将其变成Base64编码的字符串</li><li>最后才能传入<code>CryptoJS.AES.decrypt</code>方法对其解密</li></ol></blockquote></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;由于项目需要，对于登陆接口的密码需要进行AES加密后才进行传输&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.huangxiang666.com/categories/web/"/>
    
    
      <category term="AES" scheme="http://www.huangxiang666.com/tags/AES/"/>
    
      <category term="Web开发" scheme="http://www.huangxiang666.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
      <category term="CryptoJS" scheme="http://www.huangxiang666.com/tags/CryptoJS/"/>
    
  </entry>
  
  <entry>
    <title>python基本常识</title>
    <link href="http://www.huangxiang666.com/python%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86.html"/>
    <id>http://www.huangxiang666.com/python基本常识.html</id>
    <published>2017-02-28T08:06:29.000Z</published>
    <updated>2017-12-20T09:41:00.645Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Python的语法格式"><a href="#Python的语法格式" class="headerlink" title="Python的语法格式"></a>Python的语法格式</h2><p>Python是一种计算机编程语言，有着自己的一套语法格式。Python的语法格式非常简单，采用缩进的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print absolute value of an integer:</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> a &gt;= <span class="number">0</span>:</span><br><span class="line">    print(a)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(-a)</span><br></pre></td></tr></table></figure><ul><li>以<code>#</code>开头的语句是注释，解释器会自动忽略。</li><li>当语句以<code>：</code>结束时，缩进的语句视为代码块。<blockquote><p>缩进有利有弊，好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是tab。按照约定俗成的习惯，应该使用<code>4个空格</code>的缩进。<br>缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把很长的一段代码拆分成若干函数，从而得到缩进较少的代码。<br>缩进的坏处就是“复制-粘贴”功能失效了，当我们重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像Java代码那样格式化Python代码。</p></blockquote></li><li>Python程序是大小写敏感的，如果写错了大小写，程序会报错。</li></ul><h2 id="Python的数据类型"><a href="#Python的数据类型" class="headerlink" title="Python的数据类型"></a>Python的数据类型</h2><p>在Python中，能够直接处理的数据类型有以下几种：</p><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：<code>1</code>，<code>100</code>，<code>-8080</code>，<code>0</code>，等等。</p><p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和<code>0-9</code>，<code>a-f</code>表示，例如：<code>0xff00</code>，<code>0xa5b4c3d2</code>，等等。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如<code>1.23</code>，<code>3.14</code>，<code>-9.01</code>，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把<code>10</code>用<code>e</code>替代，<code>1.23x109</code>就是<code>1.23e9</code>，或者<code>12.3e8</code>，<code>0.000012</code>可以写成<code>1.2e-5</code>，等等。</p><p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是以单引号’或双引号”括起来的任意文本，比如<code>&#39;abc&#39;</code>，<code>&quot;xyz&quot;</code>等等。请注意，<code>&#39;&#39;</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>&#39;abc&#39;</code>只有<code>a，b，c</code>这3个字符。如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I&#39;m OK&quot;</code>包含的字符是<code>I，&#39;，m，空格，O，K</code>这6个字符。</p><p>如果字符串内部既包含<code>&#39;</code>又包含”怎么办？可以用转义字符<code>\</code>来标识，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'I\'m \"OK\"!'</span></span><br></pre></td></tr></table></figure></p><p>表示的字符串内容是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I<span class="string">'m "OK"!</span></span><br></pre></td></tr></table></figure></p><p>转义字符\可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code>，可以在Python的交互式命令行用<code>print()</code>打印字符串看看：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'I\'m ok.'</span>)</span><br><span class="line">I<span class="string">'m ok.</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print('</span>I\<span class="string">'m learning\nPython.'</span>)</span><br><span class="line">I<span class="string">'m learning</span></span><br><span class="line"><span class="string">Python.</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print('</span>\\\n\\<span class="string">')</span></span><br><span class="line"><span class="string">\</span></span><br><span class="line"><span class="string">\</span></span><br></pre></td></tr></table></figure></p><p>如果字符串里面有很多字符都需要转义，就需要加很多<code>\</code>，为了简化，Python还允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义，可以自己试试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'\\\t\\'</span>)</span><br><span class="line">\       \</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r'\\\t\\'</span>)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure></p><p>如果字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容，可以自己试试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'''line1</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line2</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line3'''</span>)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure></p><p>上面是在交互式命令行内输入，注意在输入多行内容时，提示符由<code>&gt;&gt;&gt;</code>变为<code>...</code>，提示你可以接着上一行输入。如果写成程序，就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'''line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3'''</span>)</span><br></pre></td></tr></table></figure></p><p>多行字符串<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>还可以在前面加上r使用，请自行测试。</p><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 3 &gt; 2</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 3 &gt; 5</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p><p>布尔值可以用and、or和not运算。</p><p>and运算是与运算，只有所有都为True，and运算结果才是True：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">and</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">and</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">False</span> <span class="keyword">and</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt; <span class="number">3</span> <span class="keyword">and</span> <span class="number">3</span> &gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p>or运算是或运算，只要其中有一个为True，or运算结果就是True：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">or</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">or</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">False</span> <span class="keyword">or</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt; <span class="number">3</span> <span class="keyword">or</span> <span class="number">1</span> &gt; <span class="number">3</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p>not运算是非运算，它是一个单目运算符，把True变成False，False变成True：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="keyword">True</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="number">1</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p>布尔值经常用在条件判断中，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'teenager'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p><p>此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p><p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>变量a是一个整数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_007 = &apos;T007&apos;</span><br></pre></td></tr></table></figure></p><p>变量t_007是一个字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Answer = True</span><br></pre></td></tr></table></figure></p><p>变量Answer是一个布尔值True。</p><p>在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 123 # a是整数</span><br><span class="line">print(a)</span><br><span class="line">a = &apos;ABC&apos; # a变为字符串</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 123; // a是整数类型变量</span><br><span class="line">a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量</span><br></pre></td></tr></table></figure><p>和静态语言相比，动态语言更灵活，就是这个原因。</p><p>请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 10</span><br><span class="line">x = x + 2</span><br></pre></td></tr></table></figure><p>如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。</p><p>最后，理解变量在计算机内存中的表示也非常重要。当我们写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;ABC&apos;</span><br></pre></td></tr></table></figure><p>时，Python解释器干了两件事情：</p><p>在内存中创建了一个’ABC’的字符串；</p><p>在内存中创建了一个名为a的变量，并把它指向’ABC’。</p><p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;ABC&apos;</span><br><span class="line">b = a</span><br><span class="line">a = &apos;XYZ&apos;</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PI = 3.14159265359</span><br></pre></td></tr></table></figure><p>但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。</p><p>最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 / 3</span><br><span class="line">3.3333333333333335</span><br></pre></td></tr></table></figure><p>/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 9 / 3</span><br><span class="line">3.0</span><br></pre></td></tr></table></figure><p>还有一种除法是//，称为地板除，两个整数的除法仍然是整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 // 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。</p><p>因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 % 3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。</p><h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;包含中文的str&apos;)</span><br><span class="line">包含中文的str</span><br></pre></td></tr></table></figure><p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;A&apos;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord(&apos;中&apos;)</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">&apos;B&apos;</span><br><span class="line">&gt;&gt;&gt; chr(25991)</span><br><span class="line">&apos;文&apos;</span><br></pre></td></tr></table></figure><p>如果知道字符的整数编码，还可以用十六进制这么写str：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;\u4e2d\u6587&apos;</span><br><span class="line">&apos;中文&apos;</span><br></pre></td></tr></table></figure><p>两种写法完全是等价的。</p><p>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p><p>Python对bytes类型的数据用带b前缀的单引号或双引号表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = b&apos;ABC&apos;</span><br></pre></td></tr></table></figure><p>要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p><p>以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)</span><br><span class="line">b&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</p><p>在bytes中，无法显示为ASCII字符的字节，用\x##显示。</p><p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">&apos;中文&apos;</span><br></pre></td></tr></table></figure><p>要计算str包含多少个字符，可以用len()函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&apos;ABC&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(&apos;中文&apos;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(b&apos;ABC&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; len(&apos;中文&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</p><p>在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。</p><p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure><p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p><p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p><p>申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码.<br>如果.py文件本身使用UTF-8编码，并且也申明了# -<em>- coding: utf-8 -</em>-，打开命令提示符测试就可以正常显示中文。</p><p>##格式化</p><p>最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似’亲爱的xxx你好！你xx月的话费是xx，余额是xx’之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py-str-format</span><br></pre></td></tr></table></figure><p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</span><br><span class="line">&apos;Hello, world&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</span><br><span class="line">&apos;Hi, Michael, you have $1000000.&apos;</span><br></pre></td></tr></table></figure><p>你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。</p><p>常见的占位符有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%d整数</span><br><span class="line">%f浮点数</span><br><span class="line">%s字符串</span><br><span class="line">%x十六进制整数</span><br></pre></td></tr></table></figure><p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;%2d-%02d&apos; % (3, 1)</span><br><span class="line">&apos; 3-01&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;%.2f&apos; % 3.1415926</span><br><span class="line">&apos;3.14&apos;</span><br></pre></td></tr></table></figure><p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Age: %s. Gender: %s&apos; % (25, True)</span><br><span class="line">&apos;Age: 25. Gender: True&apos;</span><br></pre></td></tr></table></figure><p>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7</span><br><span class="line">&apos;growth rate: 7 %&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;本篇博客主要介绍Python的语法格式、Python的数据类型以及Python的一些编码规范。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.huangxiang666.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.huangxiang666.com/tags/Python/"/>
    
      <category term="Python学习笔记" scheme="http://www.huangxiang666.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>web开发中乱码问题的解决</title>
    <link href="http://www.huangxiang666.com/web%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3.html"/>
    <id>http://www.huangxiang666.com/web开发中乱码问题的解决.html</id>
    <published>2015-12-24T07:55:58.000Z</published>
    <updated>2017-12-20T09:15:35.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web开发中乱码问题的解决"><a href="#web开发中乱码问题的解决" class="headerlink" title="web开发中乱码问题的解决"></a>web开发中乱码问题的解决</h2><p>由于楼主刚刚接触web不久，自然而然的就遇到了乱码问题。下面就记录一下乱码问题的解决。</p><ol><li>表单的提交分为GET和POST两种请求方式。两种方式的乱码解决又不一样，用post提交请求时，只需要在接受的时候加上<code>request.setCharacterEncoding(&quot;utf-8&quot;);</code> 而GET的请求方法在处理时，应该将接收过来的值打碎成 <code>ISO-8859-1</code>编码，然后再组装成utf-8:<code>new String(request.getParameter(param).getBytes(&quot;iso-8859-1&quot;),&quot;UTF-8&quot;)</code>;</li></ol><a id="more"></a><ol><li><p>过滤器的乱码处理问题</p><blockquote><p>如果每次接收都像上面那样去处理的话肯定是太麻烦了，用过滤器来处理请求的乱码问题很方便，只需要写一个过滤器，就可以过滤所有请求页面的乱码问题了。至于如何用过滤器处理乱码请参考<a href="http://www.cnblogs.com/liuling/archive/2012/12/17/asdfsdfa.html" target="_blank" rel="noopener">用过滤器来解决JSP中的乱码问题</a>。不过值得注意的是，如果使用Struts的话，在web.xml里面处理编码的过滤器必须在struts过滤器前面注册，否则所有页面都不会经过过滤器。</p></blockquote></li><li><p>AJAX请求的乱码问题</p><blockquote><p>如果使用ajax出现了乱码问题这样解决：前端ajax函数的请求的url里面中文参数用两个encodeURI()函数处理，<code>var url=&quot;user.do?p=checkUser&amp;name=&quot;+encodingURI(encodingURI(username.value))&quot;</code>而服务器端则用 <code>URLDecoder.decode()</code>函数去接收，<code>string userName = URLDecoder.decode(request.getParameter(&quot;name&quot;),&quot;utf-8&quot;)</code>;   这样就能够解决ajax请求中乱码的问题了。</p></blockquote></li></ol><h2 id="PS-以上几条是摘自网上的。我暂时还没遇到。"><a href="#PS-以上几条是摘自网上的。我暂时还没遇到。" class="headerlink" title="PS:以上几条是摘自网上的。我暂时还没遇到。"></a>PS:以上几条是摘自网上的。我暂时还没遇到。</h2><ol><li>在我的项目中，遇到的问题是<code>发送get请求时出现乱码</code>，导致这个问题的原因是，我在<code>web.xml</code> 文件中之配置了针对post请求的编码设置，但是tomcat对POST和GET请求的处理方式是不一样的，我们要针对GET请求出现乱码问题的解决，就需要修改tomcat下的<code>server.xml</code>文件，如下所示：<br>将原来的配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ol><p>改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; useBodyEncodingForURI=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>然而，如果你修改的是tomcat安装目录下的<code>server.xml</code>文件的话，那么你在eclipse当中运行项目时会发现配置并没有起作用，这是因为eclipse在运行时用的是eclipse当中配置的tomact，所以我们需要<code>打开左侧项目列表server文件夹--&gt;tomcat--&gt;server.xml</code>按照以上的方式做同样的修改.</p><ul><li>！这里需要注意的是：<code>配置useBodyEncodingForURI=&quot;true&quot;后，可以解决普通get请求的中文乱码问题，但是对于通过ajax发起的get请求中文依然会乱码，请把useBodyEncodingForURI=&quot;true&quot;改为URIEncoding=&quot;UTF-8&quot;即可</code>。</li></ul><h4 id="然而经过了以上的设置之后，博主的乱码问题依然没有解决，如下图所示："><a href="#然而经过了以上的设置之后，博主的乱码问题依然没有解决，如下图所示：" class="headerlink" title="然而经过了以上的设置之后，博主的乱码问题依然没有解决，如下图所示："></a>然而经过了以上的设置之后，博主的乱码问题依然没有解决，如下图所示：</h4><p><img src="http://img.blog.csdn.net/20151224154555984" alt="乱码"></p><p>在建立一条新数据之后，显示出来的是一串的？？？？。好吧，这时候自然而然的想到了数据库的编码问题了。于是，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo /ect/init.d/mysql start</span><br><span class="line">mysql&gt; show variables like &quot;%char%&quot;;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | latin1                     |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | latin1                     |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br></pre></td></tr></table></figure><p>根据上面的显示我们可以发现<code>character-set-server</code>和<code>character-set-database</code>的编码是<code>latin1</code>，所以，接下来我就要将其修改为utf8了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1. 打开mysql的配置文件，ubuntu下是my.cnf</span><br><span class="line">lucas@lucas-ThinkPad-PC:~$ sudo vim /etc/mysql/my.cnf</span><br><span class="line">// 2. 在配置文件中加入以下一句</span><br><span class="line">character-set-server=utf8 // 自己根据对应的需要修改的在对应的节点下添加。</span><br><span class="line">// 3. 这样问题就解决了。</span><br></pre></td></tr></table></figure><p>我是使用命令行进行修改的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">lucas@lucas-ThinkPad-PC:~$ su</span><br><span class="line">root@lucas-ThinkPad-PC:/home/lucas# mysql -u root -p</span><br><span class="line"></span><br><span class="line">mysql&gt; set character_set_client=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set character_set_connection=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set character_set_database=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set character_set_results=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set character_set_server=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set character_set_system=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">mysql&gt; set collation_connection=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">mysql&gt; set collation_database=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">mysql&gt; set collation_server=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;character_set_%&apos;;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8                       |</span><br><span class="line">| character_set_connection | utf8                       |</span><br><span class="line">| character_set_database   | utf8                       |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8                       |</span><br><span class="line">| character_set_server     | utf8                       |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line">// 经过一番折腾之后，修改完毕，重启数据库，再运行一下项目，发现添加数据再也没有乱码了。</span><br></pre></td></tr></table></figure><p>当然，除此之外，还有一些乱码的问题，例如浏览器的默认编码啊什么的。这些直接设置一下浏览器的编码就行了。还有许多我暂时还没接触到的。等博主接触到了再加上去吧。继续上班。。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;在刚开始接触web开发的时候，博主在开发中也遇到了乱码的问题，在这里记录一下解决的过程。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="错误收集" scheme="http://www.huangxiang666.com/categories/%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="utf-8" scheme="http://www.huangxiang666.com/tags/utf-8/"/>
    
      <category term="编码" scheme="http://www.huangxiang666.com/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="乱码" scheme="http://www.huangxiang666.com/tags/%E4%B9%B1%E7%A0%81/"/>
    
      <category term="web开发" scheme="http://www.huangxiang666.com/tags/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>maven加入json-lib.jar报错Missing artifact net.sf.json-lib:json-lib:jar:2.4:compile</title>
    <link href="http://www.huangxiang666.com/maven%E5%8A%A0%E5%85%A5json-lib-jar%E6%8A%A5%E9%94%99Missing-artifact-net-sf-json-lib-json-lib-jar-2-4-compile.html"/>
    <id>http://www.huangxiang666.com/maven加入json-lib-jar报错Missing-artifact-net-sf-json-lib-json-lib-jar-2-4-compile.html</id>
    <published>2015-12-06T01:20:11.000Z</published>
    <updated>2017-12-20T09:15:17.999Z</updated>
    
    <content type="html"><![CDATA[<p>在pom.xml文件中添加json-lib：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;json-lib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>出现错误： <code>Missing artifact net.sf.json-lib:json-lib:jar:2.4:compile</code></p><p>出现错误的原因：json-lib是区分jdk版本的，pom.xml中的配置应该加上标签classifiter指定jdk版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;json-lib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">    &lt;!-- 加上jdk版本,如jdk15 --&gt;</span><br><span class="line">    &lt;classifier&gt;jdk15&lt;/classifier&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这样，错误就解决了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;在使用maven加入json-lib.jar的时候遇到的一个问题&lt;/blockquote&gt;
    
    </summary>
    
      <category term="错误收集" scheme="http://www.huangxiang666.com/categories/%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="java" scheme="http://www.huangxiang666.com/tags/java/"/>
    
      <category term="maven" scheme="http://www.huangxiang666.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>volley 源码解析</title>
    <link href="http://www.huangxiang666.com/volley-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"/>
    <id>http://www.huangxiang666.com/volley-源码解析.html</id>
    <published>2015-11-23T21:45:10.000Z</published>
    <updated>2017-12-20T08:24:15.546Z</updated>
    
    <content type="html"><![CDATA[<p>2015年11月24日 05:45:10<br>转自：<a href="volley">https://github.com/android-cn/android-open-project-analysis/tree/master/volley</a></p><h2 id="Volley-源码解析"><a href="#Volley-源码解析" class="headerlink" title="Volley 源码解析"></a>Volley 源码解析</h2><p>====================================</p><p>###1. 功能介绍  </p><p>####1.1. Volley<br>Volley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。</p><blockquote><p>名字由来：a burst or emission of many things or a large amount at once<br>发布演讲时候的配图<br><img src="http://i.imgur.com/CkahHnL.png" alt="Volley"></p></blockquote><p>从名字由来和配图中无数急促的火箭可以看出 Volley 的特点：特别适合<strong>数据量小，通信频繁</strong>的网络操作。（个人认为 Android 应用中绝大多数的网络操作都属于这种类型）。</p><a id="more"></a><p>####1.2 Volley 的主要特点<br>(1). 扩展性强。Volley 中大多是基于接口的设计，可配置性强。<br>(2). 一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。<br>(3). 默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现，这两者的区别及优劣在<code>4.2.1 Volley</code>中具体介绍。<br>(4). 提供简便的图片加载工具。  </p><p>###2. 总体设计</p><p>####2.1 总体设计图<br><img src="http://i.imgur.com/o46EL8t.png" alt="总体设计图"><br>上面是 Volley 的总体设计图，主要是通过两种<code>Dispatch Thread</code>不断从<code>RequestQueue</code>中取出请求，根据是否已缓存调用<code>Cache</code>或<code>Network</code>这两类数据获取接口之一，从内存缓存或是服务器取得请求的数据，然后交由<code>ResponseDelivery</code>去做结果分发及回调处理。  </p><p>####2.2 Volley 中的概念<br>简单介绍一些概念，在<code>详细设计</code>中会仔细介绍。<br>Volley 的调用比较简单，通过 newRequestQueue(…) 函数新建并启动一个请求队列<code>RequestQueue</code>后，只需要往这个<code>RequestQueue</code>不断 add Request 即可。  </p><p><strong> Volley：</strong>Volley 对外暴露的 API，通过 newRequestQueue(…) 函数新建并启动一个请求队列<code>RequestQueue</code>。  </p><p><strong>Request：</strong>表示一个请求的抽象类。<code>StringRequest</code>、<code>JsonRequest</code>、<code>ImageRequest</code> 都是它的子类，表示某种类型的请求。  </p><p><strong>RequestQueue：</strong>表示请求队列，里面包含一个<code>CacheDispatcher</code>(用于处理走缓存请求的调度线程)、<code>NetworkDispatcher</code>数组(用于处理走网络请求的调度线程)，一个<code>ResponseDelivery</code>(返回结果分发接口)，通过 start() 函数启动时会启动<code>CacheDispatcher</code>和<code>NetworkDispatchers</code>。  </p><p><strong>CacheDispatcher：</strong>一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code>去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入<code>NetworkDispatcher</code>去调度处理。  </p><p><strong>NetworkDispatcher：</strong>一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code>去执行后续处理，并判断结果是否要进行缓存。  </p><p><strong>ResponseDelivery：</strong>返回结果分发接口，目前只有基于<code>ExecutorDelivery</code>的在入参 handler 对应线程内进行分发。  </p><p><strong>HttpStack：</strong>处理 Http 请求，返回请求结果。目前 Volley 中有基于 HttpURLConnection 的<code>HurlStack</code>和 基于 Apache HttpClient 的<code>HttpClientStack</code>。  </p><p><strong>Network：</strong>调用<code>HttpStack</code>处理请求，并将结果转换为可被<code>ResponseDelivery</code>处理的<code>NetworkResponse</code>。  </p><p><strong>Cache：</strong>缓存请求结果，Volley 默认使用的是基于 sdcard 的<code>DiskBasedCache</code>。<code>NetworkDispatcher</code>得到请求结果后判断是否需要存储在 Cache，<code>CacheDispatcher</code>会从 Cache 中取缓存结果。  </p><p>###3. 流程图<br>Volley 请求流程图<br><img src="http://i.imgur.com/7LdQ6ZA.png" alt="Volley 请求流程图"> </p><blockquote><p><strong>上图是 Volley 请求时的流程图，在  Volley 的发布演讲中给出，我在这里将其用中文重新画出。</strong>   </p></blockquote><p>###4. 详细设计</p><p>####4.1 类关系图<br><img src="http://i.imgur.com/NHO3snQ.png" alt="类关系图"><br>这是 Volley 框架的主要类关系图    </p><blockquote><p>图中<strong>红色圈内</strong>的部分，组成了 Volley 框架的核心，围绕 RequestQueue 类，将各个功能点以<strong>组合</strong>的方式结合在了一起。各个功能点也都是以<strong>接口</strong>或者<strong>抽象类</strong>的形式提供。<br>红色圈外面的部分，在 Volley 源码中放在了 toolbox 包中，作为 Volley 为各个功能点提供的默认的具体实现。<br>通过类图我们看出， Volley 有着非常好的拓展性。通过各个功能点的接口，我们可以给出自定义的，更符合我们需求的具体实现。</p><p><strong>多用组合，少用继承；针对接口编程，不针对具体实现编程。</strong>  </p><p><strong>优秀框架的设计，令人叫绝，受益良多。</strong>  </p></blockquote><p>###4.2 核心类功能介绍</p><p>####4.2.1 Volley.java<br>这个和 Volley 框架同名的类，其实是个工具类，作用是构建一个可用于添加网络请求的<code>RequestQueue</code>对象。<br><strong>(1). 主要函数</strong><br>Volley.java 有两个重载的静态方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span></span></span><br></pre></td></tr></table></figure></p><p>第一个方法的实现调用了第二个方法，传 HttpStack 参数为 null。<br>第二个方法中，如果 HttpStatck 参数为 null，则如果系统在 Gingerbread 及之后(即 API Level &gt;= 9)，采用基于 HttpURLConnection 的 HurlStack，如果小于 9，采用基于 HttpClient 的 HttpClientStack。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得到了 HttpStack,然后通过它构造一个代表网络（Network）的具体实现<code>BasicNetwork</code>。<br>接着构造一个代表缓存（Cache）的基于 Disk 的具体实现<code>DiskBasedCache</code>。<br>最后将网络（Network）对象和缓存（Cache）对象传入构建一个 RequestQueue，启动这个 RequestQueue，并返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">queue.start();</span><br><span class="line"><span class="keyword">return</span> queue;</span><br></pre></td></tr></table></figure></p><blockquote><p>我们平时大多采用<code>Volly.newRequestQueue(context)</code>的默认实现，构建 RequestQueue。<br>通过源码可以看出，我们可以抛开 Volley 工具类构建自定义的 RequestQueue，采用自定义的<code>HttpStatck</code>，采用自定义的<code>Network</code>实现，采用自定义的 Cache 实现等来构建<code>RequestQueue</code>。<br><strong>优秀框架的高可拓展性的魅力来源于此啊</strong></p></blockquote><p><strong>(2). HttpURLConnection 和 AndroidHttpClient(HttpClient 的封装)如何选择及原因：</strong><br>在 Froyo(2.2) 之前，HttpURLConnection 有个重大 Bug，调用 close() 函数会影响连接池，导致连接复用失效，所以在 Froyo 之前使用 HttpURLConnection 需要关闭 keepAlive。<br>另外在 Gingerbread(2.3) HttpURLConnection 默认开启了 gzip 压缩，提高了 HTTPS 的性能，Ice Cream Sandwich(4.0) HttpURLConnection 支持了请求结果缓存。<br>再加上 HttpURLConnection 本身 API 相对简单，所以对 Android 来说，在 2.3 之后建议使用 HttpURLConnection，之前建议使用 AndroidHttpClient。  </p><p><strong>(3). 关于 User Agent</strong><br>通过代码我们发现如果是使用 AndroidHttpClient，Volley 还会将请求头中的 User-Agent 字段设置为 App 的 ${packageName}/${versionCode}，如果异常则使用 “volley/0”，不过这个获取 User-Agent 的操作应该放到 if else 内部更合适。而对于 HttpURLConnection 却没有任何操作，为什么呢？<br>如果用 <a href="http://www.trinea.cn/android/android-network-sniffer/" target="_blank" rel="noopener">Fiddler 或 Charles</a> 对数据抓包我们会发现，我们会发现 HttpURLConnection 默认是有 User-Agent 的，类似：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dalvik/1.6.0 (Linux; U; Android 4.1.1; Google Nexus 4 - 4.1.1 - API 16 - 768x1280_1 Build/JRO03S)</span><br></pre></td></tr></table></figure></p><p>经常用 WebView 的同学会也许会发现似曾相识，是的，WebView 默认的 User-Agent 也是这个。实际在请求发出之前，会检测 User-Agent 是否为空，如果不为空，则加上系统默认 User-Agent。在 Android 2.1 之后，我们可以通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String userAgent = System.getProperty(<span class="string">"http.agent"</span>);</span><br></pre></td></tr></table></figure></p><p>得到系统默认的 User-Agent，Volley 如果希望自定义 User-Agent，可在自定义 Request 中重写 getHeaders() 函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getHeaders</span><span class="params">()</span> <span class="keyword">throws</span> AuthFailureError </span>&#123;</span><br><span class="line">    <span class="comment">// self-defined user agent</span></span><br><span class="line">    Map&lt;String, String&gt; headerMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    headerMap.put(<span class="string">"User-Agent"</span>, <span class="string">"android-open-project-analysis/1.0"</span>);</span><br><span class="line">    <span class="keyword">return</span> headerMap;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">####4.2.2 Request.java</span><br><span class="line">代表一个网络请求的抽象类。我们通过构建一个`Request`类的非抽象子类(StringRequest、JsonRequest、ImageRequest 或自定义)对象，并将其加入到·RequestQueue·中来完成一次网络请求操作。  </span><br><span class="line">Volley 支持 <span class="number">8</span> 种 Http 请求方式 **GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE, PATCH**  </span><br><span class="line">Request 类中包含了请求 url，请求请求方式，请求 Header，请求 Body，请求的优先级等信息。  </span><br><span class="line"></span><br><span class="line">**因为是抽象类，子类必须重写的两个方法。**  </span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Response&lt;T&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span>;</span><br></pre></td></tr></table></figure></p><p>子类重写此方法，将网络返回的原生字节内容，转换成合适的类型。此方法会在工作线程中被调用。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(T response)</span></span>;</span><br></pre></td></tr></table></figure><p>子类重写此方法，将解析成合适类型的内容传递给它们的监听回调。</p><p><strong>以下两个方法也经常会被重写</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBody()</span><br></pre></td></tr></table></figure></p><p>重写此方法，可以构建用于 POST、PUT、PATCH 请求方式的 Body 内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Map&lt;String, String&gt; <span class="title">getParams</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><p>在上面<code>getBody</code>函数没有被重写情况下，此方法的返回值会被 key、value 分别编码后拼装起来转换为字节码作为 Body 内容。  </p><p>####4.2.3 RequestQueue.java<br>Volley 框架的核心类，将请求 Request 加入到一个运行的<code>RequestQueue</code>中，来完成请求操作。</p><p>####(1). 主要成员变量<br>RequestQueue 中维护了两个<strong>基于优先级</strong>的 Request 队列，缓存请求队列和网络请求队列。<br>放在缓存请求队列中的 Request，将通过缓存获取数据；放在网络请求队列中的 Request，将通过网络获取数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure></p><p>维护了一个正在进行中，尚未完成的请求集合。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure></p><p>维护了一个等待请求的集合，如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = <span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure></p><p>####(2). 启动队列<br>创建出 RequestQueue 以后，调用 start 方法，启动队列。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Starts the dispatchers in this queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span></span><br><span class="line">    <span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start 方法中，开启一个<strong>缓存调度线程<code>CacheDispatcher</code></strong>和 n 个<strong>网络调度线程<code>NetworkDispatcher</code></strong>，这里 n 默认为 4，存在优化的余地，比如可以根据 CPU 核数以及网络类型计算更合适的并发数。<br>缓存调度线程不断的从缓存请求队列中取出 Request 去处理，网络调度线程不断的从网络请求队列中取出 Request 去处理。  </p><p>####(3). 加入请求<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span></span>;</span><br></pre></td></tr></table></figure></p><p>流程图如下：<br><img src="http://i.imgur.com/t0imrUX.png" alt="加入请求流程图"> </p><p>####(4). 请求完成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request&lt;?&gt; request)</span></span></span><br></pre></td></tr></table></figure></p><p>Request 请求结束  </p><blockquote><p>(1). 首先从正在进行中请求集合<code>mCurrentRequests</code>中移除该请求。<br>(2). 然后查找请求等待集合<code>mWaitingRequests</code>中是否存在等待的请求，如果存在，则将等待队列移除，并将等待队列所有的请求添加到缓存请求队列中，让缓存请求处理线程<code>CacheDispatcher</code>自动处理。  </p></blockquote><p>####(5). 请求取消<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">(RequestFilter filter)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">(<span class="keyword">final</span> Object tag)</span></span></span><br></pre></td></tr></table></figure></p><p>取消当前请求集合中所有符合条件的请求。<br>filter 参数表示可以按照自定义的过滤器过滤需要取消的请求。<br>tag 表示按照<code>Request.setTag</code>设置好的 tag 取消请求，比如同属于某个 Activity 的。  </p><p>####4.2.4 CacheDispatcher.java<br>一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code> 去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入<code>NetworkDispatcher</code>去调度处理。  </p><p>####(1). 成员变量<br><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue</code> 缓存请求队列<br><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue</code> 网络请求队列<br><code>Cache mCache</code> 缓存类，代表了一个可以获取请求结果，存储请求结果的缓存<br><code>ResponseDelivery mDelivery</code> 请求结果传递类  </p><p>####(2). 处理流程图<br><img src="http://i.imgur.com/WqwZpN1.png" alt="缓存调度线程处理流程图"></p><p>####4.2.5 NetworkDispatcher.java<br>一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给 ResponseDelivery 去执行后续处理，并判断结果是否要进行缓存。</p><p>####(1). 成员变量<br><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue</code> 网络请求队列<br><code>Network mNetwork</code> 网络类，代表了一个可以执行请求的网络<br><code>Cache mCache</code>  缓存类，代表了一个可以获取请求结果，存储请求结果的缓存<br><code>ResponseDelivery mDelivery</code> 请求结果传递类，可以传递请求的结果或者错误到调用者  </p><p>####(2). 处理流程图<br><img src="http://i.imgur.com/IxknIDx.png" alt="网络调度线程处理流程图"></p><p>####4.2.6 Cache.java<br>缓存接口，代表了一个可以获取请求结果，存储请求结果的缓存。</p><p>####(1). 主要方法：<br><code>public Entry get(String key);</code> 通过 key 获取请求的缓存实体<br><code>public void put(String key, Entry entry);</code> 存入一个请求的缓存实体<br><code>public void remove(String key);</code> 移除指定的缓存实体<br><code>public void clear();</code> 清空缓存  </p><p>####(2). 代表缓存实体的内部类 Entry<br>成员变量和方法<br><code>byte[] data</code> 请求返回的数据（Body 实体）<br><code>String etag</code> Http 响应首部中用于缓存新鲜度验证的 ETag<br><code>long serverDate</code> Http 响应首部中的响应产生时间<br><code>long ttl</code> 缓存的过期时间<br><code>long softTtl</code> 缓存的新鲜时间<br><code>Map&lt;String, String&gt; responseHeaders</code> 响应的 Headers<br><code>boolean isExpired()</code> 判断缓存是否过期，过期缓存不能继续使用<br><code>boolean refreshNeeded()</code> 判断缓存是否新鲜，不新鲜的缓存需要发到服务端做新鲜度的检测  </p><p>####4.2.7 DiskBasedCache.java<br>继承 Cache 类，基于 Disk 的缓存实现类。</p><p>####(1). 主要方法：<br><code>public synchronized void initialize()</code> 初始化，扫描缓存目录得到所有缓存数据摘要信息放入内存。<br><code>public synchronized Entry get(String key)</code> 从缓存中得到数据。先从摘要信息中得到摘要信息，然后读取缓存数据文件得到内容。<br><code>public synchronized void put(String key, Entry entry)</code> 将数据存入缓存内。先检查缓存是否会满，会则先删除缓存中部分数据，然后再新建缓存文件。<br><code>private void pruneIfNeeded(int neededSpace)</code> 检查是否能再分配 neededSpace 字节的空间，如果不能则删除缓存中部分数据。<br><code>public synchronized void clear()</code> 清空缓存。<br><code>public synchronized void remove(String key)</code> 删除缓存中某个元素。  </p><p>####(2). CacheHeader 类<br>CacheHeader 是缓存文件摘要信息，存储在缓存文件的头部，与上面的<code>Cache.Entry</code>相似。  </p><p>####4.2.8 NoCache.java<br>继承 Cache 类，不做任何操作的缓存实现类，可将它作为构建<code>RequestQueue</code>的参数以实现一个不带缓存的请求队列。  </p><p>####4.2.9 Network.java<br>代表网络的接口，处理网络请求。<br>唯一的方法，用于执行特定请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br></pre></td></tr></table></figure></p><p>####4.2.10 NetworkResponse.java<br><code>Network</code>中方法 performRequest 的返回值，<code>Request</code>的 parseNetworkResponse(…) 方法入参，是 Volley 中用于内部 Response 转换的一级。<br>封装了网络请求响应的 StatusCode，Headers 和 Body 等。  </p><p>####(1). 成员变量<br><code>int statusCode</code> Http 响应状态码<br><code>byte[] data</code> Body 数据<br><code>Map&lt;String, String&gt; headers</code> 响应 Headers<br><code>boolean notModified</code> 表示是否为 304 响应<br><code>long networkTimeMs</code> 请求耗时  </p><p>####(2). Volley 的内部 Response 转换流程图<br><img src="http://i.imgur.com/Pnn9HHG.png" alt="Volley"><br>从上到下表示从得到数据后一步步的处理，箭头旁的注释表示该步处理后的实体类。  </p><p>####4.2.11 BasicNetwork.java<br>实现 Network，Volley 中默认的网络接口实现类。调用<code>HttpStack</code>处理请求，并将结果转换为可被<code>ResponseDelivery</code>处理的<code>NetworkResponse</code>。<br>主要实现了以下功能：<br>(1). 利用 HttpStack 执行网络请求。<br>(2). 如果 Request 中带有实体信息，如 Etag,Last-Modify 等，则进行缓存新鲜度的验证，并处理 304（Not Modify）响应。<br>(3). 如果发生超时，认证失败等错误，进行重试操作，直到成功、抛出异常(不满足重试策略等)结束。  </p><p>####4.2.12 HttpStack.java<br>用于处理 Http 请求，返回请求结果的接口。目前 Volley 中的实现有基于 HttpURLConnection 的 HurlStack 和 基于 Apache HttpClient 的 HttpClientStack。<br>唯一方法，执行请求<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, AuthFailureError</span>;</span><br></pre></td></tr></table></figure></p><p>执行 Request 代表的请求，第二个参数表示发起请求之前，添加额外的请求 Headers。  </p><p>####4.2.13 HttpClientStack.java<br>实现 HttpStack 接口，利用 Apache 的 HttpClient 进行各种请求方式的请求。<br>基本就是 org.apache.http 包下面相关类的常见用法，不做详解，不过与下面 HttpURLConnection 做下对比就能发现 HttpURLConnection 的 API 相对简单的多。  </p><p>####4.2.14 HurlStack.java<br>实现 HttpStack 接口，利用 Java 的 HttpURLConnection 进行各种请求方式的请求。  </p><p>####4.2.15 Response.java<br>封装了经过解析后的数据，用于传输。并且有两个内部接口 Listener 和 ErrorListener 分别可表示请求失败和成功后的回调。<br>Response 的构造函数被私有化，而通过两个函数名更易懂的静态方法构建对象。  </p><p>####4.2.16 ByteArrayPool.java<br>byte[] 的回收池，用于 byte[] 的回收再利用，减少了内存的分配和回收。<br>主要通过一个元素长度从小到大排序的<code>ArrayList</code>作为 byte[] 的缓存，另有一个按使用时间先后排序的<code>ArrayList</code>属性用于缓存满时清理元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">returnBuf</span><span class="params">(<span class="keyword">byte</span>[] buf)</span></span></span><br></pre></td></tr></table></figure></p><p>将用过的 byte[] 回收，根据 byte[] 长度按照从小到大的排序将 byte[] 插入到缓存中合适位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">byte</span>[] getBuf(<span class="keyword">int</span> len)</span><br></pre></td></tr></table></figure></p><p>获取长度不小于 len 的 byte[]，遍历缓存，找出第一个长度大于传入参数<code>len</code>的 byte[]，并返回；如果最终没有合适的 byte[]，new 一个返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trim</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><p>当缓存的 byte 超过预先设置的大小时，按照先进先出的顺序删除最早的 byte[]。  </p><p>####4.2.17 PoolingByteArrayOutputStream.java<br>继承 ByteArrayOutputStream，原始 ByteArrayOutputStream 中用于接受写入 bytes 的 buf，每次空间不足时便会 new 更大容量的 byte[]，而 PoolingByteArrayOutputStream 使用了 ByteArrayPool 作为 Byte[] 缓存来减少这种操作，从而提高性能。  </p><p>####4.2.18 HttpHeaderParser.java<br>Http header 的解析工具类，在 Volley 中主要作用是用于解析 Header 从而判断返回结果是否需要缓存，如果需要返回 Header 中相关信息。<br>有三个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parseDateAsEpoch</span><span class="params">(String dateStr)</span></span></span><br></pre></td></tr></table></figure></p><p>解析时间，将 RFC1123 的时间格式，解析成 epoch 时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseCharset</span><span class="params">(Map&lt;String, String&gt; headers)</span></span></span><br></pre></td></tr></table></figure><p>解析编码集，在 Content-Type 首部中获取编码集，如果没有找到，默认返回 ISO-8859-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Cache.<span class="function">Entry <span class="title">parseCacheHeaders</span><span class="params">(NetworkResponse response)</span></span></span><br></pre></td></tr></table></figure><p><strong>比较重要的方法</strong>，通过网络响应中的缓存控制 Header 和 Body 内容，构建缓存实体。如果 Header 的 Cache-Control 字段含有<code>no-cache</code>或<code>no-store</code>表示不缓存，返回 null。<br>(1). 根据 Date 首部，获取响应生成时间<br>(2). 根据 ETag 首部，获取响应实体标签<br>(3). 根据 Cache－Control 和 Expires 首部，计算出缓存的过期时间，和缓存的新鲜度时间</p><blockquote><p>两点需要说明下：<br>1.没有处理<code>Last-Modify</code>首部，而是处理存储了<code>Date</code>首部，并在后续的新鲜度验证时，使用<code>Date</code>来构建<code>If-Modified-Since</code>。<br>这与 Http 1.1 的语义有些违背。<br>2.计算过期时间，Cache－Control 首部优先于 Expires 首部。  </p></blockquote><p>####4.2.19 RetryPolicy.java<br>重试策略接口<br>有三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentTimeout</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>获取当前请求用时（用于 Log）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentRetryCount</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>获取已经重试的次数（用于 Log）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br></pre></td></tr></table></figure></p><p>确定是否重试，参数为这次异常的具体信息。在请求异常时此接口会被调用，可在此函数实现中抛出传入的异常表示停止重试。  </p><p>####4.2.20 DefaultRetryPolicy.java<br>实现 RetryPolicy，Volley 默认的重试策略实现类。主要通过在 retry(…) 函数中判断重试次数是否达到上限确定是否继续重试。<br>其中<code>mCurrentRetryCount</code>变量表示已经重试次数。<br><code>mBackoffMultiplier</code>表示每次重试之前的 timeout 该乘以的因子。<br><code>mCurrentTimeoutMs</code>变量表示当前重试的 timeout 时间，会以<code>mBackoffMultiplier</code>作为因子累计前几次重试的 timeout。  </p><p>####4.2.21 ResponseDelivery.java<br>请求结果的传输接口，用于传递请求结果或者请求错误。<br>有三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span></span>;</span><br></pre></td></tr></table></figure></p><p>此方法用于传递请求结果，<code>request</code> 和 <code>response</code> 参数分别表示请求信息和返回结果信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span></span>;</span><br></pre></td></tr></table></figure></p><p>此方法用于传递请求结果，并在完成传递后执行 Runnable。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span></span>;</span><br></pre></td></tr></table></figure></p><p>此方法用于传输请求错误。  </p><p>####4.2.22 ExecutorDelivery.java<br>请求结果传输接口具体实现类。<br>在 Handler 对应线程中传输缓存调度线程或者网络调度线程中产生的请求结果或请求错误，会在请求成功的情况下调用 Request.deliverResponse(…) 函数，失败时调用 Request.deliverError(…) 函数。  </p><p>####4.2.23 StringRequest.java<br>继承 Request 类,代表了一个返回值为 String 的请求。将网络返回的结果数据解析为 String 类型。通过构造函数的 listener 传参，支持请求成功后的 onResponse(…) 回调。  </p><p>####4.2.24 JsonRequest.java<br>抽象类，继承自 Request，代表了 body 为 JSON 的请求。提供了构建 JSON 请求参数的方法。  </p><p>####4.2.25 JsonObjectRequest.java<br>继承自 JsonRequest，将网络返回的结果数据解析为 JSONObject 类型。  </p><p>####4.2.26 JsonArrayRequest.java<br>继承自 JsonRequest，将网络返回的结果数据解析为 JSONArray 类型。  </p><p>####4.2.27 ImageRequest.java<br>继承 Request 类，代表了一个返回值为 Image 的请求。将网络返回的结果数据解析为 Bitmap 类型。<br>可以设置图片的最大宽度和最大高度，并计算出合适尺寸返回。每次最多解析一张图片防止 OOM。  </p><p>####4.2.28 ImageLoader.java<br>封装了 ImageRequst 的方便使用的图片加载工具类。 </p><blockquote><p>1.可以设置自定义的<code>ImageCache</code>，可以是内存缓存，也可以是 Disk 缓存，将获取的图片缓存起来，重复利用，减少请求。<br>2.可以定义图片请求过程中显示的图片和请求失败后显示的图片。<br>3.相同请求（相同地址，相同大小）只发送一个，可以避免重复请求。<br>// TODO  </p></blockquote><p>####4.2.29 NetworkImageView.java<br>利用 ImageLoader，可以加载网络图片的 ImageView<br>有三个公开的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultImageResId</span><span class="params">(<span class="keyword">int</span> defaultImage)</span></span></span><br></pre></td></tr></table></figure></p><p>设置默认图片，加载图片过程中显示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorImageResId</span><span class="params">(<span class="keyword">int</span> errorImage)</span></span></span><br></pre></td></tr></table></figure></p><p>设置错误图片，加载图片失败后显示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageUrl</span><span class="params">(String url, ImageLoader imageLoader)</span></span></span><br></pre></td></tr></table></figure></p><p>设置网络图片的 Url 和 ImageLoader，将利用这个 ImageLoader 去获取网络图片。  </p><blockquote><p>如果有新的图片加载请求，会把这个 ImageView 上旧的加载请求取消。  </p></blockquote><p>####4.2.30 ClearCacheRequest.java<br>用于人为清空 Http 缓存的请求。<br>添加到 RequestQueue 后能很快执行，因为优先级很高，为<code>Priority.IMMEDIATE</code>。并且清空缓存的方法<code>mCache.clear()</code>写在了<code>isCanceled()</code>方法体中，能最早的得到执行。  </p><p>ClearCacheRequest 的写法不敢苟同，目前看来唯一的好处就是可以将清空缓存操作也当做一个请求。而在<code>isCanceled()</code>中做清空操作本身就造成了歧义，不看源码没人知道在<code>NetworkDispatcher</code> run 方法循环的过程中，<code>isCanceled()</code>这个读操作竟然做了可能造成缓存被清空。只能跟源码的解释一样当做一个 Hack 操作。  </p><p>####4.2.31 Authenticator.java<br>身份认证接口，用于基本认证或者摘要认证。这个类是 Volley 用于和身份验证打通的接口，比如 OAuth，不过目前的使用不是特别广泛和 Volley 的内部结合也不是特别紧密。  </p><p>####4.2.32 AndroidAuthenticator.java<br>继承 Authenticator，基于 Android AccountManager 的认证交互实现类。  </p><p>####4.2.33 VolleyLog.java<br>Volley 的 Log 工具类。  </p><p>####4.2.34 VolleyError.java<br>Volley 中所有错误异常的父类，继承自 Exception，可通过此类设置和获取 NetworkResponse 或者请求的耗时。  </p><p>####4.2.35 AuthFailureError.java<br>继承自 VolleyError，代表请求认证失败错误，如 RespondeCode 的 401 和 403。  </p><p>####4.2.36 NetworkError.java<br>继承自 VolleyError，代表网络错误。  </p><p>####4.2.37 ParseError.java<br>继承自 VolleyError，代表内容解析错误。  </p><p>####4.2.38 ServerError.java<br>继承自 VolleyError，代表服务端错误。  </p><p>####4.2.39 TimeoutError.java<br>继承自 VolleyError，代表请求超时错误。  </p><p>####4.2.40 NoConnectionError.java<br>继承自 NetworkError，代表无法建立连接错误。  </p><p>###5. 杂谈</p><p>####5.1 关于 Http 缓存<br>Volley 构建了一套相对完整的符合 Http 语义的缓存机制。<br><strong>优点和特点</strong><br>(1). 根据<code>Cache-Control</code>和<code>Expires</code>首部来计算缓存的过期时间。如果两个首部都存在情况下，以<code>Cache-Control</code>为准。<br>(2). 利用<code>If-None-Match</code>和<code>If-Modified-Since</code>对过期缓存或者不新鲜缓存，进行请求再验证，并处理 304 响应，更新缓存。<br>(3). 默认的缓存实现，将缓存以文件的形式存储在 Disk，程序退出后不会丢失。</p><p><strong>我个人认为的不足之处</strong><br>缓存的再验证方面，在构建<code>If-Modified-Since</code>请求首部时，Volley 使用了服务端响应的<code>Date</code>首部，没有使用<code>Last-Modified</code>首部。整个框架没有使用<code>Last-Modified</code>首部。这与 Http 语义不符。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCacheHeaders</span><span class="params">(Map&lt;String, String&gt; headers, Cache.Entry entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If there's no cache entry, we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry.etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        headers.put(<span class="string">"If-None-Match"</span>, entry.etag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry.serverDate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Date refTime = <span class="keyword">new</span> Date(entry.serverDate);</span><br><span class="line">        headers.put(<span class="string">"If-Modified-Since"</span>, DateUtils.formatDate(refTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务端根据请求时通过<code>If-Modified-Since</code>首部传过来的时间，判断资源文件是否在<code>If-Modified-Since</code>时间 <strong>以后</strong> 有改动，如果有改动，返回新的请求结果。如果没有改动，返回 304 not modified。<br><code>Last-Modified</code>代表了资源文件的最后修改时间。通常使用这个首部构建<code>If-Modified-Since</code>的时间。<br><code>Date</code>代表了响应产生的时间，正常情况下<code>Date</code>时间在<code>Last-Modified</code>时间之后。也就是<code>Date</code>&gt;=<code>Last-Modified</code>。<br>通过以上原理，既然<code>Date</code>&gt;=<code>Last-Modified</code>。那么我利用<code>Date</code>构建，也是完全正确的。  </p><p><strong>可能的问题出在服务端的 Http 实现上，如果服务端完全遵守 Http 语义，采用时间比较的方式来验证<code>If-Modified-Since</code>，判断服务器资源文件修改时间是不是在<code>If-Modified-Since</code>之后。那么使用<code>Date</code>完全正确。</strong><br><strong>可是有的服务端实现不是比较时间，而是直接的判断服务器资源文件修改时间，是否和<code>If-Modified-Since</code>所传时间相等。这样使用<code>Date</code>就不能实现正确的再验证，因为<code>Date</code>的时间总不会和服务器资源文件修改时间相等。</strong>  </p><p>尽管使用<code>Date</code>可能出现的不正确情况，归结于服务端没有正确的实现 Http 语义。<br><strong>但我还是希望 Volley 也能完全正确的实现 Http 语义，至少同时处理<code>Last-Modified</code>和<code>Date</code>,并且优先使用<code>Last-Modified</code>。</strong>  </p><p>####5.2 Bug</p><p>#####(1). BasicNetwork.performRequest(…)<br>如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ……</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">int</span> statusCode = <span class="number">0</span>;</span><br><span class="line">            NetworkResponse networkResponse = <span class="keyword">null</span>;</span><br><span class="line">            ……</span><br><span class="line">            <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) &#123;</span><br><span class="line">              ……</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BasicNetwork.performRequest(…) 最后的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</span><br></pre></td></tr></table></figure></p><p>应该是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(e);</span><br></pre></td></tr></table></figure></p><p>更合理。  </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;在github开源项目上看到的非常好的一篇关于volley项目的源码解析，转载过来存档一下。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="android" scheme="http://www.huangxiang666.com/categories/android/"/>
    
    
      <category term="android" scheme="http://www.huangxiang666.com/tags/android/"/>
    
      <category term="开源项目" scheme="http://www.huangxiang666.com/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="volley" scheme="http://www.huangxiang666.com/tags/volley/"/>
    
      <category term="源码" scheme="http://www.huangxiang666.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
