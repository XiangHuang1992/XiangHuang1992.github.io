<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[android开发规范之编码规范]]></title>
    <url>%2Fandroid%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E4%B9%8B%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[编码规范 java代码中不出现中文，最多注释中可以出现中文，中文统一写在strings.xml中； 局部变量命名、静态成员变量命名 只能包含字母，单词首字母大写，其他字母都为小写 常量命名只能包含字母和，字母全部大写，单词之间用隔开 布局文件中的id命名 123456789命名模式为：view缩写_模块名称_view的逻辑名称常用控件的缩写如下LayoutView：lv_RelativeView : rv_TextView : tv_ImageView : iv_ImageButton : im_Button : btn_ strings.xml中的id命名命名模式：activity名称功能模块名称逻辑名称/activity名称逻辑名称/common逻辑名称strings.xml中，使用activity名称注释，将文件内容区分开来 styles.xml：将layout中不断重现的style提炼出通用的style通用组件，放到styles.xml中； 服务端可以实现的，就不要放在客户端； 图片尽量分拆成多个可重用的图片 引用第三方库要慎重，避免应用大容量的第三方库，导致客户端包非常大； 图片要.9.png处理 使用静态变量方式实现界面间共享要慎重； Log(系统名称 模块名称 接口名称，详细描述)； 不要重用父类的handler，对应一个类的handler也不应该让其子类用到，否则会导致message.what冲突 strings.xml中使用%1$s实现字符串的通配 如果多个Activity中包含共同的UI处理，那么可以提炼一个CommonActivity，把通用部分叫由它来处理，其他activity只要继承它即可 数据一定要效验，例如字符型转数字型，如果转换失败一定要有缺省值；服务端响应数据是否有效判断； Android性能的基本优化OK，其次说说，如何提高Android的效率，也就是如何来优化Android的性能： http用gzip压缩，设置连接超时时间和响应超时时间http请求按照业务需求，分为是否可以缓存和不可缓存，那么在无网络的环境中，仍然通过缓存的httpresponse浏览部分数据，实现离线阅读。 listview 性能优化 复用convertView在getItemView中，判断convertView是否为空，如果不为空，可复用。如果couvertview中的view需要添加listerner，代码一定要在if(convertView==null){}之外。 异步加载图片item中如果包含有webimage，那么最好异步加载 快速滑动时不显示图片当快速滑动列表时（SCROLL_STATE_FLING），item中的图片或获取需要消耗资源的view，可以不显示出来；而处于其他两种状态（SCROLL_STATE_IDLE 和SCROLL_STATE_TOUCH_SCROLL），则将那些view显示出来 BaseAdapter避免内存溢出如果BaseAdapter的实体类有属性非常消耗内存，可以将保存到文件；为提高性能，可以进行缓存，并限制缓存大小。 使用线程池，分为核心线程池和普通线程池，下载图片等耗时任务放置在普通线程池，避免耗时任务阻塞线程池后，导致所有异步任务都必须等待 异步任务，分为核心任务和普通任务，只有核心任务中出现的系统级错误才会报错，异步任务的ui操作需要判断原activity是否处于激活状态 尽量避免static成员变量引用资源耗费过多的实例,比如Context 使用WeakReference代替强引用，弱引用可以让您保持对对象的引用，同时允许GC在必要时释放对象，回收内存。对于那些创建便宜但耗费大量内存的对象，即希望保持该对象，又要在应用程序需要时使用，同时希望GC必要时回收时，可以考虑使用弱引用。 超级大胖子Bitmap及时的销毁(Activity的onDestroy时将bitmap回收，在被UI组件使用后马上进行回收会抛 RuntimeException: Canvas: trying to use a recycled bitmap android.graphics.Bitmap)设置一定的采样率(有开发者提供的图片无需进行采样，对于有用户上传或第三方的大小不可控图片，可进行采样减少图片所占的内存)，从服务端返回图片，建议同时反馈图片的size 巧妙的运用软引用drawable对应resid的资源，bitmap对应其他资源任何类型的图片，如果获取不到（例如文件不存在，或者读取文件时跑OutOfMemory异常），应该有对应的默认图片（默认图片放在在apk中，通过resid获取）； 保证Cursor 占用的内存被及时的释放掉，而不是等待GC来处理。并且 Android明显是倾向于编 程者手动的将Cursor close掉 线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程 生命周期的不可控 如果ImageView的图片是来自网络，进行异步加载 应用开发中自定义View的时候，交互部分，千万不要写成线程不断刷新界面显示，而是根据TouchListener事件主动触发界面的更新 Drawable ui组件需要用到的图片是apk包自带的，那么一律用setImageResource或者setBackgroundResource，而不要根据resourceid 注意：get(getResources(), R.drawable.btn_achievement_normal)该方法通过resid转换为drawable，需要考虑回收的问题，如果drawable是对象私有对象，在对象销毁前是肯定不会释放内存的。 复用、回收Activity对象临时的activity及时finish主界面设置为singleTask一般界面设置为singleTop 位置信息获取用户的地理位置信息时，在需要获取数据的时候打开GPS，之后及时关闭掉 在onResume时设置该界面的电源管理，在onPause时取消设置]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>android开发</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 机型适配]]></title>
    <url>%2Fandroid-%E6%9C%BA%E5%9E%8B%E9%80%82%E9%85%8D.html</url>
    <content type="text"><![CDATA[2015/10/21 15:35:54 lucas 初步编辑 2015年11月23日 03:44:59 lucas 参照了CSDN上的一些博客进行了修改。（因为没有找到原博主，所以无法列出链接，抱歉！sorry） 201X年XX月XX日 XX:XX:XX 等待下一次修改，等下次空闲时，再完善一些内容，以及提供样例代码以及部分截图。 Android机型适配 PS：Android机型适配一直以来都折磨着我们这些开发者，本篇文章讲介绍Android的屏幕适配，所谓的屏幕适配往往指的就是屏幕大小和屏幕密度的适配。 需要做好一款软件的屏幕适配方案，我们应该学习以下几个方面的知识： 了解基本的屏幕适配知识。 Google官方的解决方案啊。 与ScrollView的结合。 结合Html5和css3优化界面布局和适配。 与Weight的结合。 .9.png图片的使用。 题外话 基本的屏幕适配知识 屏幕大小 在Android系统中，将屏幕大小划分成以下几种：small、normal、large、extra large。 屏幕密度 在Android系统中，屏幕密度往往是在指定的屏幕大小区域内，有多少个像素，基本单位是dpi(点/每英寸)。 基本包括四种密度：low、dedium（中等）、hign、extra hign（更高的密度） 常见的密度如下：QVGA(240X320)、HVGA(320X480)、WVGA800(480X800) Google官方的解决方案1. 创建不同的布局(Create Different Layouts) 为了让用户在不同的分辨率的设备上的体验得到优化，我们应该为每一个我们所想支持的屏幕尺寸都创建一个自己的layout XML文件，每个文件都保存在相应的资源目录，例如，如果我们想支持large screens，我们就应该在资源目录res文件夹下创建一个layout-large。android系统会根据屏幕的尺寸大小去自动的加载相应的布局。 如下，一个包含这默认的layout和一个供选择的large screen的layout 1234567res/ layout/ main.xml layout-large/ main.xml// 需要注意的是，文件名必须相同，但文件里面的内容可以相同，你可以根据不同的屏幕的尺 寸制定不同的布局以优化用户的体验 在具体的代码中，没有什么变化，android系统会自动调用不同屏幕尺寸的布局 12345@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main);&#125; 系统会根据应用程序所运行在的android设备的屏幕大小加载相同的布局，具体的android如何选择合适的资源将在另外一篇博客关于android资源的详解中介绍到。 下面是一个关于横屏和竖屏的布局： 123456MyProject/ res/ layout/ main.xml layout-land/ main.xml 如果想要提供一个特殊的layout在大屏幕设备横屏的时候，则large和land两个限定符都需要使用。 12345678910MyProject/ res/ layout/ # default (portrait) main.xml layout-land/ # landscape main.xml layout-large/ # large (portrait) main.xml layout-large-land/ # large landscape main.xml 安卓3.2及以上支持定义屏幕尺寸的一种先进方法,允许您指定资源基于最小宽度和高度的屏幕尺寸的密度独立像素。后面我们会详细的解释。 2. 创建不同的位图(Create Different Bitmaps) 因为需要适配不同屏幕，我们需要提供不同的图片来适配，这样才能带来更好的用户体验. [通常我们需要提供下面的资源图片来适配] xhdpi: (dpi=320, density=2)hdpi: (dpi=240, density=1.5)mdpi: (dpi=160, density=1) (baseline)ldpi: (dpi=120, density=0.75) 这意味着如果我们为xhdpi的设备生成了一张200x200的图片，同时也需要为hdpi的设备生成150x150的图片，为mdpi的设备生成100x100的图片，最后为ldpi的设备生成75x75的图片。 12345678910MyProject/ res/ drawable-xhdpi/ awesomeimage.png drawable-hdpi/ awesomeimage.png drawable-mdpi/ awesomeimage.png drawable-ldpi/ awesomeimage.png 这样之后，在任何地方引用@drawable/awesomeimage，系统都会自动根据当前设备的dpi来选择合适的图片进行显示。 3. Android 多屏幕设计(Designing for Multiple Screens)支持不同的屏幕尺寸(Supporting Different Screen Sizes) 确保你的布局可以根据屏幕的大小自适应调整 为不同的屏幕配置提供对应的UI布局 确保正确的布局适合正确的屏幕。 提供缩放正确的位图（ bitmap） 使用“wrap_content”和“match_parent”为了确保你的布局能灵活的适应不同的屏幕尺寸， 针对一些view组件， 你应该使wrap_content和match_parent来设置他们的宽和高。 如果你使用了wrap_content， view的宽和高会被设置该view所包含的内容的大小值。 如果是match_parent（ 在API 8之前是fill_parent） 则会匹配该组件的父控件的大小。通过使用wrap_content和match_parent尺寸值代替硬编码的尺寸， 你的视图将分别只使用控件所需要的空间或者被拓展以填充所有有效的空间。 比如： 12345678910111213141516171819202122232425262728293031&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:id=&quot;@+id/linearLayout1&quot; android:gravity=&quot;center&quot; android:layout_height=&quot;50dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView1&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:src=&quot;@drawable/logo&quot; android:paddingRight=&quot;30dp&quot; android:layout_gravity=&quot;left&quot; android:layout_weight=&quot;0&quot; /&gt; &lt;View android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/view1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;Button android:id=&quot;@+id/categorybutton&quot; android:background=&quot;@drawable/button_bg&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;0&quot; android:layout_width=&quot;120dp&quot; style=&quot;@style/CategoryButtonStyle&quot;/&gt; &lt;/LinearLayout&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; 使用相对布局（ RelativeLayout）你可以使用LinearLayout以及wrap_content和match_parent组合来构建复杂的布局， 但是LinearLayout却不允许你精准的控制它子view的关系，子view在LinearLayout中只能简单一个接一个的排成行。如果你需要你的子view不只是简简单单的排成行的排列，更好的方法是使用RelativeLayout，它允许你指定你布局中控件与控件之间的关系， 比如，你可以指定一个子view在左边， 另一个则在屏幕的右边。 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/label&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Type here:&quot;/&gt; &lt;EditText android:id=&quot;@+id/entry&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/label&quot;/&gt; &lt;Button android:id=&quot;@+id/ok&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/entry&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginLeft=&quot;10dp&quot; android:text=&quot;OK&quot; /&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_toLeftOf=&quot;@id/ok&quot; android:layout_alignTop=&quot;@id/ok&quot; android:text=&quot;Cancel&quot; /&gt;&lt;/RelativeLayout&gt; 使用尺寸限定词(Use Size Qualifiers)PS:这里的限定词主要是指在编写布局文件时， 将布局文件放在加上类似large， sw600dp等这样限定词的文件夹中，以此来告诉系统根据屏幕选择对应的布局文件， 比如下面例子的layout-large文件夹。 res/layout/main.xml,单个窗格布局(默认) 12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout-large/main.xml,两个窗格的布局。 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 注意第二个布局文件的目录名字“large qualifier”， 在大尺寸的设备屏幕时（ 比如7寸平板或者其他大屏幕的设备） 就会选择该布局文件， 而其他比较小的设备则会选择没有限定词的另一个布局（ 也就是第一个布局文件） 。 使用最小宽度限定词在Android 3.2之前， 开发者还有一个困难， 那就是Android设备的“large”屏幕尺寸， 其中包括Dell Streak（ 设备名称），老版Galaxy Tab和一般的7寸平板，有很多的应用都想针对这些不同的设备（ 比如5和7寸的设备） 定义不同的布局， 但是这些设备都被定义为了large尺寸屏幕。 也是因为这个， 所以Android在3.2的时候开始使用最小宽度限定词。 最小宽度限定词允许你根据设备的最小宽度（ dp单位） 来指定不同布局。 比如， 传统的7寸平板最小宽度为600dp， 如果你希望你的UI能够在这样的屏幕上显示两个窗格（ 不是一个窗格显示在小屏幕上），你可以使用上节中提到的使用同样的两个布局文件。 同的是， 使用sw600来指定两个方框的布局使用在最小宽度为600dp的设备上。 res/layout/main.xml,单个窗格布局（默认） 12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout-large/main.xml,两个窗格的布局 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 这样意味着当你的设备的最小宽度等于600dp或者更大时， 系统选择layout-sw600dp/main.xml（两个窗格） 的布局，而小一点的屏幕则会选择layout/main.xml（ 单个窗格） 的布局。 然而，在3.2之前的设备上， 这样做并不是很好的选择。因为3.2之前还没有将sw600dp作为一个限定词出现，所以，你还是需要使用large限定词来做。因此，你还是应该要有一个布局文件名为res/layout-large/main.xml， 和res/layout-sw600dp/main.xml一样。在后续的博客中，我们将介绍到如何避免出现这样重复的布局。 使用布局别名(Use Layout Aliases)最小宽度限定词只能在android3.2或者更高的版本上使用。因此，你还是需要使用抽象尺寸（ small，normal，large，xlarge）来兼容以前的版本。比如，你想要将你的UI设计为在手机上只显示一个方框的布局，而在7寸平板或电视， 或者其他大屏幕设备上显示多个方框的布局， 你可能得提供这些文件： res/layout/main.xml,单个窗格布局 res/layout-large,多个窗格布局 res/layout-sw600dp,多个窗格布局 最后两个文件都是一样的，因为其中一个将会适配Android3.2的设备，而另外一个则会适配其他Android低版本的平板或者电视。为了避免这些重复的文件（ 维护让人感觉头痛就是因为这个），你可以使用别名文件。 比如，你可以定义如下布局：res/layout/main.xml， 单个方框布局 res/layout/main_twopans.xml， 两个方框布局 然后添加这两个文件： res/valueslargelayout.xml： 123&lt;resources&gt; &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;&lt;/resources&gt; res/values-sw600dp/layout.xml: 123&lt;resources&gt; &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;&lt;/resources&gt; 使用方向限定词(Use Orientation Qualifiers)有一些布局不管是在横向还是纵向的屏幕配置中都能显示的非常好，但是更多的时候，适当的调整一下会更好。 在NewsReader应用例子中， 以下是布局在不同屏幕尺寸和方向的行为： small screen, portrait:,纵向，一个窗格加logo，小屏幕 small screen, landscape:,横向，一个窗格加logo，小屏幕 7&quot; tablet, portrait:,纵向，一个窗格加actionBar，7寸屏幕 7&quot; tablet, landscape:,横向，两个宽窗格加actionBar，7寸屏幕 10&quot; tablet, portrait:,纵向，两个窄窗格加actionBar ，平板 10&quot; tablet, landscape:,横向，两个宽窗格加actionBar，平板 TV, landscape:,两个窗格，宽屏，加actionBar，电视 这些每个布局都会在res/layout目录下定义一个xml文件，如此，应用就能根据屏幕配置的变化根据别名匹配到对应的布局来适应屏幕。 res/layout/onepane.xml: 12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/onepane_with_bar.xml: 1234567891011121314151617181920212223242526272829303132&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:id=&quot;@+id/linearLayout1&quot; android:gravity=&quot;center&quot; android:layout_height=&quot;50dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView1&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:src=&quot;@drawable/logo&quot; android:paddingRight=&quot;30dp&quot; android:layout_gravity=&quot;left&quot; android:layout_weight=&quot;0&quot; /&gt; &lt;View android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/view1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;Button android:id=&quot;@+id/categorybutton&quot; android:background=&quot;@drawable/button_bg&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;0&quot; android:layout_width=&quot;120dp&quot; style=&quot;@style/CategoryButtonStyle&quot;/&gt; &lt;/LinearLayout&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/twopanes.xml: 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/twopanes_narrow.xml: 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;200dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 现在所有可能的布局我们都已经定义了，唯一剩下的问题是使用方向限定词来匹配对应的布局给屏幕。这时候，你就可以使用布局别名的功能了： res/values/layouts.xml: 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane_with_bar&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;&lt;/resources&gt; res/values-sw600dp-land/layouts.xml: 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; res/values-sw600dp-port/layouts.xml: 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;&lt;/resources&gt; res/values-large-land/layouts.xml: 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; res/values-large-port/layouts.xml: 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes_narrow&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; 使用.9.png图片 关于.9图片上下左右四条黑线的含义解释： 上方黑线代表横向拉伸区域。 左边黑线代表纵向拉伸区域。 下方黑线代表横向内容显示区域。 右边黑线代表纵向内容显示区域。 支持不同的屏幕尺寸同时也意味着你的图片资源也必须能兼容不同的屏幕尺寸。比如，一个button的背景图片就必须要适应该button的各种形状。 如果你在使用组件时可以改变图片的大小，你很快就会发现这是一个不明确的选择。 因为运行的时候，图片会被拉伸或者压缩（这样容易造成图片失真）。避免这种情况的解决方案就是使用点9图片，这是一种能够指定哪些区域能够或者不能够拉伸的特殊png文件。 因此， 在设计的图片需要与组件一起变大变小时， 一定要使用点9.若要将位图转换为点9， 你可以用一个普通的图片开始（下图，是在4倍变焦情况下的图片显示） 。 你可以通过sdk中的draw9patch程序（位于tools/directory目录下） 来画点9图片。 通过左侧和顶部边框绘制像素来标记应该被拉伸的区域。 也可以通过沿右侧和底部边界绘制像素来标记。 就像下图所示一样： 请注意， 上图沿边界的黑色像素。在顶部边框和左边框的那些表明图像的可拉伸区域，右边和底部边框则表示内容应该放置的地方。 此外，注意.9.png这个格式，你也必须用这个格式，因为系统会检测这是一个点9图片而不是一个普通PNG图片。 当你将这个应用到组件的背景的时候（通过设置android:background=”@drawable/button”），android框架会自动正确的拉伸图像以适应按钮的大小，下图就是各种尺寸中的显示效果： 支持不同的屏幕密度(Supporting Different Densities)使用密度独立像素(dp)设计布局时， 要避免使用绝对像素（ absolutepixels） 定义距离和尺寸。 使用像素单位来定义布局大小是有问题的。因为，不同的屏幕有不同的像素密度，所以，同样单位的像素在不同的设备上会有不同的物理尺寸。因此，在指定单位的时候，通常使用dp或者sp。一个dp代表一个密度独立像素，也就相当于在160dpi的一个像素的物理尺寸，sp也是一个基本的单位，不过它主要是用在文本尺寸上（它也是一种尺寸规格独立的像素），所以，你在定义文本尺寸的时候应该使用这种规格单位（不要使用在布尺寸上）。 例如，当你是定义两个view之间的空间时，应该使用dp而不是px： 1234&lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/clickme&quot; android:layout_marginTop=&quot;20dp&quot; /&gt; 当指定文本尺寸时，始终应该使用sp： 123&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;20sp&quot; /&gt; 提供可供选择的图片(Provide Alternative Bitmaps)因为Android能运行在很多不同屏幕密度的设备上，所以，你应该针对不同的设备密度提供不同的bitmap资源：小屏幕（low），medium（中），high（高）以及超高（extra-high）密度。这将能帮助你在所有的屏幕密度中得到非常好的图形质量和性能。 为了提供更好的用户体验，你应该使用以下几种规格来缩放图片大小，为不同的屏幕密度提供相应的位图资源： 1234xhdpi: 2.0hdpi: 1.5mdpi: 1.0 (baseline)ldpi: 0.75 这也就意味着如果在xhdpi设备上你需要一个200x200的图片，那么你则需要一张150x150的图片用于hdpi，100x100的用于mdpi以及75x75的用户ldpi设备。 然后将这些图片资源放到res/对应的目录下面，系统会自动根据当前设备屏幕密度自动去选择合适的资源进行加载： 12345678910MyProject/ res/ drawable-xhdpi/ awesomeimage.png drawable-hdpi/ awesomeimage.png drawable-mdpi/ awesomeimage.png drawable-ldpi/ awesomeimage.png 这样放置图片资源后，不论你什么时候使用@drawable/awesomeimage，系统都会给予屏幕的dp来选择合适的图片。 实现可适应的UI流程(Implementing Adaptative UI Flows)根据当前你的应用显示的布局，它的UI流可能会不一样。比如，当你的应用是双窗格模式，点击左边窗格的条目（item）时，内容（content）显示在右边窗格中。如果是单窗格模式中，当你点击某个item的时候，内容则显示在一个新的activity中。 确定当前布局(Determine the Current Layout)由于每种布局的实现会略有差别，首先你可能要确定用户当前可见的布局是哪一个。比如，你可能想知道当前用户到底是处于“单窗格”的模式还是“双窗格”的模式。 你可以通过检查指定的视图（view）是否存在和可见来实现： 12345678910111213public class NewsReaderActivity extends FragmentActivity &#123; boolean mIsDualPane; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main_layout); View articleView = findViewById(R.id.article); mIsDualPane = articleView != null &amp;&amp; articleView.getVisibility() == View.VISIBLE; &#125;&#125; 另一个关于如何适配不同组件是否存在的例子，是在组件执行操作之前先检查它是否是可用的。 比如，在News Reader示例中，有一个按钮点击后打开一个菜单，但是这个按钮仅仅只在Android3.0之后的版本中才能显示（因为这个功能被ActionBar代替，在API 11+中定义）。所以，在给这个按钮添加事件之间，你可以这样做: 12345Button catButton = (Button) findViewById(R.id.categorybutton);OnClickListener listener = /* create your listener here */;if (catButton != null) &#123; catButton.setOnClickListener(listener);&#125; 根据当前布局相应(React According to Current Layout)一些操作会根据当前的布局产生不同的效果。比如，在News Reader示例中，当你点击标题（headlines）列表中的某一条headline时， 如果你的UI是双窗格模式， 内容会显示在右边的窗格中，如果你的UI是单窗格模式，会启动一个分开的Activity并显示： 1234567891011121314@Overridepublic void onHeadlineSelected(int index) &#123; mArtIndex = index; if (mIsDualPane) &#123; /* display article on the right pane */ mArticleFragment.displayArticle(mCurrentCat.getArticle(index)); &#125; else &#123; /* start a separate activity */ Intent intent = new Intent(this, ArticleActivity.class); intent.putExtra(&quot;catIndex&quot;, mCatIndex); intent.putExtra(&quot;artIndex&quot;, index); startActivity(intent); &#125;&#125; 同样，如果你的应用处于多窗格模式，那么它应该在导航栏中设置带有选项卡的action bar。而如果是单窗格模式，那么导航栏应该设置为spinner widget。 所以， 你的代码应该检查哪个方案是最合适的： 12345678910111213141516171819202122final String CATEGORIES[] = &#123; &quot;Top Stories&quot;, &quot;Politics&quot;, &quot;Economy&quot;, &quot;Technology&quot; &#125;;public void onCreate(Bundle savedInstanceState) &#123; .... if (mIsDualPane) &#123; /* use tabs for navigation */ actionBar.setNavigationMode(android.app.ActionBar.NAVIGATION_MODE_TABS); int i; for (i = 0; i &lt; CATEGORIES.length; i++) &#123; actionBar.addTab(actionBar.newTab().setText( CATEGORIES[i]).setTabListener(handler)); &#125; actionBar.setSelectedNavigationItem(selTab); &#125; else &#123; /* use list navigation (spinner) */ actionBar.setNavigationMode(android.app.ActionBar.NAVIGATION_MODE_LIST); SpinnerAdapter adap = new ArrayAdapter(this, R.layout.headline_item, CATEGORIES); actionBar.setListNavigationCallbacks(adap, handler); &#125;&#125; 在其他Activity中复用Fragment在多屏幕设计时经常出现的情况是：在一些屏幕配置上设计一个窗格，而在其他屏幕配置上启动一个独立的Activity。例如，在News Reader中，新闻内容文字在大屏幕上市显示在屏幕右边的方框中，而在小屏幕中，则是由单独的activity显示的。 像这样的情况，你就应该在不同的activity中使用同一个Fragment，以此来避免代码的重复， 而达到代码复用的效果。比如，ArticleFragment在双窗格模式下是这样用的： 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 在小屏幕中，它又是如下方式被复用的（没有布局文件）ArticleActivity： 12ArticleFragment frag = new ArticleFragment();getSupportFragmentManager().beginTransaction().add(android.R.id.content, frag).commit(); 当然，如果将这个fragment定义在XML布局文件中，也有同样的效果 但是在这个例子中则没有必要，因为这个articlefragment是这个activity的唯一组件。 当你在设计fragment的时候，非常重要的一点：不要为某个特定的activity设计耦合度高的fragment。通常的做法是， 通过定义抽象接口，并在接口中定义需要与该fragment进行交互的activity的抽象方法，然后与该fragment进行交互的activity实现这些抽象接口方法。 例如，在News Reader中，HeadlinesFragment就很好的诠释了这一点： 1234567891011121314public class HeadlinesFragment extends ListFragment &#123; ... OnHeadlineSelectedListener mHeadlineSelectedListener = null; /* Must be implemented by host activity */ public interface OnHeadlineSelectedListener &#123; public void onHeadlineSelected(int index); &#125; ... public void setOnHeadlineSelectedListener(OnHeadlineSelectedListener listener) &#123; mHeadlineSelectedListener = listener; &#125;&#125; 然后，当用户选择了一个headline item之后，fragment将通知对应的activity指定监听事件（ 而不是通过硬编码的方式去通知）： 1234567891011public class HeadlinesFragment extends ListFragment &#123; ... @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; if (null != mHeadlineSelectedListener) &#123; mHeadlineSelectedListener.onHeadlineSelected(position); &#125; &#125; ...&#125; 处理屏幕配置变化(Handle Screen Configuration Changes)如果使用的是单独的activity来实现你界面的不同部分，你需要注意的是，屏幕变化（如旋转变化）的时候，你也应该根据屏幕配置的变化来保持你的UI布局的一致性。 例如，在传统的Android3.0或以上版本的7寸平板上，News Reader示例在竖屏的时候使用独立的activity显示文章内容，而在横屏的时候，则使用两个窗格模式（即内容显示在右边的方中） 。 这也就意味着，当用户在竖屏模式下观看文章的时候，你需要检测屏幕是否变成了横屏， 如果改变了，则结束当前activity并返回到主activity中，这样，content就能显示在双窗格模式布局中。 12345678910111213141516public class ArticleActivity extends FragmentActivity &#123; int mCatIndex, mArtIndex; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mCatIndex = getIntent().getExtras().getInt(&quot;catIndex&quot;, 0); mArtIndex = getIntent().getExtras().getInt(&quot;artIndex&quot;, 0); // If should be in two-pane mode, finish to return to main activity if (getResources().getBoolean(R.bool.has_two_panes)) &#123; finish(); return; &#125; ...&#125; PS:关于官方的屏幕适配解决方案就暂时介绍到这，更详细的内容可以去自行查阅官方文档：develop.google.com/training/basics/supporting-devices/screens.html#create-layouts 与ScrollView的结合虽然图片完整的展示出来了，但是却发生了轻微的形状改变。为了顺利解决这个问题，就需要与ScrollView结合来完整的展示整张图片。道理不多讲了，直接用一个实例来说明问题。新建一个工程：test_demo_02。然后将所需要展示的图片添加到drawable-hdpi 文件夹下面。接下来开始在layout文件夹中设计布局。 布局代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;fill_parent&quot;android:orientation=&quot;vertical&quot;&gt; &lt;TextViewandroid:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;wrap_content&quot;android:text=&quot;与ScrollView结合的图片布局&quot;/&gt;&lt;ScrollViewandroid:id=&quot;@+id/myScrollView&quot;android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;wrap_content&quot;android:scrollbars=&quot;vertical&quot;android:layout_weight=&quot;4&quot;&gt;&lt;ImageViewandroid:id=&quot;@+id/myImageView&quot;android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;wrap_content&quot;android:background=&quot;@drawable/guozi3&quot;&gt;&lt;/ImageView&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; 结合Html5 和 css3优化界面布局和配置（这块博主暂时未测试，待测试后更新）采用HTML5和CSS3制作界面，然后在WebView视图上进行显示，然后通过JavaScript进行事件的交互是一种很不错的开发技巧。下面举一个例子说明问题。例如：制作一个“花卉采购计划”的表单，然后在WebView上予以显示。 有以下几项内容需要予以说明：1、电脑的桌面浏览器不同于移动手机浏览器，因此需要在HTML的文件的head元素中设置viewport meta标签。 &lt;meta name=”viewport” content=”width=device; user-scalable=0;”2、可以设置不同的CSS级联样式表，来适应不同宽度的屏幕。 比如：最大宽度为320px,可以这样写： 再比如：最小宽度为480px,可以这么写： 与layout_weight的结合(权重属性的使用)在进行视图布局时，与layout_weight的属性值进行有效的结合，可以达到通用的布局效果。layout_weight其实就是用来控制比例的，在实践操作中，有同学说是正比例控制，也有同学说是反比例控制。其实正比例和反比例的情况都是存在的，就看如何与layout_width和layout_height的属性值进行适当的结合啦！俗话说：没有规矩，不成方圆。个人认为，反比例的控制效果，是无节制，无规范结合layout_width和layout_height的产物，极其不提倡，只会把人带入思维的死循环。就像某位所说，这样做，只会将简单问题复杂化，复杂问题深入化，深入问题模糊化，模糊问题抽象化，从而显示学者的高明，实则愚蠢，只是制造垃圾而已。其实，简单的，往往就是最好的。 .9.png图片的使用PS：在前文的Google官方解决方案中，已经介绍了.9图片，这里就不再介绍。 题外话为了适配更多的机型，并且防止用户因为应用占用内存太多，不得不卸载的问题，就要让应用支持安装的SDCard中。具体代码如下：为manifest元素增加属性：android:installLocation=&quot;preferExternal&quot;切记：应用的开发要基于android2.2及以上进行开发才支持安装到SDCard。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>机型适配</tag>
        <tag>屏幕适配</tag>
        <tag>android进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volley 源码解析]]></title>
    <url>%2Fvolley-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[2015年11月24日 05:45:10转自：https://github.com/android-cn/android-open-project-analysis/tree/master/volley Volley 源码解析==================================== ###1. 功能介绍 ####1.1. VolleyVolley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。 名字由来：a burst or emission of many things or a large amount at once发布演讲时候的配图 从名字由来和配图中无数急促的火箭可以看出 Volley 的特点：特别适合数据量小，通信频繁的网络操作。（个人认为 Android 应用中绝大多数的网络操作都属于这种类型）。 ####1.2 Volley 的主要特点(1). 扩展性强。Volley 中大多是基于接口的设计，可配置性强。(2). 一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。(3). 默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现，这两者的区别及优劣在4.2.1 Volley中具体介绍。(4). 提供简便的图片加载工具。 ###2. 总体设计 ####2.1 总体设计图上面是 Volley 的总体设计图，主要是通过两种Dispatch Thread不断从RequestQueue中取出请求，根据是否已缓存调用Cache或Network这两类数据获取接口之一，从内存缓存或是服务器取得请求的数据，然后交由ResponseDelivery去做结果分发及回调处理。 ####2.2 Volley 中的概念简单介绍一些概念，在详细设计中会仔细介绍。Volley 的调用比较简单，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue后，只需要往这个RequestQueue不断 add Request 即可。 Volley：Volley 对外暴露的 API，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue。 Request：表示一个请求的抽象类。StringRequest、JsonRequest、ImageRequest 都是它的子类，表示某种类型的请求。 RequestQueue：表示请求队列，里面包含一个CacheDispatcher(用于处理走缓存请求的调度线程)、NetworkDispatcher数组(用于处理走网络请求的调度线程)，一个ResponseDelivery(返回结果分发接口)，通过 start() 函数启动时会启动CacheDispatcher和NetworkDispatchers。 CacheDispatcher：一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。 NetworkDispatcher：一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理，并判断结果是否要进行缓存。 ResponseDelivery：返回结果分发接口，目前只有基于ExecutorDelivery的在入参 handler 对应线程内进行分发。 HttpStack：处理 Http 请求，返回请求结果。目前 Volley 中有基于 HttpURLConnection 的HurlStack和 基于 Apache HttpClient 的HttpClientStack。 Network：调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。 Cache：缓存请求结果，Volley 默认使用的是基于 sdcard 的DiskBasedCache。NetworkDispatcher得到请求结果后判断是否需要存储在 Cache，CacheDispatcher会从 Cache 中取缓存结果。 ###3. 流程图Volley 请求流程图 上图是 Volley 请求时的流程图，在 Volley 的发布演讲中给出，我在这里将其用中文重新画出。 ###4. 详细设计 ####4.1 类关系图这是 Volley 框架的主要类关系图 图中红色圈内的部分，组成了 Volley 框架的核心，围绕 RequestQueue 类，将各个功能点以组合的方式结合在了一起。各个功能点也都是以接口或者抽象类的形式提供。红色圈外面的部分，在 Volley 源码中放在了 toolbox 包中，作为 Volley 为各个功能点提供的默认的具体实现。通过类图我们看出， Volley 有着非常好的拓展性。通过各个功能点的接口，我们可以给出自定义的，更符合我们需求的具体实现。 多用组合，少用继承；针对接口编程，不针对具体实现编程。 优秀框架的设计，令人叫绝，受益良多。 ###4.2 核心类功能介绍 ####4.2.1 Volley.java这个和 Volley 框架同名的类，其实是个工具类，作用是构建一个可用于添加网络请求的RequestQueue对象。(1). 主要函数Volley.java 有两个重载的静态方法。123public static RequestQueue newRequestQueue(Context context)public static RequestQueue newRequestQueue(Context context, HttpStack stack) 第一个方法的实现调用了第二个方法，传 HttpStack 参数为 null。第二个方法中，如果 HttpStatck 参数为 null，则如果系统在 Gingerbread 及之后(即 API Level &gt;= 9)，采用基于 HttpURLConnection 的 HurlStack，如果小于 9，采用基于 HttpClient 的 HttpClientStack。1234567if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; stack = new HurlStack(); &#125; else &#123; stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); &#125;&#125; 得到了 HttpStack,然后通过它构造一个代表网络（Network）的具体实现BasicNetwork。接着构造一个代表缓存（Cache）的基于 Disk 的具体实现DiskBasedCache。最后将网络（Network）对象和缓存（Cache）对象传入构建一个 RequestQueue，启动这个 RequestQueue，并返回。1234Network network = new BasicNetwork(stack);RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);queue.start();return queue; 我们平时大多采用Volly.newRequestQueue(context)的默认实现，构建 RequestQueue。通过源码可以看出，我们可以抛开 Volley 工具类构建自定义的 RequestQueue，采用自定义的HttpStatck，采用自定义的Network实现，采用自定义的 Cache 实现等来构建RequestQueue。优秀框架的高可拓展性的魅力来源于此啊 (2). HttpURLConnection 和 AndroidHttpClient(HttpClient 的封装)如何选择及原因：在 Froyo(2.2) 之前，HttpURLConnection 有个重大 Bug，调用 close() 函数会影响连接池，导致连接复用失效，所以在 Froyo 之前使用 HttpURLConnection 需要关闭 keepAlive。另外在 Gingerbread(2.3) HttpURLConnection 默认开启了 gzip 压缩，提高了 HTTPS 的性能，Ice Cream Sandwich(4.0) HttpURLConnection 支持了请求结果缓存。再加上 HttpURLConnection 本身 API 相对简单，所以对 Android 来说，在 2.3 之后建议使用 HttpURLConnection，之前建议使用 AndroidHttpClient。 (3). 关于 User Agent通过代码我们发现如果是使用 AndroidHttpClient，Volley 还会将请求头中的 User-Agent 字段设置为 App 的 ${packageName}/${versionCode}，如果异常则使用 “volley/0”，不过这个获取 User-Agent 的操作应该放到 if else 内部更合适。而对于 HttpURLConnection 却没有任何操作，为什么呢？如果用 Fiddler 或 Charles 对数据抓包我们会发现，我们会发现 HttpURLConnection 默认是有 User-Agent 的，类似：1Dalvik/1.6.0 (Linux; U; Android 4.1.1; Google Nexus 4 - 4.1.1 - API 16 - 768x1280_1 Build/JRO03S) 经常用 WebView 的同学会也许会发现似曾相识，是的，WebView 默认的 User-Agent 也是这个。实际在请求发出之前，会检测 User-Agent 是否为空，如果不为空，则加上系统默认 User-Agent。在 Android 2.1 之后，我们可以通过1String userAgent = System.getProperty("http.agent"); 得到系统默认的 User-Agent，Volley 如果希望自定义 User-Agent，可在自定义 Request 中重写 getHeaders() 函数1234567891011121314151617@Overridepublic Map&lt;String, String&gt; getHeaders() throws AuthFailureError &#123; // self-defined user agent Map&lt;String, String&gt; headerMap = new HashMap&lt;String, String&gt;(); headerMap.put("User-Agent", "android-open-project-analysis/1.0"); return headerMap;&#125;``` ####4.2.2 Request.java代表一个网络请求的抽象类。我们通过构建一个`Request`类的非抽象子类(StringRequest、JsonRequest、ImageRequest 或自定义)对象，并将其加入到·RequestQueue·中来完成一次网络请求操作。 Volley 支持 8 种 Http 请求方式 **GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE, PATCH** Request 类中包含了请求 url，请求请求方式，请求 Header，请求 Body，请求的优先级等信息。 **因为是抽象类，子类必须重写的两个方法。** ```javaabstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response); 子类重写此方法，将网络返回的原生字节内容，转换成合适的类型。此方法会在工作线程中被调用。 1abstract protected void deliverResponse(T response); 子类重写此方法，将解析成合适类型的内容传递给它们的监听回调。 以下两个方法也经常会被重写1public byte[] getBody() 重写此方法，可以构建用于 POST、PUT、PATCH 请求方式的 Body 内容。1protected Map&lt;String, String&gt; getParams() 在上面getBody函数没有被重写情况下，此方法的返回值会被 key、value 分别编码后拼装起来转换为字节码作为 Body 内容。 ####4.2.3 RequestQueue.javaVolley 框架的核心类，将请求 Request 加入到一个运行的RequestQueue中，来完成请求操作。 ####(1). 主要成员变量RequestQueue 中维护了两个基于优先级的 Request 队列，缓存请求队列和网络请求队列。放在缓存请求队列中的 Request，将通过缓存获取数据；放在网络请求队列中的 Request，将通过网络获取数据。12private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue = new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;(); 维护了一个正在进行中，尚未完成的请求集合。1private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;(); 维护了一个等待请求的集合，如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列。1private final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = new HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;(); ####(2). 启动队列创建出 RequestQueue 以后，调用 start 方法，启动队列。 1234567891011121314151617/** * Starts the dispatchers in this queue. */public void start() &#123; stop(); // Make sure any currently running dispatchers are stopped. // Create the cache dispatcher and start it. mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // Create network dispatchers (and corresponding threads) up to the pool size. for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125;&#125; start 方法中，开启一个缓存调度线程CacheDispatcher和 n 个网络调度线程NetworkDispatcher，这里 n 默认为 4，存在优化的余地，比如可以根据 CPU 核数以及网络类型计算更合适的并发数。缓存调度线程不断的从缓存请求队列中取出 Request 去处理，网络调度线程不断的从网络请求队列中取出 Request 去处理。 ####(3). 加入请求1public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request); 流程图如下： ####(4). 请求完成1void finish(Request&lt;?&gt; request) Request 请求结束 (1). 首先从正在进行中请求集合mCurrentRequests中移除该请求。(2). 然后查找请求等待集合mWaitingRequests中是否存在等待的请求，如果存在，则将等待队列移除，并将等待队列所有的请求添加到缓存请求队列中，让缓存请求处理线程CacheDispatcher自动处理。 ####(5). 请求取消12public void cancelAll(RequestFilter filter)public void cancelAll(final Object tag) 取消当前请求集合中所有符合条件的请求。filter 参数表示可以按照自定义的过滤器过滤需要取消的请求。tag 表示按照Request.setTag设置好的 tag 取消请求，比如同属于某个 Activity 的。 ####4.2.4 CacheDispatcher.java一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery 去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。 ####(1). 成员变量BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue 缓存请求队列BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue 网络请求队列Cache mCache 缓存类，代表了一个可以获取请求结果，存储请求结果的缓存ResponseDelivery mDelivery 请求结果传递类 ####(2). 处理流程图 ####4.2.5 NetworkDispatcher.java一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给 ResponseDelivery 去执行后续处理，并判断结果是否要进行缓存。 ####(1). 成员变量BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue 网络请求队列Network mNetwork 网络类，代表了一个可以执行请求的网络Cache mCache 缓存类，代表了一个可以获取请求结果，存储请求结果的缓存ResponseDelivery mDelivery 请求结果传递类，可以传递请求的结果或者错误到调用者 ####(2). 处理流程图 ####4.2.6 Cache.java缓存接口，代表了一个可以获取请求结果，存储请求结果的缓存。 ####(1). 主要方法：public Entry get(String key); 通过 key 获取请求的缓存实体public void put(String key, Entry entry); 存入一个请求的缓存实体public void remove(String key); 移除指定的缓存实体public void clear(); 清空缓存 ####(2). 代表缓存实体的内部类 Entry成员变量和方法byte[] data 请求返回的数据（Body 实体）String etag Http 响应首部中用于缓存新鲜度验证的 ETaglong serverDate Http 响应首部中的响应产生时间long ttl 缓存的过期时间long softTtl 缓存的新鲜时间Map&lt;String, String&gt; responseHeaders 响应的 Headersboolean isExpired() 判断缓存是否过期，过期缓存不能继续使用boolean refreshNeeded() 判断缓存是否新鲜，不新鲜的缓存需要发到服务端做新鲜度的检测 ####4.2.7 DiskBasedCache.java继承 Cache 类，基于 Disk 的缓存实现类。 ####(1). 主要方法：public synchronized void initialize() 初始化，扫描缓存目录得到所有缓存数据摘要信息放入内存。public synchronized Entry get(String key) 从缓存中得到数据。先从摘要信息中得到摘要信息，然后读取缓存数据文件得到内容。public synchronized void put(String key, Entry entry) 将数据存入缓存内。先检查缓存是否会满，会则先删除缓存中部分数据，然后再新建缓存文件。private void pruneIfNeeded(int neededSpace) 检查是否能再分配 neededSpace 字节的空间，如果不能则删除缓存中部分数据。public synchronized void clear() 清空缓存。public synchronized void remove(String key) 删除缓存中某个元素。 ####(2). CacheHeader 类CacheHeader 是缓存文件摘要信息，存储在缓存文件的头部，与上面的Cache.Entry相似。 ####4.2.8 NoCache.java继承 Cache 类，不做任何操作的缓存实现类，可将它作为构建RequestQueue的参数以实现一个不带缓存的请求队列。 ####4.2.9 Network.java代表网络的接口，处理网络请求。唯一的方法，用于执行特定请求。1public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError; ####4.2.10 NetworkResponse.javaNetwork中方法 performRequest 的返回值，Request的 parseNetworkResponse(…) 方法入参，是 Volley 中用于内部 Response 转换的一级。封装了网络请求响应的 StatusCode，Headers 和 Body 等。 ####(1). 成员变量int statusCode Http 响应状态码byte[] data Body 数据Map&lt;String, String&gt; headers 响应 Headersboolean notModified 表示是否为 304 响应long networkTimeMs 请求耗时 ####(2). Volley 的内部 Response 转换流程图从上到下表示从得到数据后一步步的处理，箭头旁的注释表示该步处理后的实体类。 ####4.2.11 BasicNetwork.java实现 Network，Volley 中默认的网络接口实现类。调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。主要实现了以下功能：(1). 利用 HttpStack 执行网络请求。(2). 如果 Request 中带有实体信息，如 Etag,Last-Modify 等，则进行缓存新鲜度的验证，并处理 304（Not Modify）响应。(3). 如果发生超时，认证失败等错误，进行重试操作，直到成功、抛出异常(不满足重试策略等)结束。 ####4.2.12 HttpStack.java用于处理 Http 请求，返回请求结果的接口。目前 Volley 中的实现有基于 HttpURLConnection 的 HurlStack 和 基于 Apache HttpClient 的 HttpClientStack。唯一方法，执行请求12public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError; 执行 Request 代表的请求，第二个参数表示发起请求之前，添加额外的请求 Headers。 ####4.2.13 HttpClientStack.java实现 HttpStack 接口，利用 Apache 的 HttpClient 进行各种请求方式的请求。基本就是 org.apache.http 包下面相关类的常见用法，不做详解，不过与下面 HttpURLConnection 做下对比就能发现 HttpURLConnection 的 API 相对简单的多。 ####4.2.14 HurlStack.java实现 HttpStack 接口，利用 Java 的 HttpURLConnection 进行各种请求方式的请求。 ####4.2.15 Response.java封装了经过解析后的数据，用于传输。并且有两个内部接口 Listener 和 ErrorListener 分别可表示请求失败和成功后的回调。Response 的构造函数被私有化，而通过两个函数名更易懂的静态方法构建对象。 ####4.2.16 ByteArrayPool.javabyte[] 的回收池，用于 byte[] 的回收再利用，减少了内存的分配和回收。主要通过一个元素长度从小到大排序的ArrayList作为 byte[] 的缓存，另有一个按使用时间先后排序的ArrayList属性用于缓存满时清理元素。1public synchronized void returnBuf(byte[] buf) 将用过的 byte[] 回收，根据 byte[] 长度按照从小到大的排序将 byte[] 插入到缓存中合适位置。1public synchronized byte[] getBuf(int len) 获取长度不小于 len 的 byte[]，遍历缓存，找出第一个长度大于传入参数len的 byte[]，并返回；如果最终没有合适的 byte[]，new 一个返回。1private synchronized void trim() 当缓存的 byte 超过预先设置的大小时，按照先进先出的顺序删除最早的 byte[]。 ####4.2.17 PoolingByteArrayOutputStream.java继承 ByteArrayOutputStream，原始 ByteArrayOutputStream 中用于接受写入 bytes 的 buf，每次空间不足时便会 new 更大容量的 byte[]，而 PoolingByteArrayOutputStream 使用了 ByteArrayPool 作为 Byte[] 缓存来减少这种操作，从而提高性能。 ####4.2.18 HttpHeaderParser.javaHttp header 的解析工具类，在 Volley 中主要作用是用于解析 Header 从而判断返回结果是否需要缓存，如果需要返回 Header 中相关信息。有三个方法1public static long parseDateAsEpoch(String dateStr) 解析时间，将 RFC1123 的时间格式，解析成 epoch 时间 1public static String parseCharset(Map&lt;String, String&gt; headers) 解析编码集，在 Content-Type 首部中获取编码集，如果没有找到，默认返回 ISO-8859-1 1public static Cache.Entry parseCacheHeaders(NetworkResponse response) 比较重要的方法，通过网络响应中的缓存控制 Header 和 Body 内容，构建缓存实体。如果 Header 的 Cache-Control 字段含有no-cache或no-store表示不缓存，返回 null。(1). 根据 Date 首部，获取响应生成时间(2). 根据 ETag 首部，获取响应实体标签(3). 根据 Cache－Control 和 Expires 首部，计算出缓存的过期时间，和缓存的新鲜度时间 两点需要说明下：1.没有处理Last-Modify首部，而是处理存储了Date首部，并在后续的新鲜度验证时，使用Date来构建If-Modified-Since。这与 Http 1.1 的语义有些违背。2.计算过期时间，Cache－Control 首部优先于 Expires 首部。 ####4.2.19 RetryPolicy.java重试策略接口有三个方法：1public int getCurrentTimeout(); 获取当前请求用时（用于 Log）1public int getCurrentRetryCount(); 获取已经重试的次数（用于 Log）1public void retry(VolleyError error) throws VolleyError; 确定是否重试，参数为这次异常的具体信息。在请求异常时此接口会被调用，可在此函数实现中抛出传入的异常表示停止重试。 ####4.2.20 DefaultRetryPolicy.java实现 RetryPolicy，Volley 默认的重试策略实现类。主要通过在 retry(…) 函数中判断重试次数是否达到上限确定是否继续重试。其中mCurrentRetryCount变量表示已经重试次数。mBackoffMultiplier表示每次重试之前的 timeout 该乘以的因子。mCurrentTimeoutMs变量表示当前重试的 timeout 时间，会以mBackoffMultiplier作为因子累计前几次重试的 timeout。 ####4.2.21 ResponseDelivery.java请求结果的传输接口，用于传递请求结果或者请求错误。有三个方法：1public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response); 此方法用于传递请求结果，request 和 response 参数分别表示请求信息和返回结果信息。1public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable); 此方法用于传递请求结果，并在完成传递后执行 Runnable。1public void postError(Request&lt;?&gt; request, VolleyError error); 此方法用于传输请求错误。 ####4.2.22 ExecutorDelivery.java请求结果传输接口具体实现类。在 Handler 对应线程中传输缓存调度线程或者网络调度线程中产生的请求结果或请求错误，会在请求成功的情况下调用 Request.deliverResponse(…) 函数，失败时调用 Request.deliverError(…) 函数。 ####4.2.23 StringRequest.java继承 Request 类,代表了一个返回值为 String 的请求。将网络返回的结果数据解析为 String 类型。通过构造函数的 listener 传参，支持请求成功后的 onResponse(…) 回调。 ####4.2.24 JsonRequest.java抽象类，继承自 Request，代表了 body 为 JSON 的请求。提供了构建 JSON 请求参数的方法。 ####4.2.25 JsonObjectRequest.java继承自 JsonRequest，将网络返回的结果数据解析为 JSONObject 类型。 ####4.2.26 JsonArrayRequest.java继承自 JsonRequest，将网络返回的结果数据解析为 JSONArray 类型。 ####4.2.27 ImageRequest.java继承 Request 类，代表了一个返回值为 Image 的请求。将网络返回的结果数据解析为 Bitmap 类型。可以设置图片的最大宽度和最大高度，并计算出合适尺寸返回。每次最多解析一张图片防止 OOM。 ####4.2.28 ImageLoader.java封装了 ImageRequst 的方便使用的图片加载工具类。 1.可以设置自定义的ImageCache，可以是内存缓存，也可以是 Disk 缓存，将获取的图片缓存起来，重复利用，减少请求。2.可以定义图片请求过程中显示的图片和请求失败后显示的图片。3.相同请求（相同地址，相同大小）只发送一个，可以避免重复请求。// TODO ####4.2.29 NetworkImageView.java利用 ImageLoader，可以加载网络图片的 ImageView有三个公开的方法：1public void setDefaultImageResId(int defaultImage) 设置默认图片，加载图片过程中显示。1public void setErrorImageResId(int errorImage) 设置错误图片，加载图片失败后显示。1public void setImageUrl(String url, ImageLoader imageLoader) 设置网络图片的 Url 和 ImageLoader，将利用这个 ImageLoader 去获取网络图片。 如果有新的图片加载请求，会把这个 ImageView 上旧的加载请求取消。 ####4.2.30 ClearCacheRequest.java用于人为清空 Http 缓存的请求。添加到 RequestQueue 后能很快执行，因为优先级很高，为Priority.IMMEDIATE。并且清空缓存的方法mCache.clear()写在了isCanceled()方法体中，能最早的得到执行。 ClearCacheRequest 的写法不敢苟同，目前看来唯一的好处就是可以将清空缓存操作也当做一个请求。而在isCanceled()中做清空操作本身就造成了歧义，不看源码没人知道在NetworkDispatcher run 方法循环的过程中，isCanceled()这个读操作竟然做了可能造成缓存被清空。只能跟源码的解释一样当做一个 Hack 操作。 ####4.2.31 Authenticator.java身份认证接口，用于基本认证或者摘要认证。这个类是 Volley 用于和身份验证打通的接口，比如 OAuth，不过目前的使用不是特别广泛和 Volley 的内部结合也不是特别紧密。 ####4.2.32 AndroidAuthenticator.java继承 Authenticator，基于 Android AccountManager 的认证交互实现类。 ####4.2.33 VolleyLog.javaVolley 的 Log 工具类。 ####4.2.34 VolleyError.javaVolley 中所有错误异常的父类，继承自 Exception，可通过此类设置和获取 NetworkResponse 或者请求的耗时。 ####4.2.35 AuthFailureError.java继承自 VolleyError，代表请求认证失败错误，如 RespondeCode 的 401 和 403。 ####4.2.36 NetworkError.java继承自 VolleyError，代表网络错误。 ####4.2.37 ParseError.java继承自 VolleyError，代表内容解析错误。 ####4.2.38 ServerError.java继承自 VolleyError，代表服务端错误。 ####4.2.39 TimeoutError.java继承自 VolleyError，代表请求超时错误。 ####4.2.40 NoConnectionError.java继承自 NetworkError，代表无法建立连接错误。 ###5. 杂谈 ####5.1 关于 Http 缓存Volley 构建了一套相对完整的符合 Http 语义的缓存机制。优点和特点(1). 根据Cache-Control和Expires首部来计算缓存的过期时间。如果两个首部都存在情况下，以Cache-Control为准。(2). 利用If-None-Match和If-Modified-Since对过期缓存或者不新鲜缓存，进行请求再验证，并处理 304 响应，更新缓存。(3). 默认的缓存实现，将缓存以文件的形式存储在 Disk，程序退出后不会丢失。 我个人认为的不足之处缓存的再验证方面，在构建If-Modified-Since请求首部时，Volley 使用了服务端响应的Date首部，没有使用Last-Modified首部。整个框架没有使用Last-Modified首部。这与 Http 语义不符。123456789101112131415private void addCacheHeaders(Map&lt;String, String&gt; headers, Cache.Entry entry) &#123; // If there's no cache entry, we're done. if (entry == null) &#123; return; &#125; if (entry.etag != null) &#123; headers.put("If-None-Match", entry.etag); &#125; if (entry.serverDate &gt; 0) &#123; Date refTime = new Date(entry.serverDate); headers.put("If-Modified-Since", DateUtils.formatDate(refTime)); &#125;&#125; 服务端根据请求时通过If-Modified-Since首部传过来的时间，判断资源文件是否在If-Modified-Since时间 以后 有改动，如果有改动，返回新的请求结果。如果没有改动，返回 304 not modified。Last-Modified代表了资源文件的最后修改时间。通常使用这个首部构建If-Modified-Since的时间。Date代表了响应产生的时间，正常情况下Date时间在Last-Modified时间之后。也就是Date&gt;=Last-Modified。通过以上原理，既然Date&gt;=Last-Modified。那么我利用Date构建，也是完全正确的。 可能的问题出在服务端的 Http 实现上，如果服务端完全遵守 Http 语义，采用时间比较的方式来验证If-Modified-Since，判断服务器资源文件修改时间是不是在If-Modified-Since之后。那么使用Date完全正确。可是有的服务端实现不是比较时间，而是直接的判断服务器资源文件修改时间，是否和If-Modified-Since所传时间相等。这样使用Date就不能实现正确的再验证，因为Date的时间总不会和服务器资源文件修改时间相等。 尽管使用Date可能出现的不正确情况，归结于服务端没有正确的实现 Http 语义。但我还是希望 Volley 也能完全正确的实现 Http 语义，至少同时处理Last-Modified和Date,并且优先使用Last-Modified。 ####5.2 Bug #####(1). BasicNetwork.performRequest(…)如下代码：12345678910111213141516171819@Overridepublic NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; …… while (true) &#123; …… try &#123; …… &#125; catch (IOException e) &#123; int statusCode = 0; NetworkResponse networkResponse = null; …… if (responseContents != null) &#123; …… &#125; else &#123; throw new NetworkError(networkResponse); &#125; &#125; &#125;&#125; BasicNetwork.performRequest(…) 最后的1throw new NetworkError(networkResponse); 应该是1throw new NetworkError(e); 更合理。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>开源项目</tag>
        <tag>volley</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发中乱码问题的解决]]></title>
    <url>%2Fweb%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3.html</url>
    <content type="text"><![CDATA[web开发中乱码问题的解决由于楼主刚刚接触web不久，自然而然的就遇到了乱码问题。下面就记录一下乱码问题的解决。 表单的提交分为GET和POST两种请求方式。两种方式的乱码解决又不一样，用post提交请求时，只需要在接受的时候加上request.setCharacterEncoding(&quot;utf-8&quot;); 而GET的请求方法在处理时，应该将接收过来的值打碎成 ISO-8859-1编码，然后再组装成utf-8:new String(request.getParameter(param).getBytes(&quot;iso-8859-1&quot;),&quot;UTF-8&quot;); 过滤器的乱码处理问题 如果每次接收都像上面那样去处理的话肯定是太麻烦了，用过滤器来处理请求的乱码问题很方便，只需要写一个过滤器，就可以过滤所有请求页面的乱码问题了。至于如何用过滤器处理乱码请参考用过滤器来解决JSP中的乱码问题。不过值得注意的是，如果使用Struts的话，在web.xml里面处理编码的过滤器必须在struts过滤器前面注册，否则所有页面都不会经过过滤器。 AJAX请求的乱码问题 如果使用ajax出现了乱码问题这样解决：前端ajax函数的请求的url里面中文参数用两个encodeURI()函数处理，var url=&quot;user.do?p=checkUser&amp;name=&quot;+encodingURI(encodingURI(username.value))&quot;而服务器端则用 URLDecoder.decode()函数去接收，string userName = URLDecoder.decode(request.getParameter(&quot;name&quot;),&quot;utf-8&quot;); 这样就能够解决ajax请求中乱码的问题了。 PS:以上几条是摘自网上的。我暂时还没遇到。 在我的项目中，遇到的问题是发送get请求时出现乱码，导致这个问题的原因是，我在web.xml 文件中之配置了针对post请求的编码设置，但是tomcat对POST和GET请求的处理方式是不一样的，我们要针对GET请求出现乱码问题的解决，就需要修改tomcat下的server.xml文件，如下所示：将原来的配置：1&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 改为：1&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; useBodyEncodingForURI=&quot;true&quot;/&gt; 然而，如果你修改的是tomcat安装目录下的server.xml文件的话，那么你在eclipse当中运行项目时会发现配置并没有起作用，这是因为eclipse在运行时用的是eclipse当中配置的tomact，所以我们需要打开左侧项目列表server文件夹--&gt;tomcat--&gt;server.xml按照以上的方式做同样的修改. ！这里需要注意的是：配置useBodyEncodingForURI=&quot;true&quot;后，可以解决普通get请求的中文乱码问题，但是对于通过ajax发起的get请求中文依然会乱码，请把useBodyEncodingForURI=&quot;true&quot;改为URIEncoding=&quot;UTF-8&quot;即可。 然而经过了以上的设置之后，博主的乱码问题依然没有解决，如下图所示： 在建立一条新数据之后，显示出来的是一串的？？？？。好吧，这时候自然而然的想到了数据库的编码问题了。于是， 1234567891011121314sudo /ect/init.d/mysql startmysql&gt; show variables like &quot;%char%&quot;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+ 根据上面的显示我们可以发现character-set-server和character-set-database的编码是latin1，所以，接下来我就要将其修改为utf8了。 12345// 1. 打开mysql的配置文件，ubuntu下是my.cnflucas@lucas-ThinkPad-PC:~$ sudo vim /etc/mysql/my.cnf// 2. 在配置文件中加入以下一句character-set-server=utf8 // 自己根据对应的需要修改的在对应的节点下添加。// 3. 这样问题就解决了。 我是使用命令行进行修改的： 12345678910111213141516171819202122232425262728293031323334353637lucas@lucas-ThinkPad-PC:~$ suroot@lucas-ThinkPad-PC:/home/lucas# mysql -u root -pmysql&gt; set character_set_client=utf8;Query OK, 0 rows affected (0.00 sec)mysql&gt; set character_set_connection=utf8;Query OK, 0 rows affected (0.00 sec)mysql&gt; set character_set_database=utf8;Query OK, 0 rows affected (0.00 sec)mysql&gt; set character_set_results=utf8;Query OK, 0 rows affected (0.00 sec)mysql&gt; set character_set_server=utf8;Query OK, 0 rows affected (0.00 sec)mysql&gt; set character_set_system=utf8;Query OK, 0 rows affected (0.01 sec)mysql&gt; set collation_connection=utf8;Query OK, 0 rows affected (0.01 sec)mysql&gt; set collation_database=utf8;Query OK, 0 rows affected (0.01 sec)mysql&gt; set collation_server=utf8;Query OK, 0 rows affected (0.01 sec)mysql&gt; show variables like &apos;character_set_%&apos;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec)// 经过一番折腾之后，修改完毕，重启数据库，再运行一下项目，发现添加数据再也没有乱码了。 当然，除此之外，还有一些乱码的问题，例如浏览器的默认编码啊什么的。这些直接设置一下浏览器的编码就行了。还有许多我暂时还没接触到的。等博主接触到了再加上去吧。继续上班。。。。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>utf-8</tag>
        <tag>编码</tag>
        <tag>乱码</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven加入json-lib.jar报错Missing artifact net.sf.json-lib:json-lib:jar:2.4:compile]]></title>
    <url>%2Fmaven%E5%8A%A0%E5%85%A5json-lib-jar%E6%8A%A5%E9%94%99Missing-artifact-net-sf-json-lib-json-lib-jar-2-4-compile.html</url>
    <content type="text"><![CDATA[在pom.xml文件中添加json-lib： 12345&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 出现错误： Missing artifact net.sf.json-lib:json-lib:jar:2.4:compile 出现错误的原因：json-lib是区分jdk版本的，pom.xml中的配置应该加上标签classifiter指定jdk版本: 1234567&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;!-- 加上jdk版本,如jdk15 --&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt;&lt;/dependency&gt; 这样，错误就解决了。]]></content>
      <categories>
        <category>java开发问题</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS下使用pyenv管理Python版本]]></title>
    <url>%2FMac-OS%E4%B8%8B%E4%BD%BF%E7%94%A8pyenv%E7%AE%A1%E7%90%86Python%E7%89%88%E6%9C%AC.html</url>
    <content type="text"><![CDATA[问题的由来在开发过程中，可能会遇到多个版本同时部署的情况。 Mac OS自带的Python版本是2.x，自己开发需要Python3.x 系统自带的是2.6.x，开发环境是2.7.x 由于Mac机器系统保护的原因，默认的Python无法对PIP一些包升级，需要组建新的Python环境 此时需要在系统中安装多个版本的Python，但又不能影响系统自带的Python，即需要实现Python的多版本共存。pyenv就是这样一个Python版本管理器。 Pyenvpyenv是Python版本管理工具。pyenv可以改变全局的Python版本，安装多个版本的Python，设置目录级别的Python版本，还能创建和管理vitual python enviroments。所有的设置都是用户级别的操作，不需要sudo命令。 pyenv主要用来管理Python的版本，比如一个项目需要Python2.x，一个项目需要Python3.x。而virtualenv主要用来管理Python包的依赖。不同项目需要依赖的包版本不同，则需要使用虚拟环境。 pyenv通过系统修改环境变量来实现Python不同版本的切换。而vitualenv通过Python包安装到一个目录来作为Python虚拟包环境，通过切换目录来实现不同包环境间的切换。 pyenv的美好之处在于，它并没有使用将不同的 PATH植入不同的shell这种高耦合的工作方式，而是简单地在PATH植入不同的shell这种高耦合的工作方式，而是简单地在PATH 的最前面插入了一个垫片路径（shims）：~/.pyenv/shims:/usr/local/bin:/usr/bin:/bin。所有对 Python 可执行文件的查找都会首先被这个 shims 路径截获，从而使后方的系统路径失效。 安装之前不同系统请参考 Common build problems，安装必须的工具。 pyenv安装安装homebrew如何安装homebrew？ 安装pyenv使用homebrew安装Mac下安装了homebrew之后使用homebrew安装pyenv。 123brew updatebrew install pyenvbrew upgrade pyenv #之后如果需要更新pyenv 在安装成功之后需要在.bashrc或者.bash_profile中添加三行来开启自动补全。 123export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;eval &quot;$(pyenv init -)&quot;eval &quot;$(pyenv virtualenv-init -)&quot; 自动安装pyenv提供了自动安装的工具，执行命令安装即可。 1curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash 需要保证系统又git，否则需要安装git。 手动安装也可以采用手动安装的方式，将pyenv检出到你想安装的目录。 123456cd ~git clone git://github.com/yyuu/pyenv.git .pyenvecho &apos;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&apos; &gt;&gt; ~/.bashrcecho &apos;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&apos; &gt;&gt; ~/.bashrcecho &apos;eval &quot;$(pyenv init -)&quot;&apos; &gt;&gt; ~/.bashrcsource ~/.bashrc 添加环境变量。PYENV_ROOT 指向 pyenv 检出的根目录，并向 $PATH 添加 $PYENV_ROOT/bin 以提供访问 pyenv命令的路径。 这里的 shell 配置文件（~/.bash_profile）依不同 Linux 而需作修改，如果使用 Zsh 则需要相应的配置 ~/.zshrc 在使用 pyenv 之后使用 pip 安装的第三方模块会自动安装到当前使用 python 版本下，不会和系统模块产生冲突。使用 pip 安装模块之后，如果没有生效，记得使用 pyenv rehash 来更新垫片路径。 pyenv常用命令使用pyenv commands可以查看所有pyenv命令。 查看已安装Python版本 pyenv versions 123ferdinand@ferdinanddeMacBook-Pro  ~  pyenv versions system* 3.6.3 (set by /Users/ferdinand/.python-version) 带*号的是当前路径下所使用的Python版本。 查看可安装的Python版本 pyenv install -l 1234567891011121314151617181920212223242526272829erdinand@ferdinanddeMacBook-Pro  ~  pyenv install -lAvailable versions: 2.1.3 2.2.3 2.3.7 2.4 2.4.1 2.4.2 2.4.3 2.4.4 2.4.5 2.4.6 2.5 2.5.1 2.5.2 2.5.3 2.5.4 2.5.5 2.5.6 2.6.6 2.6.7 2.6.8 2.6.9 2.7-dev 2.7 2.7.1 2.7.2 2.7.3 ………… 安装Python1pyenv install &lt;version&gt; # version为版本号 Python版本管理123pyenv global &lt;version&gt; # 全局设置python版本为指定版本，设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。pyenv local &lt;version&gt; # 设置当前路径下python版本为指定版本，设置 Python 本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。pyenv shell &lt;version&gt; # 设置当前shell窗口使用的python版本为指定版本，设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。这个版本的优先级比 local 和 global 都要高。–unset 参数可以用于取消当前 shell 设定的版本。 使用pyenv切换Python 版本之后可以通过which python或者是python --version来查看是否生效。 1234ferdinand@ferdinanddeMacBook-Pro  ~  which python/Users/ferdinand/.pyenv/shims/pythonferdinand@ferdinanddeMacBook-Pro  ~  python --versionPython 3.6.3 Python版本的优先级 shell &gt; local &gt; global pyenv会从当前目录开始向上逐级查找.python-versiob文件，直到根目录为止，若找不到，则使用global版本。 1pyenv rehash # 创建垫片路径（为所有已安装的可执行文件创建 shims，如：~/.pyenv/versions/*/bin/*，因此，每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令） Python卸载12pyenv isntall &lt;version&gt; # 安装版本号为&lt;version&gt;的Pythonpyenv uninstall &lt;version&gt; #卸载版本号为&lt;version&gt;的Python]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pyenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下关于将普通用户权限提升为root的问题]]></title>
    <url>%2FUbuntu%E4%B8%8B%E5%85%B3%E4%BA%8E%E5%B0%86%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E4%B8%BAroot%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[问题的由来 博主一个好奇就想把自己的那个用户提升为root级别的，所以进行了如下操作。1234567suvi etc/passwd然后将自己创建的那个用户（博主的用户名为lucas），对应的值lucas:x:1000:0:lucas,,,:/home/lucas:/bin/bash中的1000修改成了和root用户一样的0.好吧，这下lucas确实成了root用户了，但是问题就来了，你下次登录的适合界面上只剩下客人会话了。其它会话都没了。 解决措施1234567在用户登录界面，按下 `ctrl+alt+f7`进入命令行界面。按照如下操作进行：输入用户名：lucas（博主的）输入密码：xxxxxx然后使用vi命令打开我们修改过的文件：/etc/passwd将0修改成原来的数值。这样我们的登录界面又会出现用户登录啦！好吧。。至此，问题解决。 PS：博主的Linux系统的Ubuntu kylin 15.10 的版本。具体的原因是ubuntu从12.04开始，添加了额外的root保护，不允许直接开启root账户，强制使账户改为root账户会被屏蔽。所以以后不能再继续作死了。老老实实的用sudo吧。%&gt;_&lt;%。 记录时间：2015年12月10日19:05:05。下班吃饭。]]></content>
      <categories>
        <category>问题搜集整理</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>root权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器是如何工作的]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84.html</url>
    <content type="text"><![CDATA[why？ Web浏览器是世界上使用最广泛的软件。 浏览器提供web资源并创建可以允许web应用程序的沙箱环境。 浏览器实现这一点的方式非常复杂，并且由许多不同的标准决定。 浏览器的一些机制其实是具有着欺骗性和反直觉性。 了解浏览器的工作原理为我们提高网站/网页类应用程序的效率和代码的组织结构提供了理论依据。 复杂 这里无法讲解浏览器工作原理的所有细节。 每个浏览器都有自己的实现方式。 一般和模块化的方法 浏览器遵循相同的标准 大多数浏览器有着相同的总体结构和同样的模块 本文将讨论这些共同行为。 浏览器的两个主要模块 渲染引擎（也成为布局引擎） Javascript解释器 不同浏览器使用的渲染引擎不一样 Mozilla Firefox 使用 Gecko Safari 和 Google Chrome（version 27之前）使用Webkit。 Chrome使用Blink在version 27之后 一个web页面的组成 HTML：应用程序的内容 CSS： 内容的样式 Javascript： 应用程序的逻辑部分，有时也是一些动画(animations)等等。 其它 渲染引擎（rendering engine）的工作从HTML,CSS,JS开始，将网页呈现在用户屏幕上，大概需要经过四个阶段： 处理HTML构建DOM，处理CSS构建CSSOM 将DOM和CSSOM合并到一个渲染树中 布局渲染树（render tree）,通过几何计算]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器从请求发出到返回经历了什么]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%AF%B7%E6%B1%82%E5%8F%91%E5%87%BA%E5%88%B0%E8%BF%94%E5%9B%9E%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88.html</url>
    <content type="text"><![CDATA[一个最简单的http请求，没有代理，ipv4和以下任何步骤都没有问题的情况下： 浏览器检查缓存，如果请求的对象在缓存中并且是新的，跳到步骤9。 浏览器从OS获取服务器的ip地址。 OS进行DNS查找，并将IP地址返回给浏览器。 浏览器打开到服务器的TCP连接（如果是https则步骤更复杂点,后面再分析）。 浏览器通过TCP连接发送HTTP请求。 浏览器接受http响应，并可能关闭TCP连接或将其重新用于另一个请求。 浏览器检查响应是重定向还是条件响应（3xx的状态码）,授权请求（401），错误（4xx或5xx）等。这些与正常响应（2xx）的处理方式不同。 如果允许缓存，响应将存储在缓存中。 浏览器解码响应（比如响应是gzip的需要解压缩） 浏览器决定如何处理响应（它可能是一个HTML页面，可能是一张图片，也可能是一个声音片段）。 浏览器渲染响应，或者提示无法识别的类型弹出框警告。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hibernate学习教程（二）----ORM 概述]]></title>
    <url>%2FHibernate%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89-ORM-%E6%A6%82%E8%BF%B0.html</url>
    <content type="text"><![CDATA[什么是JDBC JDBC:Java Database Connectivity，提供一组Java API，用于java程序中访问关系数据库。通过这些API，Java程序能够执行SQL语句并与任何SQL兼容的数据库进行交互。 JDBC提供了一种灵活的架构，可以编写一个独立于数据库的应用程序，该应用程序可以在不同的平台上并与不同的DBMS进行修改。 JDBC的优点和缺点 优点 缺点 简洁的SQL处理 用于大型应用程序时比较复杂 处理大量数据有着良好的性能 资源占用开销比较大 非常适用于小型应用程序 没有进行封装抽象 语法简单，学习成本较低 很难用于MVC模式开发 只能用于DBMS查询 为什么要进行ORM关系映射(Object Relational Mapping)当我们使用面向对象的系统时，对象模型与关系数据库之间存在不匹配。RDBMS以表格形式表示数据，而面向对象的语言（如Java和C#）将其表现为对象的互联图。如下所示： 12345678910111213141516171819202122232425public class Employee &#123; private int id; private String first_name; private String last_name; private int salary; public Employee() &#123;&#125; public Employee(String fname, String lname, int salary) &#123; this.first_name = fname; this.last_name = lname; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public String getFirstName() &#123; return first_name; &#125; public String getLastName() &#123; return last_name; &#125; public int getSalary() &#123; return salary; &#125;&#125; 上面的对象需要被存储和检索到下面的RDBMS表： 1234567create table EMPLOYEE ( id INT NOT NULL auto_increment, first_name VARCHAR(20) default NULL, last_name VARCHAR(20) default NULL, salary INT default NULL, PRIMARY KEY (id)); 那么就会存在以下两个问题： 如果我们需要在开发了几个页面之后或在应用程序中修改数据库的设计时，应该怎么处理？ 在关系数据库加载和存储对象会暴露以下不匹配问题： 不匹配问题 描述 Granularity（粒度） 有时，您将有一个对象模型，它具有比数据库中对应表数量更多的类。 Inheritance（继承） RDBMS不定义类似于继承的任何东西，它是面向对象编程语言中的自然范例。 Identity（对象同一性） RDBMS正好定义了“同一性”的一个概念：主键。然而，Java定义了对象标识（a == b）和对象相等（a.equals（b）） Associations 面向对象语言使用对象引用表示Associations，RDBMS使用外键列表示 Navigation 在Java和RDBMS中访问对象的方式是完全不同的 对象关系映射（ORM）是处理所有上述不匹配问题的解决方案。 粒度问题 粒度：是指你正在使用的类型的大小。 继承（子类型问题） 在Java中，使用超类(superclass)和子类(subclass)来实现继承模型。 在Java中，继承是类型继承(type Inheritance)，而数据库表并不是一种类型。 数据库产品一般不实现类型或者表继承。而且即使实现了，我们也会遇到数据完整性的问题（对可更新视图的有限完整性规则）。 一旦把继承进入到模型当中，就有了多态(polymorphism)的可能。SQL数据库缺乏一种明显的表示多态关联的方式，一个外键约束精确的引用一张目标表，定义一个引用多表的外键并不容易。必须编写一个程序化的约束来加强这种完整性规则。 子类型的这种不匹配的结果是：模型中的继承结构必须在一个不提供继承策略的SQL数据库中被持久化。 对象同一性如果当我们需要检查两个对象是否为同一个对象的时候。解决方法有三种： 在java中： 对象同一性（粗略等同于内存位置，用a==b检查） 等同性，通过equals()方法（也成为值等同）的实现来确定。 数据库的同一性用主键值来表达。如果使用java中的方法来判断，那么主键值必然会不相等。 什么是ORM ORM（对象关系映射），是一种用于关系数据库和面向对象编程语言（如Java、C#）之间转换数据的编程技术。相对于JDBC，ORM具有以下优点： 序号 优点 1 允许业务逻辑代码访问对象而不是数据库表 2 从面向对象的角度考虑隐藏SQL查询的详细信息 3 底层基于JDBC 4 无需处理数据库实现 5 基于业务概念而不是数据库结构的实体 6 事务管理和秘钥自动生成 7 应用快速开发 ORM解决方案由以下四个模块组成： 序号 解决方案 1 用于对持久化类的对象进行基本CRUD操作的API 2 用于指定引用类的类和属性的查询的语言或API 3 用于指定映射元数据的可配置工具 4 用于实现ORM的一项技术，与事务对象交互，执行脏检查、延迟关联抓取以及其它优化功能 Java中的ORM框架Java中有几个持久化框架和ORM选项。持久化框架是一种将对象存储和检索到关系数据库中的ORM服务。 Enterprise JavaBeans Entity Beans Java Data Objects Castor TopLink Spring DAO Hibernate ……. etc. ORM和Hibernate的一些好处生产力与持久化相关的代码可能会是java中最冗长的一部分代码，Hibernate除去了许多琐碎的工作，让我们可以把更多的精力集中于业务问题的处理上。无论我们喜欢哪一种应用程序开发策略——自上而下，从一个领域模型开始；或者自底而上，从一个现有的数据库Schema开始——Hibernate与适当的工具一起使用，将明显减少开发时间。 可维护性更少的代码行使得系统更易于理解，因为它强调业务逻辑甚于那些费力的基础性工作。更重要的是，系统包含的代码越少则越利于重构。自动的对象/关系持久化充分减少了代码行。 Hibernate更易于维护还有其它原因，在手工编码的持久化系统中，关系表示法和对象模型实现领域之间存在一种必然的压力。改变一个，通常都要改变另一个，并且一个表示法设计通常需要妥协以便适应另一个的存在。ORM提供了两个模型之间的一个缓冲，允许面向对象在Java方面进行更优雅的利用，并且每个模型的微小变化都不会传递到另一个模型。 性能手工编码的持久化和自动的持久化相比总是可以一样快，并且经常更快。这是事实。但是在实际开发中，会受到时间和预算的约束。 在有限时间的项目中，手工编码的持久化通常允许你进行一些优化；Hibernate始终允许使用更多的优化。 自动的持久化能够大大提高开发人员的工作效率，使得开发人员能够花更多的时间对其它少数瓶颈进行手工优化。 实现ORM框架的人，可能在性能优化方面比我们做的更好。 供应商独立性ORM从底层的SQL数据库和SQL方言中把应用程序抽象出来。如果这个工具支持不同的数据库，这会给我们的应用程序带来一定程度的可移植性。可以帮我们减少一些被供应商锁定的风险。 数据库的独立性使得我们可以在开发时选择一些轻量级的数据库，在部署时，将实际的产品部署在不同的数据库上。]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>ORM框架</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate教程（一）---Hibernate简介]]></title>
    <url>%2FHibernate%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[Hibernate简介 Hibernate是一个Java对象映射关系的解决方案的ORM（Object-Relational Mapping）框架，是一个开源持久框架，由Gavin King于2001年创建。为Java应用提供强大的、高性能对象持久化和查询服务。 Hibernate将Java类映射到数据库表，将Java数据类型映射到SQL数据类型，减轻了开发人员95%的数据持久性相关的编程任务。 Hibernate位于传统的Java对象和数据库服务器之间，基于适当的O/R机制和模式来处理持久化这些对象的所有工作。 Hibernate的优势 Hibernate通过XML配置文件将Java类映射到数据库表，而不需要编写任何代码。 提供简单的API,用于直接存储和检索数据库中的Java对象。 如果数据库或任何表中有更改，只需要修改XML文件。 提取我们不熟悉的SQL类型，并提供我们熟悉的Java对象。 Hibernate不需要应用府服务器来操作。 操作复杂关联的数据库对象。 使用智能抓取策略简化数据库操作。 提供简单的数据查询。 Hibernate支持的数据库Hibernate几乎支持所有的关系型数据库管理系统(RDBMS),支持的数据库如下所示： HSQL Database Engine DB2/NT MySQL PostgreSQL FrontBase Oracle Microsoft SQL Server Database Sybase SQL Server nformix Dynamic Server Hibernate架构Hibernate架构是分层的，所以我们不需要知道底层的API，Hibernate利用数据库和配置数据向我们的应用程序提供持久性服务（和持久性对象）。 下图是Hibernate应用结构体系简要视图： 下图是Hibernate应用结构体系详细视图，包含了几个重要的核心类： Hibernate使用各种现有的Java API，如JDBC,JTA,JNDI。 JDBC提供了关系数据库通用的功能抽象层，所有具有JDBC驱动程序的数据库都被Hibernate支持。JTA和JNDI允许Hibernate与J2EE服务器集成。 Hibernate应用结构体系主要类对象Configuration ObjectConfiguration Object是我们在Hibernate应用程序中创建的第一个Hibernate对象，通常在应用程序初始化时且只创建一次。它是Hibernate所需要的配置和属性文件。Configuration对象提供两个关键组件： Database Connection:通过Hibernate支持的一个或多个配置文件来处理。hibernate.properties,hibernate.cfg.xml。 Class Mapping Setup:这个组件用于Java类和数据库表之间创建连接。 SessionFactory ObjectConfiguration Object用于创建一个SessionFactory Obejct，该对象使用提供的配置文件为应用程序配置Hibernate，并允许实例化一个Session对象。SessionFactory是线程安全对象,供应用程序的所有线程使用。 SessionFactory是重量级对象。因此通常在应用程序启动期间创建并保留供以后使用。 每个数据库都需要使用一个单独的配置文件创建一个SessionFactory对象。如果使用多个数据库，则必须创建多个SessionFactory对象。 Session(会话) ObjectSession（会话）用于获取与数据库的物理连接，Session对象是轻量级的，并且是每当需要与数据库进行交互时才会被实例化。持久化对象通过Session对象进行保存和检索。 Session对象不应该长时间保持打开，因为他们通常不是线程安全的，所以应该根据业务需求创建和销毁它们。 Transaction（事务） Object事务Transaction代表与数据库的工作单元，大多数关系型数据库都支持事务功能。Hibernate中的事务由底层事务管理器和事务（来自JDBC和JTA）处理。 这是一个可选对象，Hibernate应用程序可以选择不使用此接口，而选择在自己的应用程序代码中管理事务。 Query Object查询Query对象使用SQL或者Hibernate查询语言(Hibernate Query Language,HQL)字符串从数据库检索数据并创建对象。Query实例用于绑定查询参数，限制查询返回的结果数量，最后执行查询。 Criteria Object条件对象用于创建和执行面向对象的标准查询以检索对象。 Hibernate 环境配置该章主要介绍如何安装Hibernate以及其它相关包来为Hibernate应用程序准备一个开发环境。本文将使用Mysql数据库来演示Hibernate实例。 Hibernate下载 在windows上下载.zip文件，在Unix上下载.tz文件。 从http://www.hibernate.org/downloads下载最新版的Hibernate。 下载完成之后进行解压。 安装Hibernate下载完Hibernate之后，只需要执行以下两个简单的步骤即可。请确保正确的配置了CLASSPATH环境变量，否则在编译应用程序时会出现问题。 Hibernate的依赖包 S.N. Packages/Libraries 1 dom4j - XML parsing www.dom4j.org/ 2 Xalan - XSLT Processor http://xml.apache.org/xalan-j/ 3 Xerces - The Xerces Java Parser http://xml.apache.org/xerces-j/ 4 cglib - Appropriate changes to Java classes at runtime http://cglib.sourceforge.net/ 5 log4j - Logging Faremwork http://logging.apache.org/log4j 6 Commons - Logging, Email etc. http://jakarta.apache.org/commons 7 SLF4J - Logging Facade for Java http://www.slf4j.org Hibernate配置Hibernate需要提前知道在哪里可以找到定义的Java类和数据库表相关联的映射信息。Hibernate还需要一组与数据库和其它相关参数相关的配置设置。所有这些信息通常作为标准java属性文件hibernate.properties或者名为hibernate.cfg.xml的XML文件提供。 Hibernate属性以下是在独立情况下为一个数据库配置所需要的重要属性列表： S.N. Properties and Description 1 hibernate.dialect:此属性使Hibernate为选定的数据库生成适当的SQL 2 hibernate.connection.driver_class:JDBC驱动程序类 3 hibernate.connection.url:数据库实例的JDBC URL 4 hibernate.connection.username:数据库用户名 5 hibernate.connection.password:数据库密码 6 hibernate.connection.pool_size:限制在Hibernate数据库连接池中的等待连接数 7 hibernate.connection.autocommit:允许JDBC连接自动提交 如果随着应用服务器和JNDI使用同一个服务器，则还需要配置以下属性： S.N. Properties and Description 1 hibernate.connection.datasource:在应用服务器中定义的JNDI名称 2 hibernate.jndi.class:JNDI的InitialContext类 3 hibernate.jndi.&lt;JNDIpropertyname&gt;: 4 hibernate.jndi.url:提供JNDI的url 5 hibernate.connection.username:数据库用户名 6 hibernate.connection.password:数据库密码 Hibernate和Mysql数据库MySQL是目前最流行的开源数据库系统之一，下面我们创建一个hibernate.cfg.xml配置文件，并将其放置于应用程序类路径的根目录下，必须确保已经安装MySQL 并保证已经保证创建了可用的测试数据库。XML配置文件必须符合Hibernate 3 Configuration DTD，该文件可从http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd获得。1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-configuration SYSTEM "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name="hibernate.dialect"&gt; org.hibernate.dialect.MySQLDialect &lt;/property&gt; &lt;property name="hibernate.connection.driver_class"&gt; com.mysql.jdbc.Driver &lt;/property&gt; &lt;!-- Assume test is the database name --&gt; &lt;property name="hibernate.connection.url"&gt; jdbc:mysql://localhost/test &lt;/property&gt; &lt;property name="hibernate.connection.username"&gt; root &lt;/property&gt; &lt;property name="hibernate.connection.password"&gt; root123 &lt;/property&gt; &lt;!-- List of XML mapping files --&gt; &lt;mapping resource="Employee.hbm.xml"/&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 下表是各类数据库的属性类型(Dialect Property)列表： Database Dialect Property DB2 org.hibernate.dialect.DB2Dialect HSQLDB org.hibernate.dialect.HSQLDialect HypersonicSQL org.hibernate.dialect.HSQLDialect Informix org.hibernate.dialect.InformixDialect Ingres org.hibernate.dialect.IngresDialect Interbase org.hibernate.dialect.InterbaseDialect Microsoft SQL Server 2000 org.hibernate.dialect.SQLServerDialect Microsoft SQL Server 2005 org.hibernate.dialect.SQLServer2005Dialect Microsoft SQL Server 2008 org.hibernate.dialect.SQLServer2008Dialect MySQL org.hibernate.dialect.MySQLDialect Oracle (any version) org.hibernate.dialect.OracleDialect Oracle 11g org.hibernate.dialect.Oracle10gDialect Oracle 10g org.hibernate.dialect.Oracle10gDialect Oracle 9i org.hibernate.dialect.Oracle9iDialect PostgreSQL org.hibernate.dialect.PostgreSQLDialect Progress org.hibernate.dialect.ProgressDialect SAP DB org.hibernate.dialect.SAPDBDialect Sybase org.hibernate.dialect.SybaseDialect Sybase Anywhere org.hibernate.dialect.SybaseAnywhereDialect Hibernate实例创建POJO类 首先，我们创建Java POJO类，这取决于将被持久化到数据库的应用程序，生成getXXX()和setXXX()方法，使其成为JavaBeans兼容类。 POJO（java普通对象）是一种java对象，它不扩展或实现一些EJB框架分别需要的一些专门的类或接口。所有正常的Java对象都是POJO。 当你设计一个要被Hibernate持久化的类时，提供符合JavaBeans的代码以及一个在Employee类中像id属性一样用作索引的属性很重要。 12345678910111213141516171819202122232425262728293031323334353637public class Employee &#123; private int id; private String firstName; private String lastName; private int salary; public Employee() &#123;&#125; public Employee(String fname, String lname, int salary) &#123; this.firstName = fname; this.lastName = lname; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public void setId( int id ) &#123; this.id = id; &#125; public String getFirstName() &#123; return firstName; &#125; public void setFirstName( String first_name ) &#123; this.firstName = first_name; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName( String last_name ) &#123; this.lastName = last_name; &#125; public int getSalary() &#123; return salary; &#125; public void setSalary( int salary ) &#123; this.salary = salary; &#125;&#125; 创建数据库表第二步，我们需要在数据库中创建一张表，将表对应我们需要持久化的每一个对象，根据上面的java类我们创建下面这样一个表“ 1234567create table EMPLOYEE ( id INT NOT NULL auto_increment, first_name VARCHAR(20) default NULL, last_name VARCHAR(20) default NULL, salary INT default NULL, PRIMARY KEY (id)); 创建配置映射文件接下来我们需要创建一个配置文件，说明Hibernate如何将定义的类映射至数据库表。 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; &lt;hibernate-mapping&gt; &lt;class name="Employee" table="EMPLOYEE"&gt; &lt;meta attribute="class-description"&gt; This class contains the employee detail. &lt;/meta&gt; &lt;id name="id" type="int" column="id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="firstName" column="first_name" type="string"/&gt; &lt;property name="lastName" column="last_name" type="string"/&gt; &lt;property name="salary" column="salary" type="int"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 我们应该把映射文件保存为&lt;classname&gt;.hbm.xml格式的文件。上面文件保存为Employee.hbm.xml。 映射文件是一个XML格式的文档。&lt;hibernate-mapping&gt;作为包含所有&lt;class&gt;元素的根元素。 &lt;class&gt;元素用于定义从java类到数据库表的特定映射。java类名称使用使用类元素的name属性指定，并且使用table属性指定数据库表名称。 &lt;meta&gt;元素是可选元素，用于创建类描述。 &lt;id&gt;是将类中的唯一ID元素映射到数据库表的主键。id元素中的name属性引用类中的属性，cloumn属性引用数据库表中的列。type属性保存hibernate映射类型，此映射类型将从Java转换成SQL数据类型。 id元素中的&lt;generator&gt;属性用于自动生成主键值，设置class的属性值为native，让hibernate选择identity，sequence,hilo算法来创建主键，这取决于底层数据库的能力。 &lt;property&gt;元素用于将Java类属性映射到数据库表中的列。元素的name属性引用类中的属性，cloumn属性引用数据库表中的列。type属性保存hibernate映射类型，此映射类型将从Java类型转换成SQL数据类型。 创建应用类(java class)完成了以上步骤后，我们来创建一个应用文件来测试一下我们的配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import java.util.List; import java.util.Date;import java.util.Iterator; import org.hibernate.HibernateException; import org.hibernate.Session; import org.hibernate.Transaction;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class ManageEmployee &#123; private static SessionFactory factory; public static void main(String[] args) &#123; try&#123; factory = new Configuration().configure().buildSessionFactory(); &#125;catch (Throwable ex) &#123; System.err.println("Failed to create sessionFactory object." + ex); throw new ExceptionInInitializerError(ex); &#125; ManageEmployee ME = new ManageEmployee(); /* 添加一些employee对象到数据库表中*/ Integer empID1 = ME.addEmployee("Zara", "Ali", 1000); Integer empID2 = ME.addEmployee("Daisy", "Das", 5000); Integer empID3 = ME.addEmployee("John", "Paul", 10000); /* 列出所有employee对象 */ ME.listEmployees(); /* 修改 */ ME.updateEmployee(empID1, 5000); /* 从数据库中删除 */ ME.deleteEmployee(empID2); /* 列出所有对象s */ ME.listEmployees(); &#125; /* 向数据库中添加employee对象的方法 */ public Integer addEmployee(String fname, String lname, int salary)&#123; Session session = factory.openSession(); Transaction tx = null; Integer employeeID = null; try&#123; tx = session.beginTransaction(); Employee employee = new Employee(fname, lname, salary); employeeID = (Integer) session.save(employee); tx.commit(); &#125;catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125;finally &#123; session.close(); &#125; return employeeID; &#125; /* 列出所有employee对象的方法 */ public void listEmployees( )&#123; Session session = factory.openSession(); Transaction tx = null; try&#123; tx = session.beginTransaction(); List employees = session.createQuery("FROM Employee").list(); for (Iterator iterator = employees.iterator(); iterator.hasNext();)&#123; Employee employee = (Employee) iterator.next(); System.out.print("First Name: " + employee.getFirstName()); System.out.print(" Last Name: " + employee.getLastName()); System.out.println(" Salary: " + employee.getSalary()); &#125; tx.commit(); &#125;catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125;finally &#123; session.close(); &#125; &#125; /* 修改employee对象的方法 */ public void updateEmployee(Integer EmployeeID, int salary )&#123; Session session = factory.openSession(); Transaction tx = null; try&#123; tx = session.beginTransaction(); Employee employee = (Employee)session.get(Employee.class, EmployeeID); employee.setSalary( salary ); session.update(employee); tx.commit(); &#125;catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125;finally &#123; session.close(); &#125; &#125; /* 删除employee对象的方法 */ public void deleteEmployee(Integer EmployeeID)&#123; Session session = factory.openSession(); Transaction tx = null; try&#123; tx = session.beginTransaction(); Employee employee = (Employee)session.get(Employee.class, EmployeeID); session.delete(employee); tx.commit(); &#125;catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125;finally &#123; session.close(); &#125; &#125;&#125; 编译和执行编译和执行的步骤（请确保正确配置了环境变量）： 创建hibernate.cfg.xml配置文件。 创建Employee.hbm.xml映射文件。 创建Employee.java文件，并编译它。 创建如上所示的ManageEmployee.java文件，并执行编译。 执行ManageEmployee.class文件，运行程序。]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>ORM框架</tag>
        <tag>javaweb</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java解惑》读书笔记]]></title>
    <url>%2F%E3%80%8AJava%E8%A7%A3%E6%83%91%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[表达式之谜奇数性奇数：被2整除余1的数。表达式i%2是计算i除以2时所产生的余数。这个表达式其实是错误的。在所有的int数值中，有一半的值为负数，当值为负数时，无论该值为奇数还是偶数，结果都会返回false。123456789101112package com.hx.test;public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(isOdd(-5)); &#125; public static boolean isOdd(int i) &#123;// return i % 2 == 1; // 这个表达式是错误的。// return i % 2 != 0; // 正确 return (i &amp; 1) != 0; // 正确 &#125;&#125; 找零时刻1234567891011package com.hx.test;import java.math.BigDecimal;public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(2.00 - 1.10); // 输出结果0.8999999999999999 System.out.println((200-110)+"cents"); //输出结果 90 cents System.out.println(new BigDecimal("2.00").subtract(new BigDecimal("1.10"))); //输出结果0.9 &#125;&#125; 在需要使用精确数值的地方，要避免使用float和double，对于货币计算，要使用int,long,BigDecimal。 长整除123456789101112131415161718package com.hx.test;import java.math.BigDecimal;public class HelloWorld &#123; public static void main(String[] args) &#123; final long MICROS_PRE_DAY = 24*60*60*1000*1000; final long MILLS_PRE_DAY = 24*60*60*1000; //final long MICROS_PRE_DAY = 24L*60*60*1000*1000; //final long MILLS_PRE_DAY = 24L*60*60*1000; System.out.println(MICROS_PRE_DAY/MILLS_PRE_DAY); // 为什么结果会打印5？？？ // &#125;&#125; 当操作很大的数字时，千万要提防溢出。即便用来保存结果的变量足够大，也并不意味着要产生结果的计算具有正确的类型。当拿不准的时候，就使用long运算来执行整个计算。 十六进制的趣事123456789package com.hx.test;public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(Long.toHexString(0x100000000L + 0xcafebabe)); // cafebabe System.out.println(Long.toHexString(0x100000000L + 0xcafebabeL)); // 1cafebabe &#125;&#125; 混合类型的计算可能产生混淆，尤其需要注意的是十六进制和八进制字面常量无需显式的减号符号就可以表示负的数值，为了避免这种窘境，通常最好避免混合类型的计算。]]></content>
      <categories>
        <category>Java解惑</category>
      </categories>
      <tags>
        <tag>java解惑</tag>
        <tag>表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下的cmd神器:Cmder介绍及其设置]]></title>
    <url>%2Fwindows%E4%B8%8B%E7%9A%84cmd%E7%A5%9E%E5%99%A8-Cmder.html</url>
    <content type="text"><![CDATA[Cmder的安装cmder官网： http://cmder.net/Github：https://github.com/cmderdev/cmder 官网安装在官网上,我们可以看到Download模块，分为min版和full版，两者的区别在于：full版集成了msysgit工具，是Git for Windows的标准配置，除了git本身这个命令之外，里面还有大量的linux命令，比如 grep, curl(没有 wget)； 像vim, grep, tar, unzip, ssh, ls, bash, perl 对于爱折腾的Coder更是痛点需求。 将下载的压缩包解压到你想放置的目录。 点击Cmder.exe即可运行。 Cmder配置及相关设置乱码和文字重叠当我们使用ls命令查看文件目录时，发现，中文被显示成了一些奇怪的乱码，将以下几行代码配置在cmder/config/user-aliases下即可解决问题:1234l=ls --show-control-charsla=ls -aF --show-control-charsll=ls -alF --show-control-charsls=ls --show-control-chars -F 如果进行了以上配置还存在乱码问题时，还能尝试进行如下配置： 启动Cmder前文已经说过，Cmder无需安装，解压即可运行。Cmder点击Cmder.exe即可运行，显然，这样打开是非常不方便的，所以，我们可以进行如下配置： 将cmder添加入环境变量将cmder.exe所在的目录添加至系统环境变量。添加完之后，使用win+r输入cmder即可运行Cmder。右键点击我的电脑---&gt;属性,然后如下图所示进行配置即可： 添加cmser至右键菜单能不能将cmder添加到右键，让我们可以在任意文件目录下打开cmder呢？如果能这样使用那么简直是不能太赞了！！答案是完全可以的，因为在上一步骤我们已经将cmder加入了环境变量，所以我们只需要进行如下配置即可： 12// 以系统管理员权限打开cmd窗口，输入以下代码，回车即可。Cmder.exe /REGISTER ALL 默认开启设置作为强大的存在，必然支持私人定制。输入win + alt + p 或者 在底部右击点击 settings, 进入设置页面；可以根据自己的所需进行各种配置(字体，皮肤等等等等)。 目前游走在前端，Gulp已离不开，Cmder+PowerShell这个组合无疑是运行gulp的利器。如下图所示，可以设置PowerShell作为默认开启的选项；也可以更改默认开启是所在目录。 Cmder常用功能介绍Cmder功能非常强大，也有许多功能： Cmder常用快捷键 Tab：自动路径补全 ctrl+T:建立新页签 ctrl+W：关闭页签 ctrl+tab：切换页签 alt_f4:关闭所有页签 alt+shift+1:开启cmd.exe alt+shift+2:开启powershell.exe alt+shift+3:开启powershell.exe（系统管理员权限） ctrl+1:快速切换到第一个页签 ctrl+n:快速切换到第n个页签 alt+enter:切换到全屏状态 ctrl+r:历史命令搜索 可在视窗内搜寻画面上曾经出现过的任意字 新增页签按钮，可透过滑鼠新增页签 切换页签按钮，可透过滑鼠切换页签 锁定视窗，让视窗无法再输入 切换视窗是否提供卷轴功能，启动时可查询之前显示过的内容 按下滑鼠左键可开启系统菜单，滑鼠右键可开启工具选项视窗，win+alt+p开启工具选项视窗。 cmder元件组成Cmder集成了多套软体，其中最重要的是msysgit、ConEmu、Clink。 msysgit除了提供git for windows相关工具之外，还提供了多套Unix/linux环境下常用的指令工具，例如：less、ls、tar、grep等。 ConEmu体验不如cmder Clink将GNU Readline 函式库整合进原生的Windows 命令提示字元视窗，提供命令列模式下强大的编辑与输入能力，这也是用了cmder 之后会这么像在Linux 环境下使用的感觉。 Chocolatey软件包管理系统在 Linux 下，大家喜欢用apt-get(mac下用brew)来安装应用程序，如今在 windows 下，大家可以使用Chocolatey来快速下载搭建一个开发环境。Chocolatey的哲学就是完全用命令行来安装应用程序， 它更像一个包管理工具（背后使用Nuget）另外需要说明的是，Chocolatey只是把官方下载路径封装到了Chocolatey中，所以下载源都是其官方路径，所以下载的一定是合法的，但是如果原软件是需要 Licence 注册的话，那么Chocolatey下载安装好的软件还是需要你去购买注册。不过Chocolatey一般还是会选用免费 Licence 可用的软件。 安装chocolatey , 运行如下命令即可：1@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin 安装软件命令choco install softwareName, 短写是cinst softwareName可安装的应用程序，可以参见其 Package列表以下是window下开发常用的开发环境应用:123456789101112choco install autohotkey.portable #安装 AutoHotkey (Portable)choco install nodejs.install #安装 nodechoco install git.install #安装 gitchoco install ruby #安装 rubychoco install python #安装 pythonchoco install jdk8 #安装 JDK8choco install googlechrome #安装 Chromechoco install google-chrome-x64 #Google Chrome (64-bit only)choco install firefox #安装 firefoxchoco install notepadplusplus.install #安装 notepad++choco install Atom #安装 Atomchoco install SublimeText3 #安装 SublimeText3 其他功能 Cmder还增加了alias功能;他让你用短短的指令执行一些常见但指令超长又难以记忆的语法;比如 ls cls等等；在其控制台输入alias可以查看。 主控台文字自动放大缩小功能，你只要按下Ctrl+滑鼠滚轮就可以办到;果你用支援两点触控的笔电，也可以在触控板上用两指放大的手势调整文字大小。还有：up，向上翻历史命令; Cmder有极为简单的复制粘贴操作。Ctr+V直接粘贴;用鼠标选中你想拷贝的内容，自动就复制到剪切板；天神，这悉数的美感;点赞! 自定义aliases:打开Cmder目录下的config文件夹，里面的aliases文件就是我们可以配置的别名文件，只需将里面ls命令的别名按下列方式修改就可以在ls命令下显示中文。]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>cmder</tag>
        <tag>cmd.linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下jdk环境变量的配置]]></title>
    <url>%2Fubuntu%E4%B8%8Bjdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[Linux下jdk环境变量的配置PS:博主的系统版本是 ubuntu kylin 15.10。 下载、及安装 下载:http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 下载完成之后就是解压了： 进入到文件目录下执行该指令sudo tar zxvf ./jdk-8u65-linux-x64.tar.gz 安装完成之后就是配置环境变量啦2.1 打开/etc/profile文件：sudo gedit /etc/profile2.2 添加如下环境变量123456789#set java environment export JAVA_HOME=/usr/local/java/jdk版本 export JRE_HOME=/usr/local/java/jdk版本/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH 2.3 使得修改生效：一种是使用重启的方式使得修改生效，另一种则是使用source /etc/profile也可以使修改生效。 输入java -version测试是否配置成功。3.1 出现以下代码表示配置成功： 1234lucas@lucas-ThinkPad-PC:~/java$ java -versionjava version &quot;1.8.0_65&quot;Java(TM) SE Runtime Environment (build 1.8.0_65-b17)Java HotSpot(TM) 64-Bit Server VM (build 25.65-b01, mixed mode) 3.2 如出现如下代码：1234567程序 &apos;java&apos; 已包含在下列软件包中： * default-jre * gcj-4.6-jre-headless * gcj-4.7-jre-headless * openjdk-7-jre-headless * openjdk-6-jre-headless请尝试：sudo apt-get install &lt;选定的软件包&gt; 则可以通过以下方式来解决： 在终端输入如下命令：1234// 这里是输入你的jdk安装目录以及版本号，具体的根据自己的设置去配。sudo update-alternatives --install /usr/bin/java java /home/lester/develop/jdk1.6.0_37/bin/java 300sudo update-alternatives --install /usr/bin/javac javac /home/lester/develop/jdk1.6.0_37/bin/javac 300 在配置完以上信息之后，再去java -version 进行测试。就能看到成功配置的信息啦！～ 好了，初次接触linux下的开发，确实会遇到许多的问题，博主会将这些常见的问题一一记录下来，以便自己查看，也为了让其他和我一样刚入门的新手一些参考。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>java环境变量</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下Apache2服务器的搭建]]></title>
    <url>%2FUbuntu%E4%B8%8BApache2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[Apache服务器的下载与安装博主选择的是使用apt-get开发包打包的方式安装的。下面是安装步骤： 安装apache，在命令行终端中输入以下命令： 1$ sudo apt-get install apache2 如果网络连接正常的话，应该是会顺利安装好的，在安装完成之后，需要重启apache服务，在命令行终端中输入如下命令： 1234$ sudo /etc/init.d/apache2 restart``` &gt; 如果重启之后出现如下提示，则表示服务器已经启动成功了。 lucas@lucas-ThinkPad-PC:~$ sudo /etc/init.d/apache2 restart[ ok ] Restarting apache2 (via systemctl): apache2.service.``` 可能出现的问题1： NameVirtualHost * :80 has no VirtualHost. 出现上述问题的原因：定义了多个NameVirtualHost，我们只需要将/etc/apahce2/ports.conf 中的NameVirtualHost * :80注释掉即可。 可能出现的问题2： Could not reliably determine the server’s fully qualified domain name, using 127.0.1.1 for ServerName 原因：根据提示，无法可靠的确定服务器的有效域名，使用127.0.1.1作为服务器域名。因此在下面的测试中，应该使用127.0.1.1，而不是127.0.0.1。 解决方法：终端输入vim /etc/apache2/httpd.conf，在文件中添加ServerName localhost:80 ，再次restart apache2,就可以使用127.0.0.1来访问web服务器了。 Apache服务器的测试既然已经安装好了，name我们当然应该测试一下了。 在浏览器中输入http://localhost或者http://127.0.0.1，如果看到了It works，那么就说明服务器成功安装了。Apache的默认安装，会在var/www/的目录，这个就是我们的web目录了，所有需要能够浏览器访问的web文件都要放在这个目录里。 下面是楼主的测试结果： PS:好了。至此Ubuntu下Apache服务器的安装就已经完成，下面的文章中，我将继续Apache服务器配置文件的详解。]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>Apache2</tag>
        <tag>服务器</tag>
        <tag>ubuntu</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bower:Additional error details:Name must be lowercase, can contain digits, dots, dashes, "@" or spaces]]></title>
    <url>%2Fbower%20error.html</url>
    <content type="text"><![CDATA[在运行bower install安装第三方JS的时候，遇到以下错误提示： 12345E:\nginx-1.10.2\html\parkhero2.0\master&gt;bower installbower EINVALID Failed to read E:\nginx-1.10.2\html\parkhero2.0\master\bower.jsonAdditional error details:Name must be lowercase, can contain digits, dots, dashes, "@" or spaces 看到这个错误有点懵比，因为一直是可以正常运行的，突然遇到这个错误，然后去检查了一下bower.json文件，发现错误的原因是：12"name": "Park", // 错误就在这里，上面提示了name必须小写，可以包含数字、点、破折号、@和空格"version": "2.0.0", 好吧，至此问题就解决了。12&quot;name&quot;: &quot;park&quot;, // 改成小写&quot;version&quot;: &quot;2.0.0&quot;, 修改完之后运行bower install,正常运行了。这是个小错误，记录一下。]]></content>
      <categories>
        <category>错误收集</category>
      </categories>
      <tags>
        <tag>Bower</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Crypto-JS进行加密，以及使用angular的方式进行封装调用]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Crypto-JS%E8%BF%9B%E8%A1%8CAES%E5%8A%A0%E5%AF%86.html</url>
    <content type="text"><![CDATA[## 使用Crypto-JS进行AES加密 在最近的项目中，调用登录接口，需要对账号密码数据进行AES加密后再进行传输，使用的是AES/ECB/PKCS5Padding,我前端部分使用选择了CryptoJS,现在把使用的过程记录如下。 需要注意的点 Crypto-JS的encrypt函数不会返回字符串，需要调用对象的toString方法，或者通过Crypto-js转码才能得到真实的结果。 使用步骤 引入Crypto-JS中的 aes.js及相关模块 1234&quot;bower_components/cryptojs/aes.js&quot;,&quot;bower_components/cryptojs/enc-utf8.js&quot;,&quot;bower_components/cryptojs/pad-pkcs7.js&quot;,&quot;bower_components/cryptojs/mode-ecb.js&quot; 调用CryptoJS.AES 12345678910111213141516// 官方示例, 每次输出的密文都不一样,这样使用的话是错误的CryptoJS.AES.encrypt("Message", "Secret Passphrase");/* 正确的使用姿势！！ */// 使用用户名进行MD5，32位，作为keyvar key_str = md5.createHash(username);// 将key转换成128 bitvar key = CryptoJS.enc.Utf8.parse(key_str);// 对password进行AES加密var AESPass = CryptoJS.AES.encrypt(password, key, &#123; mode: CryptoJS.mode.ECB, //补齐方式 CBC,ECB,etc. padding: CryptoJS.pad.Pkcs7 // 偏移规则设定 pack5，pkcs7，nopadding,etc.&#125;);// CryptoJS 的 encrypt函数不会直接返回字符串，需要toString或者Crypto-JS进行转码才能得到真实的结果。var pass = AESPass.toString();var authData = Base64.encode(username + ':' + pass).replace(/[\r\n]/g, ''); // 去除回车换行符 使用AngularJS的方式调用CryptoJS.AES 使用Angular将AES封装成一个provider 提供两种方式设置key 12345// 1. 一种为在angular.module('xxxx').config中进行设置，此种方式适用于key为一个固定值的情况 CryptoKeyProvider.setCryptofraphyKey('key') // 在config中设置key $crypto.encrypto('plaintext') // 在业务逻辑处直接传入需要加密的明文进行调用// 2. 第二种方式,每次都设置不同的key $crypto.encrypto('plaintext','key') 具体源码如下： 注意：解密时，需要先将密文转换成Base64的编码的格式。 使用CryptoJS.enc.Hex.parse转换成十六进制 使用CryptoJS.enc.Base64.stringify将其变成Base64编码的字符串 最后才能传入CryptoJS.AES.decrypt方法对其解密]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>AES</tag>
        <tag>Web开发</tag>
        <tag>CryptoJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基本常识]]></title>
    <url>%2Fpython%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86.html</url>
    <content type="text"><![CDATA[Python的语法格式Python是一种计算机编程语言，有着自己的一套语法格式。Python的语法格式非常简单，采用缩进的方式：123456# print absolute value of an integer:a = 100if a &gt;= 0: print(a)else: print(-a) 以#开头的语句是注释，解释器会自动忽略。 当语句以：结束时，缩进的语句视为代码块。 缩进有利有弊，好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是tab。按照约定俗成的习惯，应该使用4个空格的缩进。缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把很长的一段代码拆分成若干函数，从而得到缩进较少的代码。缩进的坏处就是“复制-粘贴”功能失效了，当我们重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像Java代码那样格式化Python代码。 Python程序是大小写敏感的，如果写错了大小写，程序会报错。 Python的数据类型在Python中，能够直接处理的数据类型有以下几种： 整数Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 浮点数浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。 字符串字符串是以单引号’或双引号”括起来的任意文本，比如&#39;abc&#39;，&quot;xyz&quot;等等。请注意，&#39;&#39;或&quot;&quot;本身只是一种表示方式，不是字符串的一部分，因此，字符串&#39;abc&#39;只有a，b，c这3个字符。如果&#39;本身也是一个字符，那就可以用&quot;&quot;括起来，比如&quot;I&#39;m OK&quot;包含的字符是I，&#39;，m，空格，O，K这6个字符。 如果字符串内部既包含&#39;又包含”怎么办？可以用转义字符\来标识，比如：1'I\'m \"OK\"!' 表示的字符串内容是：1I'm "OK"! 转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：12345678&gt;&gt;&gt; print('I\'m ok.')I'm ok.&gt;&gt;&gt; print('I\'m learning\nPython.')I'm learningPython.&gt;&gt;&gt; print('\\\n\\')\\ 如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r&#39;&#39;表示&#39;&#39;内部的字符串默认不转义，可以自己试试：1234&gt;&gt;&gt; print('\\\t\\')\ \&gt;&gt;&gt; print(r'\\\t\\')\\\t\\ 如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&#39;&#39;&#39;...&#39;&#39;&#39;的格式表示多行内容，可以自己试试：123456&gt;&gt;&gt; print('''line1... line2... line3''')line1line2line3 上面是在交互式命令行内输入，注意在输入多行内容时，提示符由&gt;&gt;&gt;变为...，提示你可以接着上一行输入。如果写成程序，就是：123print('''line1line2line3''') 多行字符串&#39;&#39;&#39;...&#39;&#39;&#39;还可以在前面加上r使用，请自行测试。 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：12345678&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse&gt;&gt;&gt; 3 &gt; 2True&gt;&gt;&gt; 3 &gt; 5False 布尔值可以用and、or和not运算。 and运算是与运算，只有所有都为True，and运算结果才是True：12345678&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; False and FalseFalse&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1True or运算是或运算，只要其中有一个为True，or运算结果就是True：12345678&gt;&gt;&gt; True or TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; False or FalseFalse&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3True not运算是非运算，它是一个单目运算符，把True变成False，False变成True：123456&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not FalseTrue&gt;&gt;&gt; not 1 &gt; 2True 布尔值经常用在条件判断中，比如：1234if age &gt;= 18: print('adult')else: print('teenager') 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。 变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：1a = 1 变量a是一个整数。1t_007 = &apos;T007&apos; 变量t_007是一个字符串。1Answer = True 变量Answer是一个布尔值True。 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：1234a = 123 # a是整数print(a)a = &apos;ABC&apos; # a变为字符串print(a) 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：12int a = 123; // a是整数类型变量a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量 和静态语言相比，动态语言更灵活，就是这个原因。 请不要把赋值语句的等号等同于数学的等号。比如下面的代码：12x = 10x = x + 2 如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。 最后，理解变量在计算机内存中的表示也非常重要。当我们写：1a = &apos;ABC&apos; 时，Python解释器干了两件事情： 在内存中创建了一个’ABC’的字符串； 在内存中创建了一个名为a的变量，并把它指向’ABC’。 也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：1234a = &apos;ABC&apos;b = aa = &apos;XYZ&apos;print(b) 常量所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：1PI = 3.14159265359 但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。 最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：12&gt;&gt;&gt; 10 / 33.3333333333333335 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：12&gt;&gt;&gt; 9 / 33.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数：12&gt;&gt;&gt; 10 // 33 你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。 因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：12&gt;&gt;&gt; 10 % 31 无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。 字符串和编码在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：12&gt;&gt;&gt; print(&apos;包含中文的str&apos;)包含中文的str 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：12345678&gt;&gt;&gt; ord(&apos;A&apos;)65&gt;&gt;&gt; ord(&apos;中&apos;)20013&gt;&gt;&gt; chr(66)&apos;B&apos;&gt;&gt;&gt; chr(25991)&apos;文&apos; 如果知道字符的整数编码，还可以用十六进制这么写str：12&gt;&gt;&gt; &apos;\u4e2d\u6587&apos;&apos;中文&apos; 两种写法完全是等价的。 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示：1x = b&apos;ABC&apos; 要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：12345678&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)b&apos;ABC&apos;&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。 在bytes中，无法显示为ASCII字符的字节，用\x##显示。 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：1234&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)&apos;ABC&apos;&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)&apos;中文&apos; 要计算str包含多少个字符，可以用len()函数：1234&gt;&gt;&gt; len(&apos;ABC&apos;)3&gt;&gt;&gt; len(&apos;中文&apos;)2 len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：123456&gt;&gt;&gt; len(b&apos;ABC&apos;)3&gt;&gt;&gt; len(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)6&gt;&gt;&gt; len(&apos;中文&apos;.encode(&apos;utf-8&apos;))6 可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。 在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码.如果.py文件本身使用UTF-8编码，并且也申明了# -- coding: utf-8 --，打开命令提示符测试就可以正常显示中文。 ##格式化 最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似’亲爱的xxx你好！你xx月的话费是xx，余额是xx’之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。1py-str-format 在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：1234&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;&apos;Hello, world&apos;&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)&apos;Hi, Michael, you have $1000000.&apos; 你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。 常见的占位符有：1234%d 整数%f 浮点数%s 字符串%x 十六进制整数 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：1234&gt;&gt;&gt; &apos;%2d-%02d&apos; % (3, 1)&apos; 3-01&apos;&gt;&gt;&gt; &apos;%.2f&apos; % 3.1415926&apos;3.14&apos; 如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：12&gt;&gt;&gt; &apos;Age: %s. Gender: %s&apos; % (25, True)&apos;Age: 25. Gender: True&apos; 有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：12&gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7&apos;growth rate: 7 %&apos;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java概述]]></title>
    <url>%2Fjava%E6%A6%82%E8%BF%B0.html</url>
    <content type="text"><![CDATA[Java语言概述Java是由sun公司推出的java面向对象程序设计语言和java平台的的总称。由James Gosling和同事们共同研发，于1995年正式推出。java最初称为Oak，1995年更名。其特点是：面向对象、通用性、高效性、安全性、跨平台。随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。 java语言的发展java自从1996年发布1.0版本起，经过近20年的发展，于2014年已发布了java 8版本。 java语言的三个版本java语言共有三个版本： javase（J2SE，Java2 Platform Standard Edition，标准版）：是在java基础阶段主要学习的内容，包含了构成java语言核心的类，比如：数据库连接、接口定义、输入/输出、网络编程等。 javaee（J2EE，Java 2 Platform, Enterprise Edition，企业版）：用于服务端处理的企业版。该技术体系中包含的技术如Servlet Jsp等，主要针对于Web应用程序开发。 javame（J2ME，Java 2 Platform Micro Edition，微型版）：用于手机等嵌入式设备的“微型版”。其中，Javame目前使用较少，市场上的大多数为android系统和ios系统的手机，都有自己的开发工具来完成软件的开发。 Java程序设计环境Java虚拟机(JVM) JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 JVM是java的核心和基础，在java编译器和os平台之间的虚拟处理器，它是一种基于下层的操作系统和硬件平台并利用软件方法来实现的抽象计算机，可在上面执行java的字节码程序。 JVM是java实现跨平台性的一个关键，JVM本身并不能跨平台，正是由于JVM在不同的操作系统上有着不同的版本，使得java程序可以“一次编译，反复运行”。 Java开发环境的搭建 JDK和JRE JDK(Java development kit):java开发工具包，其中包含了JRE和java开发工具。安装了JDK之后就能运行Java程序。 JRE(Java runtime environment):java运行环境。其中包含了JVM和核心类库，如果只是单独的运行java程序，安装JRE即可。 JDK的下载与安装 JDK开发工具箱的下载，可以到Oracle网站，地址是www.oracle.com/technetwork/javajavase/downloads，根据自己电脑的操作系统选择Windows、Linux、Mac OS X等相对应的版本。 环境变量的配置在完成了JDK的安装之后，我们还需要进行环境变量的配置：即将jdk/bin目录添加到执行路径中，在bin目录下存放着一些可执行程序，如javac，java，javadoc等。配置环境变量的详细过程： 首先，右击【我的电脑】—【属性】—–【高级】—【环境变量】，如图： 将你jdk/bin目录加入进path中，以分号结束，但为了以后避免jdk重新安装时又要重新配置变量，我们可以在环境变量中新建一个名为%JAVA_HOME%的变量，变量值为jdk安装目录，再将%JAVA_HOME%/BIN加入到path中，如图： 测试环境变量是否配置成功，在DOS命令行下输入“javac”，输出帮助信息即为配置正确。如图： 下面提供一下临时配置环境变量的方法：当我们需要用别人的电脑进行开发，不能对别人电脑的环境变量进行随意更改时，我们可以使用临时配置的方式。临时的配置方式需要用到DOS命令行中的set命令，例如set path=” D:\Program Files\Java\jdk1.6.0_18\bin”就可以把配置临时的path变量，但是当我们再重新开启一个命令提示符窗口，该path就失去了效果。classpath也是相同的道理。 java程序编译运行方法 使用命令行方式java程序的编译和运行可以通过dos命令行的方式： 打开一个dos命令行窗口，可通过“win+R”的快捷键组合输入“cmd”的方式打开。 进入到java文件保存的目录。 执行javac文件名.java，对.java文件进行编译，生成.clss文件。 执行java文件名，即可执行该java程序。 下面用一个小程序做一个示范： 12345public class HelloWorld&#123; public static void main(String []args)&#123; System.out.println("HelloWorld"); &#125;&#125; 编译运行结果如图所示：下面是一些dos命令行常用的命令： dir：列出当前文件夹目录md：创建文件夹rd：删除文件夹（必须保证文件夹是空的）cd：进入文件目录cd..：退回到上一级目录cd/：退回到根目录del：删除文件exit：退出dos命令行 使用集成开发工具 我们还可以通过使用java集成工具来进行java程序的开发，这里主要介绍的是如和使用Eclipse编译运行一个程序。Eclipse可以从网站http://eclipse.org上免费下载。使用eclipse的步骤如下： 启动eclipse，从菜单栏选择File—&gt;New—&gt;Java Project，打开新建的这个文件，在其中右键new—&gt;class文件。进行java文件的编写编写完java文件之后，右键Run–&gt;Run As–&gt;Java Application即可。 Java中的注释 注释的作用: 1.注解，说明解释我们的程序，提高代码的阅读性 2.调试程序。当程序出现错误时，通过注释可以方便的查找出错的地方。 注释的类型：单行注释、多行注释和文档注释三种。 单行注释：//注释文字 多行注释：/注释文字（可多行）/ ，多行注释中不能嵌套多行注释 文档注释：/*注释内容/，是Java特有的注释，通常书写在类、域、构造函数、方法、定义之前。注释内容可以被JDK中的工具javadoc.exe所解析，生成一套以网页文件形式体现的该程序分说明文档。 格式如图所示：]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础,java,java概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基本语法(上)]]></title>
    <url>%2Fjava%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[java语言基础构成java的基础由关键字、标识符、注释、常量和变量、运算符、语句、函数、数组构成。 java关键字和保留字关键字定义：被java语言赋予了特殊涵义的单词。特点：关键字中所有字母均为小写。 关键字共有50个，分为以下类型，都有其特殊含义。 用于定义数据类型的关键字 用于定义流程控制的关键字 用于定义访问权限修饰符的关键字 用于定义类、函数、变量修饰符的关键字 用于定义类与类之间关系的关键字 用于建立实例及引用实例、判断实例的关键字 用于异常处理的关键字 用于包的关键字 其它修饰符关键字 保留字const，goto java中的常量和变量常量常量：表示不能改变的值。 java中常量的分类 整数常量：所有整数 小数常量：所有小数 布尔型常量：较为特有，只有两个数值，true和false 字符常量：将一个数字或字符使用单引号&#39;&#39;标识 字符串常量：将一个或多个字符使用双引号&quot;&quot;标识 null常量：只有一个数值，null 对于整数，java有三种表现形式 二进制：0和1表示，满2进1 十进制：0~9,满10进1 八进制：0~7，满8进1 十六进制：0~9，A~F，满16进1，开头用0x表示 计算机采用二进制的原因 技术实现简单，计算机由逻辑电路组成，逻辑电路通常只有两个状态，开关的接通与断开，这两种状态正好可以使用0和1来表示。 简化运算规则，两个二进制数和、积运算组合各有三种，运算规则简单，有利于简化计算机内部结构，提高运算速度。 适合逻辑运算，逻辑代数是逻辑运算的理论依据，二进制只有两个数码，正好与逻辑代数的”真”和”假”相吻合。 易于进行转换，二进制与十进制数易于相互转换。 用二进制表示数据具有抗干扰能力强，可靠性高等优点。因为每位数据只有高低两个状态，当受到一定程度的干扰时，仍能可靠的分辨出它是高是低。 变量java中的运算符标识符定义：在java语言中，对于变量、常量、函数、语句块也有名字，我们通通称之为标识符。标识符是用来给类、对象、方法、]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基本语法</tag>
        <tag>java运算符</tag>
      </tags>
  </entry>
</search>
