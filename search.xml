<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2017年GitHub上新增的值得学习的Python开源库]]></title>
    <url>%2F2017%E5%B9%B4GitHub%E4%B8%8A%E6%96%B0%E5%A2%9E%E7%9A%84%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0%E7%9A%84Python%E5%BC%80%E6%BA%90%E5%BA%93.html</url>
    <content type="text"><![CDATA[截止到目前为止，在GitHub上当我们以Python为关键字进行搜索时，发现有者60+W的相关搜索结果，近年来，Python越来越热门，在GitHub上的开源项目也井喷式的发展，那么在众多的开源项目中，哪些非常优秀的项目是非常值得我们去学习的呢？下面就为大家来介绍在GitHub上非常热门的开源项目。 Home AssistantHome Assistant是一个开源的家庭智能控制系统，它有着非常友好的基于Web的可自定义UI，可以连接灯、开关、音响设备、安放设备等，可以集中管理并追踪他们的状态。可以在一个界面上控制来自于不同厂家的不同智能设备，并且这些行为都是可以自定义的，让智能化的家庭有着更多的可能性。目前在美国市场上的大多数智能设备都兼容HomeAssostant。 1Github地址：https://github.com/home-assistant/home-assistant Pytorch Pytorch是Facebook针对机器学习和科学基础上发布的一个机器学习工具包，具有高度的灵活性，前身是使用lua语言编写的torch，主要提供了以下两个功能： 具备强GPU加速的张力计算（比如numpy）。 建立在基于磁带的自动调整基础上的深层神经网络。 1Github地址：https://github.com/pytorch/pytorch Grumpy grumpy是Google开源的一个使用Go开发的Python运行时，它将Python代码编译成Go代码，然后将其编译成本地文件，而不是字节码文件，grumpy是没有虚拟机（vm）的。编译后的Go代码是对grumpy的一系列调用。在Google公司里，运行并维护着大量的Python代码，比如Youtube的前端服务器和API就大多是使用Python编写的，这种巨型应用需要大量的工作来优化它的运行时，而Cpython中，GLI的存在，制约来Python的并发能力。grumpy就由此应运而生了。感兴趣的朋友可以复制下面的github链接去详细了解一下。 1GitHub地址：https://github.com/google/grumpy Sanic sanic是一个基于Python 3.5+的一个web框架，与flask类似。特点就如上图中的“gotta to fast”说的那样，就是一个字：快。相对与flask，它使用async/await愈发编写，使用异步特性，所以它的速度有时非常明显，但由于它出现但时间还不够长，issues还不够多，所以建议新手刚上手Python的话，还是先使用flask，解决方案比较完善。但是sanic在可遇见的未来，必定会成为一个主流框架，有必要进行学习。 1GitHub地址：https://github.com/channelcat/sanic Python-fire python-fire是谷歌开源的一个能够将任何的python代码自动生成命令行界面（CLI）的一个工具。 Python Fire是Python中创建CLI的一个非常简单的方法。 Python Fire是开发和调试Python代码一个非常有用的工具。 Python Fire有助于我们探索现有代码或者将其他人的代码转换成CLI。 Python Fire使Bash和Dash之间的转换变得更加容易。 Python Fire通过使用您需要导入和创建的的模版和变量设置REPL，使得Python REPL更加容易使用。 通过使用这个开源库，不但可以生成CLI，并且可以用来调试我们的Python程序。更多的作用，可以自行去发掘。 1GitHub地址：https://github.com/google/python-fire spaCy spacy是一个Python自然语言处理工具包。它建立于最新的研究基础之上，从诞生之初就用来解决实际问题，用于实际产品。spacy带有预先训练的统计模型和单词向量，目前支持20多种语言的标记，它具有世界上最快的句法分析器，用于标签的神经网络模型。如今人工智能概念非常火热，而自然语言的处理是人工智能的主要领域之一，而spacy是自然语言处理（NLP）中一个非常强大的工具包，所以对于想进入人工智能领域的童鞋们来说，这个开源库非常有必要学习。 1GitHub地址：https://github.com/explosion/spaCy Pipenv pipenv是Python官方正式推荐的Python打包工具。它可以帮助我们在不建立虚拟环境的情况下非常方便的安装和管理依赖，为我们的项目自动的创建和管理一个虚拟环境。有了它之后： 不需要再单独使用pip和virtualenv去创建虚拟环境，pipenv帮你创建，并且它们将一起工作。 管理一个requirements.txt文件可能会产生问题，pipenv使用Pipfile和Pipfile.lock代替了requirements.txt，更加适用。 使用hash，非常安全，可以自动曝光安全漏洞。 让我们清晰明了的了解依赖图（$pipenv图）。 通过加载.env文件简化开发流程。 有了上述一大堆优点，还等什么？赶紧复制下方的链接开始宅起来学吧！ 1GitHub地址：https://github.com/pypa/pipenv MicroPython micropython是微型控制器和受控制系统精简高效的Python实现。通过micropython，我们完全可以通过Python语言来实现对硬件底层的访问可控制，就如图片所示的一样。目前该项目还在测试阶段，完整的实现来Python3.4的语法。感兴趣的同学可以通过下面的链接去了解。 1GitHub地址：https://github.com/micropython/micropython Prophet profhet是由Facebook Core Data Science team发布的开源软件，可以在CRAN和PYPI上下载。该框架可以使开发人员专注于金融策略模型、项目组合管理和分析上。对金融领域内的数据进行科学性的预测分析，对趋势、粒度等进行预测。profhet对于丢失的数据、趋势的转变、和大量的异常值具有强大的预测分析功能。 1GitHub地址：https://github.com/facebook/prophet SerpentAI serpentAI是一个简单却又非常强大的开源软件，可以帮助开发人员创建游戏代理。将所有的游戏视频转换成适合实验的沙盒环境。该工具对机器学习和人工智能具有非常强大的作用。 serpentAI有着大量的支持模块，为使用视频游戏的环境以及使用CLI加速开发时常见的开发场景提供解决方案。 serpentAI的设计是完全基于插件的。可以方便共享给他人。 1GitHub地址：https://github.com/SerpentAI/SerpentAI Dash 在Dash的项目主页上，有一句这样的介绍：“Dash is a Python framework for building analytical web applications. No JavaScript required.”是plotly在GitHub发布的一个企业级解决方案和开源工具。它基于flask、plotly.js、React.js构建。通过它可以非常简单的构建一个强大的交互式仪表板。 1GitHub地址：https://github.com/plotly/dash Apistar apistar是一个专门为Python3开发的一个web api框架： API文档——交互式API文档，始终与代码库保持同步。 客户端库——由API Star生成的类型系统驱动的Javascript和Python客户端库。 生成模式——支持生成Swagge或RAML API类型系统。 表达式——类型注释视图，代码可测试。 性能——确定如何运行每个视图的动态行为使得API Star非常的高效。 吞吐量——支持asyncio，允许构建高吞吐量的非阻塞应用程序。 1GitHub地址：https://github.com/encode/apistar Faiss faiss是密集向量的高效相似搜索和聚合类的库。它包含搜索任意大小的向量集的算法，还包含评估和参数调整的的支持代码。由Facebook开源。用于解决在用户日常搜索过程中所返回的网站拥有完全一样或者相似度过高的内容，应用类相似性搜索的相似引擎可以为用户返回最合适的结果，并且隐藏或者丢弃那些相同的结果。 1GitHub地址：https://github.com/facebookresearch/faiss Better-exceptions Better-exceptions是GitHub上一个Python中自动提示异常的一个非常漂亮和有用的开源小工具。非常简单实用。如图所示，使用之后代码的错误提示是不是看起来非常漂亮呢？喜欢的话就赶紧复制下面的链接安装试试吧。 1GitHub地址：https://github.com/Qix-/better-exceptions Flashtext flashtext是一个基于FlashText算法，用于替换句子中的关键词或者从句子中提取关键字的一个开源库。 1GitHub地址：https://github.com/vi3k6i5/flashtext Maya maya是一款Python的时间日期的开源库。在Python中，使用时间日期让人感到非常的沮丧，特别在处理不同操作系统上的不同环境语言的实惠。这个开源库就是为了解决这个问题。 maya大多是围绕解析来自网站日期数据，所有时区代数在所有机器上的行为是相同的，不管系统区域设置如何。 1GitHub地址：https://github.com/kennethreitz/maya Tangent tangent是谷歌开源的一个免费的用于自动分化的Python库。现有的库通过跟踪程序的执行或者通过分段动态数据流图然后区分图来实现自动分化，而tangent在Python源代码本身上执行提前autodiff，并生成Python源代码作为其输出，正好填补来机器学习工具空间中的独特位置。 tangent可以在Python庞大且不断增长的子集上工作，提供其他Python ML库没有的额外的autodiff特性，具有合理的性能，并且与TensorFlow和NumPy兼容。 tangent当前还只是一个实验版本，还在持续构建开发当中。有兴趣的可以通过下方的链接进去学习并反馈意见。 1GitHub地址：https://github.com/google/tangent 好了，关于Python 2017年值得关注和学习的开源库今天就给大家分享总结到这里。其实我只是在github上搜集了一部分，在github上还有许许多多的优秀库值得我们去学习和探索。最后，生命不止，编程不息！为自己加油。 注明：本文首发于今日头【https://www.toutiao.com/i6513690243382641166/】。作者：新农民的编程生涯]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>GitHub</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python真的比其他语言慢吗]]></title>
    <url>%2FPython%E7%9C%9F%E7%9A%84%E6%AF%94%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E6%85%A2%E5%90%97.html</url>
    <content type="text"><![CDATA[为什么Python会比其它语言慢？Python是动态类型语言而不是静态类型语言。这意味着在程序执行的时候，解释器不知道被定义的变量的类型。下图总结了一个C变量（我使用C作为编译语言的替代品）和一个Python变量之间的区别： 1234/* c代码实例 */int a =1; // 将整型数1赋值给aint b = 2; // 将整型数2赋值给bint c = a + b; // 调用binary_add&lt;int,int&gt;(a,b)，并将结果分配给c C编译器一开始就知道a和b是整数，直接调用两个整数添加的方法，返回C这个整数存到内存当中。整个代码就运行 完毕了。 1234# python代码实例a = 1b = 2c = a + b 如上代码所示，Python运行完上述代码需要经过以下几个步骤： 将1分配给a：设置a的a-&gt;PyObject_HEAD-&gt;typecode为整型，然后设置a的值为1。 将2分配给b：设置b的b-&gt;PyObject_HEAD-&gt;typecode为整型，然后设置b的值为2。 调用binary_add(a,b)：在a-&gt;PyObject_HEAD找到typecode，a是整数，值为1；在b&gt;PyObject_HEAD找到typecode，b是整数，值为2。调用binary_add(a-&gt;val,b-&gt;val)，返回结果，是一个整数。 创建一个Python对象c：设置c-&gt; PyObject_HEAD -&gt;typecode为整数，将c-&gt;val设置为3步骤中返回的结果。 大家从上述步骤不难看出，动态类型语言，任何操作都涉及到很多的操作，这是Python对数值操作比C慢的主要原因。 Python是解释型语言而不是编译型语言。从上面我们看到了解释代码和编译代码之间的一个区别。优秀的编译器可以优化重复和不需要的操作，这使得它速度快。 Python的对象模型会导致内存效率较低当我们想存储若干整数时，Python可能会使用list对象，而在C中，会使用基于某种缓冲区的数组。 比如最简单形式的NumPy数组是围绕C数组构建的Python对象，也就是说，它有一个指向值的连续缓冲数据区的指针，每一个指针指向一个Python对象，该对象又饮用其数据，如图所示： 从上图不难看出，如果进行顺序执行数据的操作，那么numpy将比python在存储和访问上更有效率。 Python效率这么低，为什么我们还要使用它？ Python的动态类型使得Python比C更加容易使用，它非常的灵活，这种灵活性可以有效的利用我们的开发时间，在真正需要优化的时候，我们可以使用Python内置的库对其进行优化，这就是为什么在科学研究中，Python的使用率一直在不断增长，Python是用代码进行科学研究的一门非常有效的语言。 许多Python程序慢，是没有利用Python及其标准库中提供的功能，在数学和统计科学运算方面可以使用NumPy和Pandas等库提升速度，PyPy运行时（解释器的一种，默认解释器是CPython，是一个Python的JIT实现，只需通过用PyPy替换CPython）可以为许多Python程序提供数量级的加速。比如为我们长时间运行的Web服务器加速。 在我们开发的程序中，一个程序90%的运算往往在10%的代码中，所以针对这10%的代码进行优化可以大大提高我们程序的运行效率。在Python中，我们可以选择将这10%的代码通过Cython或Numba等项目转换成C或者若干程序集。 Cython是Python的超集，几乎是Python和C的合并，是一种渐进式语言，任何Python代码都是有效的Cython代码。Cython代码编译成C代码，使用Cython，我们可以编写一个模块或方法，让其具有C的类型和性能。混合使用C类型和Python类型。通过Cython，我们可以让我们的程序进行进一步的优化，并且具有Python的优点。 开发人员的时间效率，一个py程序可能需要6s时间，而C可能只需要1s。但开发人员使用Python可能只需要10分钟就能完成这个程序。而使用C语言你可能需要1个小时或者更多。 从上面不难看出，可能对于吞吐量比较大，并发需求较低但软件，Python不太适合。但从系统管理到目前非常火热的机器学习领域，Python显然是非常合适的语言。当要求应用开发速度以及开发人员时间有限的情况下，使用Python无疑是非常好的一个选择！ 好了，本篇文章就给大家介绍到这里，喜欢我到文章的朋友可以点击【关注】。欢迎大家留言交流。最后放上：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在学习Python之前你必须知道的]]></title>
    <url>%2F%E5%9C%A8%E5%AD%A6%E4%B9%A0Python%E4%B9%8B%E5%89%8D%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.html</url>
    <content type="text"><![CDATA[前言随着人工智能的兴起和机器学习领域的进步，人工智能已经在潜移默化中改变着我们的生活。 在2017年里，人工智能和机器学习呈现出了爆炸式的增长态势，与此同时，Python也在这几年中变得越来越火热。 伴随着人工智能的发展和机器学习的火热，许多程序开发人员开始改变方向拥抱人工智能，该培训机构也纷纷开始开设Python课程，许多其它行业的人也想以Python为契机转行进入程序开发行业，甚至连小学课程都加入连Python！ 本文将从Python的介绍以及目前的市场行情来告诉广大即将入行的同学们在选择之前你应该知道的一些东西。 什么是Python Python是一种后端程序语言，非常适合初学者入门。 Python在许多方面和Ruby类似，但和其他编程语言相比比较冗长，稍微啰嗦一点。 Python是一门高级编程语言，这意味着你不必把太多经历放在程序的底层实现上，你不需要太多的其他基础也能使用它写一些工具。 Python可以用于编写脚本、网页抓取和创建数据集。在科学计算领域非常受欢迎。有一些库在科学计算领域非常好用。 Python是一种网络编程语言，可以用于Web开发。 Python的起源 1982年，荷兰人Guido van Rossum正在开发一个教育项目：开发一个名为ABC的语言。从那以后，Rossum开始从事Python语言的开发，在Python中有着ABC语言的深刻印记。 Python是最适合初学者的编程语言？ Python的语法非常直观，非常容易理解。 Python非常易读。可能在许多公司里面项目代码不是使用Python写的，但是也会使用Python写一些工具和自动化脚本。 Web编程。Python中的flask框架很简单就可以编写出一个动态响应式的网站。这无疑对初学者来讲可以鼓舞他们，因为这种网站和我们平时的网站看起来并没什么区别。 Python的社区比较成熟。 Python能用来做什么？ Web后端开发。django，flask等非常优秀的web框架。 数据科学。Python在数据分析和数据科学领域应用非常广泛。numpy，scipy等库是机器学习和数据科学处理方面非常优秀等库。大数据分析、金融分析、科学分析等领域都大量使用了数据分析。 人工智能，TensorFlow。人工智能的一些常见应用也使用来Python技术。 Python还能用于嵌入式系统编程（micropython） 自动化运维。使用Python进行自动化运维工作。 Python作为一门胶水语言，对于那些一次性的管理任务，都可以使用Python来解决。可能在许多公司里没用使用Python作为主力后端语言，但他们可能会使用Python为部署和其它开发工作任务构建脚本，管理自动化进程，清理数据或者迁移数据。 其他。还有许多Python能够做的事情，如SEO等。Python能做的事情绝对不仅仅是爬虫，当然绝大多数人都是从Python开始的。随着互联网的发展，Python能做的事情将越来越多。 Python的不足之处Python作为一门解释型语言，它的运行速度比其它的编译语言慢。这意味着有时代码运行速度会低于你的预期。 通过Python你能从事什么样的工作？ 你可以从事Web开发。如Google、Facebook、Spotify、Netflix等知名的大公司都维护着大量的Python代码。 从事自动化运维工作。 从事目前非常热门的人工智能和机器学习的相关工作。 Python目前的市场情况得益于人工智能和机器学习的兴起，目前Python在市场上非常火热，需求量非常大。这意味着你想通过Python切入到IT行业去找一份工作是可行的。但热门的同时也意味着涌入者非常多，你可能会面对很多的竞争者。并且互联网发展日新月异，你永远不知道下一刻会发生什么。所以，切入该领域，得思考清楚，一旦做出来选择，那么就赶紧努力，付出行动，不然也是白搭。 如何学习Python？加入你已经决定来要学习Python，那么作为一个新手，你又该如何学习Python呢？ 希望从事一份Python相关的工作，这意味着你要学习的绝不仅仅是Python这门语言的语法以及学几个热门的框架就足够了的。 你需要掌握Python基础 学完这些之后，你需要去学习一些比较流行的框架（django，flask，TensorFlow，Numpy等等许多，根据你想从事的方向去写），这些框架可能就是日后就职的公司的项目使用的，所以你得会。 Linux操作的基本知识。Python应用基本都部署在Linux系统上，所以你需要掌握一定的Linux只是，不需要你会很多，但常用但操作你得会，文件操作，进程管理等。 数据结构和算法的知识。可能你在工作中并不需要自己去写算法。但掌握常见的数据结构和算法是非常有必要的，这样你可以更加理解Python中的list，dict的原理，也有利于你写出优秀的代码。 计算机网络相关的知识也必须掌握。 除此之外，还有许多更具你工作的需要你得去学习的知识，这个因人而异，每个人遇到的项目和困难不一样。 是不是觉得要学习的东西太多了？确实，程序员学习的东西确实非常多，但不用紧张，一步一个脚印，编程需要积累和沉淀，在不知不觉中，或许你就成长为一个大神了。我正在努力，也是在自己学习Python。入行也才三年不到。 好吧，这篇文章就写到这里吧，其实感觉自己什么都没写，写了一堆废话。很想贴代码的，但排版不好。下面贴一波资料吧。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的职业生涯如何规划]]></title>
    <url>%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92.html</url>
    <content type="text"><![CDATA[毛毛匆匆这两三年大学毕业近三年，三年时间说短不短，说长也不长，我是一名程序员。这两三年经历了许多，也成长了许多。 作者是一名程序员，从业年龄不长，三年不到的时间，但时常都能感觉到自己身上有着巨大的压力，来源于生活上的，也有来源于对工作未来的些许担忧，或许自己还未曾明确自己的职业规划。 相信很多人都曾今对自己的职业生涯有过迷茫，本篇文章也只是想带着自己这两三年的经历来说一说，作为一名程序员，我们的职业生涯应该如何的进行规划，从事其它行业人也可以看一看，或许也能触类旁通，有所收获。（PS：工作年限不长，说的不妥之处，请多多指教）。 专业技能方向的规划 这是我个人对于程序员职业生涯规划的一些想法。在我大学接触程序员这个行业的时候，就经常听许多人说，程序员是个青春饭，30岁之后你没有转行管理你就只能改行了之类的。当时我心里还有些担忧，我对于转岗管理非常的抵触，我非常喜欢敲一辈子键盘（我没啥大志-_—）。知道我工作后看到我40多岁的老大还在敲代码，我的心又放下来了，同时也告诉自己，我要努力，以后也这样。 在这日新月异的互联网时代，作为一名互联网从业者，首先我们得树立终身学习，终究就业的心。生命不止，奋斗不息。 程序员只是一个笼统的称呼，在程序员里，又分了许许多多的工种，首先，不论我们是从事哪方面的工作，我们都不能把自己局限在某一个领域，一定要有意识的去开阔自己的视野，整个计算机领域是如何发展的、互联网时代的演化方向和趋势（就像之前多PC时代到移动互联网时代再到现如今非常火热的人工智能大数据时代）,我门需要去了解不同的编程语言和不同领域的基础知识。触类旁通，才能不断提高自己。 其次，我们得提高自己的专业知识水平，算法和数据结构是我们必须得会的，这是基础，你的基础有多好，决定你日后能站的多高。不要让自己在大楼已经建了一半之后再回头去补这些基础知识，这会让你得补偿失得。 除了上述基础理论的沉淀之外，我们还需要去不断的实践，写代码光靠读（读资料书，读别人博客，读别人代码）是远远不够的，程序是写出来的，只有经过大量的实践，我们才能验证这些理论，再能更加深刻的体会到为什么是这样，知道了为什么是这样，我们才能做的更好。就像刚开始完成一个功能需要100行代码，而两年之后你也许10行代码就搞定了。因为我们写到多了，不断了抽象、优化了。 职场上的选择 在职场上，每个人都有着自己的想法，我们应该如何去选择一个公司，我们应该多久跳一次槽呢？经常能在群里看到有人问，我面试了几家公司，有几家公司愿意要我，我去哪一家好之类的问题。 每个人都想找一个钱多活少离家近的工作，但是这只是最美好的想法，现实总是会有各种各样的因素来制约我们，当生活上有事情的时候，我们或许需要选择一个活少离家近的，当我们经济上压力比较大的时候（房贷、车贷）时，或许钱多才是我们第一考虑的因素。当我们还是刚出社会的时候，我们的专业技能和工作经验不足的时候，我们可能就需要选择活多机会多的工作。 30岁之后我们时继续做技术还是继续做管理呢？这是许许多多多程序员都想过的问题，也是许许多多多程序员面临过的问题，目前的我还没面临这个问题，但我也曾经想过这些。最后，我得出结论： 我们都有着自己最终的目标，万变不离其宗，跟着自己内心的想法时什么，我门只要心里想着自己最终要得到什么，那就可以了。不论是管理还是技术，都能达成我们的最终目标。毕竟我们都是希望能够让自己在工作的非常开心的同时还能够不为柴米油盐发愁罢了。 好马配好鞍。如果你是一个偏向于管理，或者你的能力和你的性格适合在管理岗位上，那么你就可以往这个方向走，因为这样可以能让你比较舒服的实现自己的目标。如果你是一个偏向于潜心研究的人，那么技术方向获取是你不错的选择，你可以专攻技术向，成为一个技术专家。 成为自由职业者或者创业？除了选择在公司就职之外，我们还有其它的选择：自由职业者或者创业。两者都需要你积累人脉。（如何积累人脉？将在后面的换工作板块中阐述） 自由职业者：当你的专业技术水平比较高并且人际口碑很不错时，你可以选择成为一名自由职业者，与公司合作，单独接项目去开发。 创业：创业也是许多人在职场上摸爬滚打许多年之后的选择。当你认为自己有机会并且有一定的资本时，你可以选择去创业，创业这条路，有着无限可能。自己做好思想准备即可。 关于换工作 在我们职业生涯中，换工作是正常的，我们需要通过换工作来提高自己（能力和金钱）。我们经常在想，我们什么时候该换工作呢？如果我辞职了，我多久才能找到一份满意的工作呢。 在我看来，我们每一份工作的时间不能太长，也不能太短，频繁的换工作绝对不利于自己的职业生涯发展。 给大家算一笔换工作的账：换工作意味着今年可能没有年终奖，然后离职到下一份工作又一个空闲期，这段时间你只能吃老本，进入新公司你有几个月的试用期，这几个月试用期你可能会只有80%的薪水，还没有五险一金。你还需要面临没通过试用期的风险。所以每次离职都是成本挺大的。 为什么需要换工作？ 在一家新公司，我们不仅会接触到其它编程语言，还会接触到其它的工作方式和新的同事。跟不同的人合作，我们总是能学到不同的东西。并且，我们会积累人脉，这对于我们以后找另一份工作，也是有帮助的。 改变工作的另外一个原因是避免感到无聊，如果5年甚至10年我们一直在做同样的事情，那么可能我们不会在学习了，太安逸了。改变工作，我们将学习新的东西，迎接新的挑战，同时也会增加我们的就业能力。 在同一家公司里，我们也可以变换自己的角色，我们可以从开发人员变成测试人员，也可以变成产品经理，岗位的流动可以让扩大我们的技能包。 不管怎么样，我们都要有意思的去改变自己的工作，我们不能只停留在原地，等待着被迫改变，我们应该化被动为主动，抓住主动权，我们才能更好的把握自己的命运。 为什么不能在一份工作上做太久的时间呢？在同一家公司呆了10年，15年甚至20年的人，那么他找另一份工作相对于五年左右换工作的人的机会和竞争力将大大减少。就像去年华为辞退老员工引发大议论一样，根源在于他们下一份工作的收入和机会将远远低于现在的。因为和他的专业知识对口的公司太少了。而其它方面的技术他们又不如别人。更重要的是他们已经不再年轻，思维留下了太多以前公司的烙印，再想改变已经没有那么容易了，欢聚换来讲，他们没有太大的竞争力了。 为什么不能在一份工作上做太短的时间呢？换工作的弊端在前面已经阐述过了，所以一份工作我们需要一段时间。每一份工作我们都能在其中学到不少东西。我们需要积累和沉淀，频繁的换工作，会有以下不良的影响： 在职业圈内给人留下不安分，不忠诚的印象，在这个互联网时代，世界那么小，培养自己的职业道德和人际口碑将会给你带你很大的影响，是好是坏，全在于你自己怎么做。 在一个公司我们会接触到公司的业务，短时间你接触不到核心的业务，那么你学的东西肯定价值没那么大，在一个公司我们需要花时间去研究、接触这家公司的业务，这样才能培养自己的能力，才能在简历上写着自己负责了什么项目。其次，每个公司都是一个社会，我们融入这个社会，把这里面的人际关系处理好也需要时间。 好了，这篇文章就给大家分享到这里，由于作者自身工作经历也不是很长，所以观点难免有偏颇之处，文字排版也做的不是很好，能看到这里的都是很有耐心的人了。非常感谢您的阅读。觉得作者写的还不错的话，就点个赞或关注下吧。 PS：本文首发于今日头条：新农民的编程之旅]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>职业生涯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS下使用pyenv管理Python版本]]></title>
    <url>%2FMac-OS%E4%B8%8B%E4%BD%BF%E7%94%A8pyenv%E7%AE%A1%E7%90%86Python%E7%89%88%E6%9C%AC.html</url>
    <content type="text"><![CDATA[问题的由来在开发过程中，可能会遇到多个版本同时部署的情况。 Mac OS自带的Python版本是2.x，自己开发需要Python3.x 系统自带的是2.6.x，开发环境是2.7.x 由于Mac机器系统保护的原因，默认的Python无法对PIP一些包升级，需要组建新的Python环境 此时需要在系统中安装多个版本的Python，但又不能影响系统自带的Python，即需要实现Python的多版本共存。pyenv就是这样一个Python版本管理器。 Pyenvpyenv是Python版本管理工具。pyenv可以改变全局的Python版本，安装多个版本的Python，设置目录级别的Python版本，还能创建和管理vitual python enviroments。所有的设置都是用户级别的操作，不需要sudo命令。 pyenv主要用来管理Python的版本，比如一个项目需要Python2.x，一个项目需要Python3.x。而virtualenv主要用来管理Python包的依赖。不同项目需要依赖的包版本不同，则需要使用虚拟环境。 pyenv通过系统修改环境变量来实现Python不同版本的切换。而vitualenv通过Python包安装到一个目录来作为Python虚拟包环境，通过切换目录来实现不同包环境间的切换。 pyenv的美好之处在于，它并没有使用将不同的 PATH植入不同的shell这种高耦合的工作方式，而是简单地在PATH植入不同的shell这种高耦合的工作方式，而是简单地在PATH 的最前面插入了一个垫片路径（shims）：~/.pyenv/shims:/usr/local/bin:/usr/bin:/bin。所有对 Python 可执行文件的查找都会首先被这个 shims 路径截获，从而使后方的系统路径失效。 安装之前不同系统请参考 Common build problems，安装必须的工具。 pyenv安装安装homebrew如何安装homebrew？ 安装pyenv使用homebrew安装Mac下安装了homebrew之后使用homebrew安装pyenv。 123brew updatebrew install pyenvbrew upgrade pyenv #之后如果需要更新pyenv 在安装成功之后需要在.bashrc或者.bash_profile中添加三行来开启自动补全。 123export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;eval &quot;$(pyenv init -)&quot;eval &quot;$(pyenv virtualenv-init -)&quot; 自动安装pyenv提供了自动安装的工具，执行命令安装即可。 1curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash 需要保证系统又git，否则需要安装git。 手动安装也可以采用手动安装的方式，将pyenv检出到你想安装的目录。 123456cd ~git clone git://github.com/yyuu/pyenv.git .pyenvecho &apos;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&apos; &gt;&gt; ~/.bashrcecho &apos;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&apos; &gt;&gt; ~/.bashrcecho &apos;eval &quot;$(pyenv init -)&quot;&apos; &gt;&gt; ~/.bashrcsource ~/.bashrc 添加环境变量。PYENV_ROOT 指向 pyenv 检出的根目录，并向 $PATH 添加 $PYENV_ROOT/bin 以提供访问 pyenv命令的路径。 这里的 shell 配置文件（~/.bash_profile）依不同 Linux 而需作修改，如果使用 Zsh 则需要相应的配置 ~/.zshrc 在使用 pyenv 之后使用 pip 安装的第三方模块会自动安装到当前使用 python 版本下，不会和系统模块产生冲突。使用 pip 安装模块之后，如果没有生效，记得使用 pyenv rehash 来更新垫片路径。 pyenv常用命令使用pyenv commands可以查看所有pyenv命令。 查看已安装Python版本 pyenv versions 123ferdinand@ferdinanddeMacBook-Pro  ~  pyenv versions system* 3.6.3 (set by /Users/ferdinand/.python-version) 带*号的是当前路径下所使用的Python版本。 查看可安装的Python版本 pyenv install -l 1234567891011121314151617181920212223242526272829erdinand@ferdinanddeMacBook-Pro  ~  pyenv install -lAvailable versions: 2.1.3 2.2.3 2.3.7 2.4 2.4.1 2.4.2 2.4.3 2.4.4 2.4.5 2.4.6 2.5 2.5.1 2.5.2 2.5.3 2.5.4 2.5.5 2.5.6 2.6.6 2.6.7 2.6.8 2.6.9 2.7-dev 2.7 2.7.1 2.7.2 2.7.3 ………… 安装Python1pyenv install &lt;version&gt; # version为版本号 Python版本管理123pyenv global &lt;version&gt; # 全局设置python版本为指定版本，设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。pyenv local &lt;version&gt; # 设置当前路径下python版本为指定版本，设置 Python 本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。pyenv shell &lt;version&gt; # 设置当前shell窗口使用的python版本为指定版本，设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。这个版本的优先级比 local 和 global 都要高。–unset 参数可以用于取消当前 shell 设定的版本。 使用pyenv切换Python 版本之后可以通过which python或者是python --version来查看是否生效。 1234ferdinand@ferdinanddeMacBook-Pro  ~  which python/Users/ferdinand/.pyenv/shims/pythonferdinand@ferdinanddeMacBook-Pro  ~  python --versionPython 3.6.3 Python版本的优先级 shell &gt; local &gt; global pyenv会从当前目录开始向上逐级查找.python-versiob文件，直到根目录为止，若找不到，则使用global版本。 1pyenv rehash # 创建垫片路径（为所有已安装的可执行文件创建 shims，如：~/.pyenv/versions/*/bin/*，因此，每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令） Python卸载12pyenv isntall &lt;version&gt; # 安装版本号为&lt;version&gt;的Pythonpyenv uninstall &lt;version&gt; #卸载版本号为&lt;version&gt;的Python]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pyenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下关于将普通用户权限提升为root的问题]]></title>
    <url>%2FUbuntu%E4%B8%8B%E5%85%B3%E4%BA%8E%E5%B0%86%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E4%B8%BAroot%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[问题的由来 博主一个好奇就想把自己的那个用户提升为root级别的，所以进行了如下操作。1234567suvi etc/passwd然后将自己创建的那个用户（博主的用户名为lucas），对应的值lucas:x:1000:0:lucas,,,:/home/lucas:/bin/bash中的1000修改成了和root用户一样的0.好吧，这下lucas确实成了root用户了，但是问题就来了，你下次登录的适合界面上只剩下客人会话了。其它会话都没了。 解决措施1234567在用户登录界面，按下 `ctrl+alt+f7`进入命令行界面。按照如下操作进行：输入用户名：lucas（博主的）输入密码：xxxxxx然后使用vi命令打开我们修改过的文件：/etc/passwd将0修改成原来的数值。这样我们的登录界面又会出现用户登录啦！好吧。。至此，问题解决。 PS：博主的Linux系统的Ubuntu kylin 15.10 的版本。具体的原因是ubuntu从12.04开始，添加了额外的root保护，不允许直接开启root账户，强制使账户改为root账户会被屏蔽。所以以后不能再继续作死了。老老实实的用sudo吧。%&gt;_&lt;%。 记录时间：2015年12月10日19:05:05。下班吃饭。]]></content>
      <categories>
        <category>错误收集</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>root权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器是如何工作的]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84.html</url>
    <content type="text"><![CDATA[why？ Web浏览器是世界上使用最广泛的软件。 浏览器提供web资源并创建可以允许web应用程序的沙箱环境。 浏览器实现这一点的方式非常复杂，并且由许多不同的标准决定。 浏览器的一些机制其实是具有着欺骗性和反直觉性。 了解浏览器的工作原理为我们提高网站/网页类应用程序的效率和代码的组织结构提供了理论依据。 复杂 这里无法讲解浏览器工作原理的所有细节。 每个浏览器都有自己的实现方式。 一般和模块化的方法 浏览器遵循相同的标准 大多数浏览器有着相同的总体结构和同样的模块 本文将讨论这些共同行为。 浏览器的两个主要模块 渲染引擎（也成为布局引擎） Javascript解释器 不同浏览器使用的渲染引擎不一样 Mozilla Firefox 使用 Gecko Safari 和 Google Chrome（version 27之前）使用Webkit。 Chrome使用Blink在version 27之后 一个web页面的组成 HTML：应用程序的内容 CSS： 内容的样式 Javascript： 应用程序的逻辑部分，有时也是一些动画(animations)等等。 其它 渲染引擎（rendering engine）的工作从HTML,CSS,JS开始，将网页呈现在用户屏幕上，大概需要经过四个阶段： 处理HTML构建DOM，处理CSS构建CSSOM 将DOM和CSSOM合并到一个渲染树中 布局渲染树（render tree）,通过几何计算]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器从请求发出到返回经历了什么]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%AF%B7%E6%B1%82%E5%8F%91%E5%87%BA%E5%88%B0%E8%BF%94%E5%9B%9E%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88.html</url>
    <content type="text"><![CDATA[一个最简单的http请求，没有代理，ipv4和以下任何步骤都没有问题的情况下： 浏览器检查缓存，如果请求的对象在缓存中并且是新的，跳到步骤9。 浏览器从OS获取服务器的ip地址。 OS进行DNS查找，并将IP地址返回给浏览器。 浏览器打开到服务器的TCP连接（如果是https则步骤更复杂点,后面再分析）。 浏览器通过TCP连接发送HTTP请求。 浏览器接受http响应，并可能关闭TCP连接或将其重新用于另一个请求。 浏览器检查响应是重定向还是条件响应（3xx的状态码）,授权请求（401），错误（4xx或5xx）等。这些与正常响应（2xx）的处理方式不同。 如果允许缓存，响应将存储在缓存中。 浏览器解码响应（比如响应是gzip的需要解压缩） 浏览器决定如何处理响应（它可能是一个HTML页面，可能是一张图片，也可能是一个声音片段）。 浏览器渲染响应，或者提示无法识别的类型弹出框警告。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate学习教程（二）----ORM 概述]]></title>
    <url>%2FHibernate%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89-ORM-%E6%A6%82%E8%BF%B0.html</url>
    <content type="text"><![CDATA[什么是JDBC JDBC:Java Database Connectivity，提供一组Java API，用于java程序中访问关系数据库。通过这些API，Java程序能够执行SQL语句并与任何SQL兼容的数据库进行交互。 JDBC提供了一种灵活的架构，可以编写一个独立于数据库的应用程序，该应用程序可以在不同的平台上并与不同的DBMS进行修改。 JDBC的优点和缺点 优点 缺点 简洁的SQL处理 用于大型应用程序时比较复杂 处理大量数据有着良好的性能 资源占用开销比较大 非常适用于小型应用程序 没有进行封装抽象 语法简单，学习成本较低 很难用于MVC模式开发 只能用于DBMS查询 为什么要进行ORM关系映射(Object Relational Mapping)当我们使用面向对象的系统时，对象模型与关系数据库之间存在不匹配。RDBMS以表格形式表示数据，而面向对象的语言（如Java和C#）将其表现为对象的互联图。如下所示： 12345678910111213141516171819202122232425public class Employee &#123; private int id; private String first_name; private String last_name; private int salary; public Employee() &#123;&#125; public Employee(String fname, String lname, int salary) &#123; this.first_name = fname; this.last_name = lname; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public String getFirstName() &#123; return first_name; &#125; public String getLastName() &#123; return last_name; &#125; public int getSalary() &#123; return salary; &#125;&#125; 上面的对象需要被存储和检索到下面的RDBMS表： 1234567create table EMPLOYEE ( id INT NOT NULL auto_increment, first_name VARCHAR(20) default NULL, last_name VARCHAR(20) default NULL, salary INT default NULL, PRIMARY KEY (id)); 那么就会存在以下两个问题： 如果我们需要在开发了几个页面之后或在应用程序中修改数据库的设计时，应该怎么处理？ 在关系数据库加载和存储对象会暴露以下不匹配问题： 不匹配问题 描述 Granularity（粒度） 有时，您将有一个对象模型，它具有比数据库中对应表数量更多的类。 Inheritance（继承） RDBMS不定义类似于继承的任何东西，它是面向对象编程语言中的自然范例。 Identity（对象同一性） RDBMS正好定义了“同一性”的一个概念：主键。然而，Java定义了对象标识（a == b）和对象相等（a.equals（b）） Associations 面向对象语言使用对象引用表示Associations，RDBMS使用外键列表示 Navigation 在Java和RDBMS中访问对象的方式是完全不同的 对象关系映射（ORM）是处理所有上述不匹配问题的解决方案。 粒度问题 粒度：是指你正在使用的类型的大小。 继承（子类型问题） 在Java中，使用超类(superclass)和子类(subclass)来实现继承模型。 在Java中，继承是类型继承(type Inheritance)，而数据库表并不是一种类型。 数据库产品一般不实现类型或者表继承。而且即使实现了，我们也会遇到数据完整性的问题（对可更新视图的有限完整性规则）。 一旦把继承进入到模型当中，就有了多态(polymorphism)的可能。SQL数据库缺乏一种明显的表示多态关联的方式，一个外键约束精确的引用一张目标表，定义一个引用多表的外键并不容易。必须编写一个程序化的约束来加强这种完整性规则。 子类型的这种不匹配的结果是：模型中的继承结构必须在一个不提供继承策略的SQL数据库中被持久化。 对象同一性如果当我们需要检查两个对象是否为同一个对象的时候。解决方法有三种： 在java中： 对象同一性（粗略等同于内存位置，用a==b检查） 等同性，通过equals()方法（也成为值等同）的实现来确定。 数据库的同一性用主键值来表达。如果使用java中的方法来判断，那么主键值必然会不相等。 什么是ORM ORM（对象关系映射），是一种用于关系数据库和面向对象编程语言（如Java、C#）之间转换数据的编程技术。相对于JDBC，ORM具有以下优点： 序号 优点 1 允许业务逻辑代码访问对象而不是数据库表 2 从面向对象的角度考虑隐藏SQL查询的详细信息 3 底层基于JDBC 4 无需处理数据库实现 5 基于业务概念而不是数据库结构的实体 6 事务管理和秘钥自动生成 7 应用快速开发 ORM解决方案由以下四个模块组成： 序号 解决方案 1 用于对持久化类的对象进行基本CRUD操作的API 2 用于指定引用类的类和属性的查询的语言或API 3 用于指定映射元数据的可配置工具 4 用于实现ORM的一项技术，与事务对象交互，执行脏检查、延迟关联抓取以及其它优化功能 Java中的ORM框架Java中有几个持久化框架和ORM选项。持久化框架是一种将对象存储和检索到关系数据库中的ORM服务。 Enterprise JavaBeans Entity Beans Java Data Objects Castor TopLink Spring DAO Hibernate ……. etc. ORM和Hibernate的一些好处生产力与持久化相关的代码可能会是java中最冗长的一部分代码，Hibernate除去了许多琐碎的工作，让我们可以把更多的精力集中于业务问题的处理上。无论我们喜欢哪一种应用程序开发策略——自上而下，从一个领域模型开始；或者自底而上，从一个现有的数据库Schema开始——Hibernate与适当的工具一起使用，将明显减少开发时间。 可维护性更少的代码行使得系统更易于理解，因为它强调业务逻辑甚于那些费力的基础性工作。更重要的是，系统包含的代码越少则越利于重构。自动的对象/关系持久化充分减少了代码行。 Hibernate更易于维护还有其它原因，在手工编码的持久化系统中，关系表示法和对象模型实现领域之间存在一种必然的压力。改变一个，通常都要改变另一个，并且一个表示法设计通常需要妥协以便适应另一个的存在。ORM提供了两个模型之间的一个缓冲，允许面向对象在Java方面进行更优雅的利用，并且每个模型的微小变化都不会传递到另一个模型。 性能手工编码的持久化和自动的持久化相比总是可以一样快，并且经常更快。这是事实。但是在实际开发中，会受到时间和预算的约束。 在有限时间的项目中，手工编码的持久化通常允许你进行一些优化；Hibernate始终允许使用更多的优化。 自动的持久化能够大大提高开发人员的工作效率，使得开发人员能够花更多的时间对其它少数瓶颈进行手工优化。 实现ORM框架的人，可能在性能优化方面比我们做的更好。 供应商独立性ORM从底层的SQL数据库和SQL方言中把应用程序抽象出来。如果这个工具支持不同的数据库，这会给我们的应用程序带来一定程度的可移植性。可以帮我们减少一些被供应商锁定的风险。 数据库的独立性使得我们可以在开发时选择一些轻量级的数据库，在部署时，将实际的产品部署在不同的数据库上。]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>ORM框架</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate教程（一）---Hibernate简介]]></title>
    <url>%2FHibernate%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[Hibernate简介 Hibernate是一个Java对象映射关系的解决方案的ORM（Object-Relational Mapping）框架，是一个开源持久框架，由Gavin King于2001年创建。为Java应用提供强大的、高性能对象持久化和查询服务。 Hibernate将Java类映射到数据库表，将Java数据类型映射到SQL数据类型，减轻了开发人员95%的数据持久性相关的编程任务。 Hibernate位于传统的Java对象和数据库服务器之间，基于适当的O/R机制和模式来处理持久化这些对象的所有工作。 Hibernate的优势 Hibernate通过XML配置文件将Java类映射到数据库表，而不需要编写任何代码。 提供简单的API,用于直接存储和检索数据库中的Java对象。 如果数据库或任何表中有更改，只需要修改XML文件。 提取我们不熟悉的SQL类型，并提供我们熟悉的Java对象。 Hibernate不需要应用府服务器来操作。 操作复杂关联的数据库对象。 使用智能抓取策略简化数据库操作。 提供简单的数据查询。 Hibernate支持的数据库Hibernate几乎支持所有的关系型数据库管理系统(RDBMS),支持的数据库如下所示： HSQL Database Engine DB2/NT MySQL PostgreSQL FrontBase Oracle Microsoft SQL Server Database Sybase SQL Server nformix Dynamic Server Hibernate架构Hibernate架构是分层的，所以我们不需要知道底层的API，Hibernate利用数据库和配置数据向我们的应用程序提供持久性服务（和持久性对象）。 下图是Hibernate应用结构体系简要视图： 下图是Hibernate应用结构体系详细视图，包含了几个重要的核心类： Hibernate使用各种现有的Java API，如JDBC,JTA,JNDI。 JDBC提供了关系数据库通用的功能抽象层，所有具有JDBC驱动程序的数据库都被Hibernate支持。JTA和JNDI允许Hibernate与J2EE服务器集成。 Hibernate应用结构体系主要类对象Configuration ObjectConfiguration Object是我们在Hibernate应用程序中创建的第一个Hibernate对象，通常在应用程序初始化时且只创建一次。它是Hibernate所需要的配置和属性文件。Configuration对象提供两个关键组件： Database Connection:通过Hibernate支持的一个或多个配置文件来处理。hibernate.properties,hibernate.cfg.xml。 Class Mapping Setup:这个组件用于Java类和数据库表之间创建连接。 SessionFactory ObjectConfiguration Object用于创建一个SessionFactory Obejct，该对象使用提供的配置文件为应用程序配置Hibernate，并允许实例化一个Session对象。SessionFactory是线程安全对象,供应用程序的所有线程使用。 SessionFactory是重量级对象。因此通常在应用程序启动期间创建并保留供以后使用。 每个数据库都需要使用一个单独的配置文件创建一个SessionFactory对象。如果使用多个数据库，则必须创建多个SessionFactory对象。 Session(会话) ObjectSession（会话）用于获取与数据库的物理连接，Session对象是轻量级的，并且是每当需要与数据库进行交互时才会被实例化。持久化对象通过Session对象进行保存和检索。 Session对象不应该长时间保持打开，因为他们通常不是线程安全的，所以应该根据业务需求创建和销毁它们。 Transaction（事务） Object事务Transaction代表与数据库的工作单元，大多数关系型数据库都支持事务功能。Hibernate中的事务由底层事务管理器和事务（来自JDBC和JTA）处理。 这是一个可选对象，Hibernate应用程序可以选择不使用此接口，而选择在自己的应用程序代码中管理事务。 Query Object查询Query对象使用SQL或者Hibernate查询语言(Hibernate Query Language,HQL)字符串从数据库检索数据并创建对象。Query实例用于绑定查询参数，限制查询返回的结果数量，最后执行查询。 Criteria Object条件对象用于创建和执行面向对象的标准查询以检索对象。 Hibernate 环境配置该章主要介绍如何安装Hibernate以及其它相关包来为Hibernate应用程序准备一个开发环境。本文将使用Mysql数据库来演示Hibernate实例。 Hibernate下载 在windows上下载.zip文件，在Unix上下载.tz文件。 从http://www.hibernate.org/downloads下载最新版的Hibernate。 下载完成之后进行解压。 安装Hibernate下载完Hibernate之后，只需要执行以下两个简单的步骤即可。请确保正确的配置了CLASSPATH环境变量，否则在编译应用程序时会出现问题。 Hibernate的依赖包 S.N. Packages/Libraries 1 dom4j - XML parsing www.dom4j.org/ 2 Xalan - XSLT Processor http://xml.apache.org/xalan-j/ 3 Xerces - The Xerces Java Parser http://xml.apache.org/xerces-j/ 4 cglib - Appropriate changes to Java classes at runtime http://cglib.sourceforge.net/ 5 log4j - Logging Faremwork http://logging.apache.org/log4j 6 Commons - Logging, Email etc. http://jakarta.apache.org/commons 7 SLF4J - Logging Facade for Java http://www.slf4j.org Hibernate配置Hibernate需要提前知道在哪里可以找到定义的Java类和数据库表相关联的映射信息。Hibernate还需要一组与数据库和其它相关参数相关的配置设置。所有这些信息通常作为标准java属性文件hibernate.properties或者名为hibernate.cfg.xml的XML文件提供。 Hibernate属性以下是在独立情况下为一个数据库配置所需要的重要属性列表： S.N. Properties and Description 1 hibernate.dialect:此属性使Hibernate为选定的数据库生成适当的SQL 2 hibernate.connection.driver_class:JDBC驱动程序类 3 hibernate.connection.url:数据库实例的JDBC URL 4 hibernate.connection.username:数据库用户名 5 hibernate.connection.password:数据库密码 6 hibernate.connection.pool_size:限制在Hibernate数据库连接池中的等待连接数 7 hibernate.connection.autocommit:允许JDBC连接自动提交 如果随着应用服务器和JNDI使用同一个服务器，则还需要配置以下属性： S.N. Properties and Description 1 hibernate.connection.datasource:在应用服务器中定义的JNDI名称 2 hibernate.jndi.class:JNDI的InitialContext类 3 hibernate.jndi.&lt;JNDIpropertyname&gt;: 4 hibernate.jndi.url:提供JNDI的url 5 hibernate.connection.username:数据库用户名 6 hibernate.connection.password:数据库密码 Hibernate和Mysql数据库MySQL是目前最流行的开源数据库系统之一，下面我们创建一个hibernate.cfg.xml配置文件，并将其放置于应用程序类路径的根目录下，必须确保已经安装MySQL 并保证已经保证创建了可用的测试数据库。XML配置文件必须符合Hibernate 3 Configuration DTD，该文件可从http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd获得。1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-configuration SYSTEM "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name="hibernate.dialect"&gt; org.hibernate.dialect.MySQLDialect &lt;/property&gt; &lt;property name="hibernate.connection.driver_class"&gt; com.mysql.jdbc.Driver &lt;/property&gt; &lt;!-- Assume test is the database name --&gt; &lt;property name="hibernate.connection.url"&gt; jdbc:mysql://localhost/test &lt;/property&gt; &lt;property name="hibernate.connection.username"&gt; root &lt;/property&gt; &lt;property name="hibernate.connection.password"&gt; root123 &lt;/property&gt; &lt;!-- List of XML mapping files --&gt; &lt;mapping resource="Employee.hbm.xml"/&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 下表是各类数据库的属性类型(Dialect Property)列表： Database Dialect Property DB2 org.hibernate.dialect.DB2Dialect HSQLDB org.hibernate.dialect.HSQLDialect HypersonicSQL org.hibernate.dialect.HSQLDialect Informix org.hibernate.dialect.InformixDialect Ingres org.hibernate.dialect.IngresDialect Interbase org.hibernate.dialect.InterbaseDialect Microsoft SQL Server 2000 org.hibernate.dialect.SQLServerDialect Microsoft SQL Server 2005 org.hibernate.dialect.SQLServer2005Dialect Microsoft SQL Server 2008 org.hibernate.dialect.SQLServer2008Dialect MySQL org.hibernate.dialect.MySQLDialect Oracle (any version) org.hibernate.dialect.OracleDialect Oracle 11g org.hibernate.dialect.Oracle10gDialect Oracle 10g org.hibernate.dialect.Oracle10gDialect Oracle 9i org.hibernate.dialect.Oracle9iDialect PostgreSQL org.hibernate.dialect.PostgreSQLDialect Progress org.hibernate.dialect.ProgressDialect SAP DB org.hibernate.dialect.SAPDBDialect Sybase org.hibernate.dialect.SybaseDialect Sybase Anywhere org.hibernate.dialect.SybaseAnywhereDialect Hibernate实例创建POJO类 首先，我们创建Java POJO类，这取决于将被持久化到数据库的应用程序，生成getXXX()和setXXX()方法，使其成为JavaBeans兼容类。 POJO（java普通对象）是一种java对象，它不扩展或实现一些EJB框架分别需要的一些专门的类或接口。所有正常的Java对象都是POJO。 当你设计一个要被Hibernate持久化的类时，提供符合JavaBeans的代码以及一个在Employee类中像id属性一样用作索引的属性很重要。 12345678910111213141516171819202122232425262728293031323334353637public class Employee &#123; private int id; private String firstName; private String lastName; private int salary; public Employee() &#123;&#125; public Employee(String fname, String lname, int salary) &#123; this.firstName = fname; this.lastName = lname; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public void setId( int id ) &#123; this.id = id; &#125; public String getFirstName() &#123; return firstName; &#125; public void setFirstName( String first_name ) &#123; this.firstName = first_name; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName( String last_name ) &#123; this.lastName = last_name; &#125; public int getSalary() &#123; return salary; &#125; public void setSalary( int salary ) &#123; this.salary = salary; &#125;&#125; 创建数据库表第二步，我们需要在数据库中创建一张表，将表对应我们需要持久化的每一个对象，根据上面的java类我们创建下面这样一个表“ 1234567create table EMPLOYEE ( id INT NOT NULL auto_increment, first_name VARCHAR(20) default NULL, last_name VARCHAR(20) default NULL, salary INT default NULL, PRIMARY KEY (id)); 创建配置映射文件接下来我们需要创建一个配置文件，说明Hibernate如何将定义的类映射至数据库表。 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; &lt;hibernate-mapping&gt; &lt;class name="Employee" table="EMPLOYEE"&gt; &lt;meta attribute="class-description"&gt; This class contains the employee detail. &lt;/meta&gt; &lt;id name="id" type="int" column="id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="firstName" column="first_name" type="string"/&gt; &lt;property name="lastName" column="last_name" type="string"/&gt; &lt;property name="salary" column="salary" type="int"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 我们应该把映射文件保存为&lt;classname&gt;.hbm.xml格式的文件。上面文件保存为Employee.hbm.xml。 映射文件是一个XML格式的文档。&lt;hibernate-mapping&gt;作为包含所有&lt;class&gt;元素的根元素。 &lt;class&gt;元素用于定义从java类到数据库表的特定映射。java类名称使用使用类元素的name属性指定，并且使用table属性指定数据库表名称。 &lt;meta&gt;元素是可选元素，用于创建类描述。 &lt;id&gt;是将类中的唯一ID元素映射到数据库表的主键。id元素中的name属性引用类中的属性，cloumn属性引用数据库表中的列。type属性保存hibernate映射类型，此映射类型将从Java转换成SQL数据类型。 id元素中的&lt;generator&gt;属性用于自动生成主键值，设置class的属性值为native，让hibernate选择identity，sequence,hilo算法来创建主键，这取决于底层数据库的能力。 &lt;property&gt;元素用于将Java类属性映射到数据库表中的列。元素的name属性引用类中的属性，cloumn属性引用数据库表中的列。type属性保存hibernate映射类型，此映射类型将从Java类型转换成SQL数据类型。 创建应用类(java class)完成了以上步骤后，我们来创建一个应用文件来测试一下我们的配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import java.util.List; import java.util.Date;import java.util.Iterator; import org.hibernate.HibernateException; import org.hibernate.Session; import org.hibernate.Transaction;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class ManageEmployee &#123; private static SessionFactory factory; public static void main(String[] args) &#123; try&#123; factory = new Configuration().configure().buildSessionFactory(); &#125;catch (Throwable ex) &#123; System.err.println("Failed to create sessionFactory object." + ex); throw new ExceptionInInitializerError(ex); &#125; ManageEmployee ME = new ManageEmployee(); /* 添加一些employee对象到数据库表中*/ Integer empID1 = ME.addEmployee("Zara", "Ali", 1000); Integer empID2 = ME.addEmployee("Daisy", "Das", 5000); Integer empID3 = ME.addEmployee("John", "Paul", 10000); /* 列出所有employee对象 */ ME.listEmployees(); /* 修改 */ ME.updateEmployee(empID1, 5000); /* 从数据库中删除 */ ME.deleteEmployee(empID2); /* 列出所有对象s */ ME.listEmployees(); &#125; /* 向数据库中添加employee对象的方法 */ public Integer addEmployee(String fname, String lname, int salary)&#123; Session session = factory.openSession(); Transaction tx = null; Integer employeeID = null; try&#123; tx = session.beginTransaction(); Employee employee = new Employee(fname, lname, salary); employeeID = (Integer) session.save(employee); tx.commit(); &#125;catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125;finally &#123; session.close(); &#125; return employeeID; &#125; /* 列出所有employee对象的方法 */ public void listEmployees( )&#123; Session session = factory.openSession(); Transaction tx = null; try&#123; tx = session.beginTransaction(); List employees = session.createQuery("FROM Employee").list(); for (Iterator iterator = employees.iterator(); iterator.hasNext();)&#123; Employee employee = (Employee) iterator.next(); System.out.print("First Name: " + employee.getFirstName()); System.out.print(" Last Name: " + employee.getLastName()); System.out.println(" Salary: " + employee.getSalary()); &#125; tx.commit(); &#125;catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125;finally &#123; session.close(); &#125; &#125; /* 修改employee对象的方法 */ public void updateEmployee(Integer EmployeeID, int salary )&#123; Session session = factory.openSession(); Transaction tx = null; try&#123; tx = session.beginTransaction(); Employee employee = (Employee)session.get(Employee.class, EmployeeID); employee.setSalary( salary ); session.update(employee); tx.commit(); &#125;catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125;finally &#123; session.close(); &#125; &#125; /* 删除employee对象的方法 */ public void deleteEmployee(Integer EmployeeID)&#123; Session session = factory.openSession(); Transaction tx = null; try&#123; tx = session.beginTransaction(); Employee employee = (Employee)session.get(Employee.class, EmployeeID); session.delete(employee); tx.commit(); &#125;catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125;finally &#123; session.close(); &#125; &#125;&#125; 编译和执行编译和执行的步骤（请确保正确配置了环境变量）： 创建hibernate.cfg.xml配置文件。 创建Employee.hbm.xml映射文件。 创建Employee.java文件，并编译它。 创建如上所示的ManageEmployee.java文件，并执行编译。 执行ManageEmployee.class文件，运行程序。]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>ORM框架</tag>
        <tag>javaweb</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java解惑》读书笔记]]></title>
    <url>%2F%E3%80%8AJava%E8%A7%A3%E6%83%91%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[表达式之谜奇数性奇数：被2整除余1的数。表达式i%2是计算i除以2时所产生的余数。这个表达式其实是错误的。在所有的int数值中，有一半的值为负数，当值为负数时，无论该值为奇数还是偶数，结果都会返回false。123456789101112package com.hx.test;public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(isOdd(-5)); &#125; public static boolean isOdd(int i) &#123;// return i % 2 == 1; // 这个表达式是错误的。// return i % 2 != 0; // 正确 return (i &amp; 1) != 0; // 正确 &#125;&#125; 找零时刻1234567891011package com.hx.test;import java.math.BigDecimal;public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(2.00 - 1.10); // 输出结果0.8999999999999999 System.out.println((200-110)+"cents"); //输出结果 90 cents System.out.println(new BigDecimal("2.00").subtract(new BigDecimal("1.10"))); //输出结果0.9 &#125;&#125; 在需要使用精确数值的地方，要避免使用float和double，对于货币计算，要使用int,long,BigDecimal。 长整除123456789101112131415161718package com.hx.test;import java.math.BigDecimal;public class HelloWorld &#123; public static void main(String[] args) &#123; final long MICROS_PRE_DAY = 24*60*60*1000*1000; final long MILLS_PRE_DAY = 24*60*60*1000; //final long MICROS_PRE_DAY = 24L*60*60*1000*1000; //final long MILLS_PRE_DAY = 24L*60*60*1000; System.out.println(MICROS_PRE_DAY/MILLS_PRE_DAY); // 为什么结果会打印5？？？ // &#125;&#125; 当操作很大的数字时，千万要提防溢出。即便用来保存结果的变量足够大，也并不意味着要产生结果的计算具有正确的类型。当拿不准的时候，就使用long运算来执行整个计算。 十六进制的趣事123456789package com.hx.test;public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(Long.toHexString(0x100000000L + 0xcafebabe)); // cafebabe System.out.println(Long.toHexString(0x100000000L + 0xcafebabeL)); // 1cafebabe &#125;&#125; 混合类型的计算可能产生混淆，尤其需要注意的是十六进制和八进制字面常量无需显式的减号符号就可以表示负的数值，为了避免这种窘境，通常最好避免混合类型的计算。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java解惑</tag>
        <tag>表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下的cmd神器:Cmder介绍及其设置]]></title>
    <url>%2Fwindows%E4%B8%8B%E7%9A%84cmd%E7%A5%9E%E5%99%A8-Cmder.html</url>
    <content type="text"><![CDATA[Cmder的安装cmder官网： http://cmder.net/Github：https://github.com/cmderdev/cmder 官网安装在官网上,我们可以看到Download模块，分为min版和full版，两者的区别在于：full版集成了msysgit工具，是Git for Windows的标准配置，除了git本身这个命令之外，里面还有大量的linux命令，比如 grep, curl(没有 wget)； 像vim, grep, tar, unzip, ssh, ls, bash, perl 对于爱折腾的Coder更是痛点需求。 将下载的压缩包解压到你想放置的目录。 点击Cmder.exe即可运行。 Cmder配置及相关设置乱码和文字重叠当我们使用ls命令查看文件目录时，发现，中文被显示成了一些奇怪的乱码，将以下几行代码配置在cmder/config/user-aliases下即可解决问题:1234l=ls --show-control-charsla=ls -aF --show-control-charsll=ls -alF --show-control-charsls=ls --show-control-chars -F 如果进行了以上配置还存在乱码问题时，还能尝试进行如下配置： 启动Cmder前文已经说过，Cmder无需安装，解压即可运行。Cmder点击Cmder.exe即可运行，显然，这样打开是非常不方便的，所以，我们可以进行如下配置： 将cmder添加入环境变量将cmder.exe所在的目录添加至系统环境变量。添加完之后，使用win+r输入cmder即可运行Cmder。右键点击我的电脑---&gt;属性,然后如下图所示进行配置即可： 添加cmser至右键菜单能不能将cmder添加到右键，让我们可以在任意文件目录下打开cmder呢？如果能这样使用那么简直是不能太赞了！！答案是完全可以的，因为在上一步骤我们已经将cmder加入了环境变量，所以我们只需要进行如下配置即可： 12// 以系统管理员权限打开cmd窗口，输入以下代码，回车即可。Cmder.exe /REGISTER ALL 默认开启设置作为强大的存在，必然支持私人定制。输入win + alt + p 或者 在底部右击点击 settings, 进入设置页面；可以根据自己的所需进行各种配置(字体，皮肤等等等等)。 目前游走在前端，Gulp已离不开，Cmder+PowerShell这个组合无疑是运行gulp的利器。如下图所示，可以设置PowerShell作为默认开启的选项；也可以更改默认开启是所在目录。 Cmder常用功能介绍Cmder功能非常强大，也有许多功能： Cmder常用快捷键 Tab：自动路径补全 ctrl+T:建立新页签 ctrl+W：关闭页签 ctrl+tab：切换页签 alt_f4:关闭所有页签 alt+shift+1:开启cmd.exe alt+shift+2:开启powershell.exe alt+shift+3:开启powershell.exe（系统管理员权限） ctrl+1:快速切换到第一个页签 ctrl+n:快速切换到第n个页签 alt+enter:切换到全屏状态 ctrl+r:历史命令搜索 可在视窗内搜寻画面上曾经出现过的任意字 新增页签按钮，可透过滑鼠新增页签 切换页签按钮，可透过滑鼠切换页签 锁定视窗，让视窗无法再输入 切换视窗是否提供卷轴功能，启动时可查询之前显示过的内容 按下滑鼠左键可开启系统菜单，滑鼠右键可开启工具选项视窗，win+alt+p开启工具选项视窗。 cmder元件组成Cmder集成了多套软体，其中最重要的是msysgit、ConEmu、Clink。 msysgit除了提供git for windows相关工具之外，还提供了多套Unix/linux环境下常用的指令工具，例如：less、ls、tar、grep等。 ConEmu体验不如cmder Clink将GNU Readline 函式库整合进原生的Windows 命令提示字元视窗，提供命令列模式下强大的编辑与输入能力，这也是用了cmder 之后会这么像在Linux 环境下使用的感觉。 Chocolatey软件包管理系统在 Linux 下，大家喜欢用apt-get(mac下用brew)来安装应用程序，如今在 windows 下，大家可以使用Chocolatey来快速下载搭建一个开发环境。Chocolatey的哲学就是完全用命令行来安装应用程序， 它更像一个包管理工具（背后使用Nuget）另外需要说明的是，Chocolatey只是把官方下载路径封装到了Chocolatey中，所以下载源都是其官方路径，所以下载的一定是合法的，但是如果原软件是需要 Licence 注册的话，那么Chocolatey下载安装好的软件还是需要你去购买注册。不过Chocolatey一般还是会选用免费 Licence 可用的软件。 安装chocolatey , 运行如下命令即可：1@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin 安装软件命令choco install softwareName, 短写是cinst softwareName可安装的应用程序，可以参见其 Package列表以下是window下开发常用的开发环境应用:123456789101112choco install autohotkey.portable #安装 AutoHotkey (Portable)choco install nodejs.install #安装 nodechoco install git.install #安装 gitchoco install ruby #安装 rubychoco install python #安装 pythonchoco install jdk8 #安装 JDK8choco install googlechrome #安装 Chromechoco install google-chrome-x64 #Google Chrome (64-bit only)choco install firefox #安装 firefoxchoco install notepadplusplus.install #安装 notepad++choco install Atom #安装 Atomchoco install SublimeText3 #安装 SublimeText3 其他功能 Cmder还增加了alias功能;他让你用短短的指令执行一些常见但指令超长又难以记忆的语法;比如 ls cls等等；在其控制台输入alias可以查看。 主控台文字自动放大缩小功能，你只要按下Ctrl+滑鼠滚轮就可以办到;果你用支援两点触控的笔电，也可以在触控板上用两指放大的手势调整文字大小。还有：up，向上翻历史命令; Cmder有极为简单的复制粘贴操作。Ctr+V直接粘贴;用鼠标选中你想拷贝的内容，自动就复制到剪切板；天神，这悉数的美感;点赞! 自定义aliases:打开Cmder目录下的config文件夹，里面的aliases文件就是我们可以配置的别名文件，只需将里面ls命令的别名按下列方式修改就可以在ls命令下显示中文。]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>cmder</tag>
        <tag>cmd.linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下jdk环境变量的配置]]></title>
    <url>%2Fubuntu%E4%B8%8Bjdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[Linux下jdk环境变量的配置PS:博主的系统版本是 ubuntu kylin 15.10。 下载、及安装 下载:http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 下载完成之后就是解压了： 进入到文件目录下执行该指令sudo tar zxvf ./jdk-8u65-linux-x64.tar.gz 安装完成之后就是配置环境变量啦2.1 打开/etc/profile文件：sudo gedit /etc/profile2.2 添加如下环境变量123456789#set java environment export JAVA_HOME=/usr/local/java/jdk版本 export JRE_HOME=/usr/local/java/jdk版本/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH 2.3 使得修改生效：一种是使用重启的方式使得修改生效，另一种则是使用source /etc/profile也可以使修改生效。 输入java -version测试是否配置成功。3.1 出现以下代码表示配置成功： 1234lucas@lucas-ThinkPad-PC:~/java$ java -versionjava version &quot;1.8.0_65&quot;Java(TM) SE Runtime Environment (build 1.8.0_65-b17)Java HotSpot(TM) 64-Bit Server VM (build 25.65-b01, mixed mode) 3.2 如出现如下代码：1234567程序 &apos;java&apos; 已包含在下列软件包中： * default-jre * gcj-4.6-jre-headless * gcj-4.7-jre-headless * openjdk-7-jre-headless * openjdk-6-jre-headless请尝试：sudo apt-get install &lt;选定的软件包&gt; 则可以通过以下方式来解决： 在终端输入如下命令：1234// 这里是输入你的jdk安装目录以及版本号，具体的根据自己的设置去配。sudo update-alternatives --install /usr/bin/java java /home/lester/develop/jdk1.6.0_37/bin/java 300sudo update-alternatives --install /usr/bin/javac javac /home/lester/develop/jdk1.6.0_37/bin/javac 300 在配置完以上信息之后，再去java -version 进行测试。就能看到成功配置的信息啦！～ 好了，初次接触linux下的开发，确实会遇到许多的问题，博主会将这些常见的问题一一记录下来，以便自己查看，也为了让其他和我一样刚入门的新手一些参考。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>java环境变量</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下Apache2服务器的搭建]]></title>
    <url>%2FUbuntu%E4%B8%8BApache2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[Apache服务器的下载与安装博主选择的是使用apt-get开发包打包的方式安装的。下面是安装步骤： 安装apache，在命令行终端中输入以下命令： 1$ sudo apt-get install apache2 如果网络连接正常的话，应该是会顺利安装好的，在安装完成之后，需要重启apache服务，在命令行终端中输入如下命令： 1234$ sudo /etc/init.d/apache2 restart``` &gt; 如果重启之后出现如下提示，则表示服务器已经启动成功了。 lucas@lucas-ThinkPad-PC:~$ sudo /etc/init.d/apache2 restart[ ok ] Restarting apache2 (via systemctl): apache2.service.``` 可能出现的问题1： NameVirtualHost * :80 has no VirtualHost. 出现上述问题的原因：定义了多个NameVirtualHost，我们只需要将/etc/apahce2/ports.conf 中的NameVirtualHost * :80注释掉即可。 可能出现的问题2： Could not reliably determine the server’s fully qualified domain name, using 127.0.1.1 for ServerName 原因：根据提示，无法可靠的确定服务器的有效域名，使用127.0.1.1作为服务器域名。因此在下面的测试中，应该使用127.0.1.1，而不是127.0.0.1。 解决方法：终端输入vim /etc/apache2/httpd.conf，在文件中添加ServerName localhost:80 ，再次restart apache2,就可以使用127.0.0.1来访问web服务器了。 Apache服务器的测试既然已经安装好了，name我们当然应该测试一下了。 在浏览器中输入http://localhost或者http://127.0.0.1，如果看到了It works，那么就说明服务器成功安装了。Apache的默认安装，会在var/www/的目录，这个就是我们的web目录了，所有需要能够浏览器访问的web文件都要放在这个目录里。 下面是楼主的测试结果： PS:好了。至此Ubuntu下Apache服务器的安装就已经完成，下面的文章中，我将继续Apache服务器配置文件的详解。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Apache2</tag>
        <tag>服务器</tag>
        <tag>ubuntu</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bower:Additional error details:Name must be lowercase, can contain digits, dots, dashes, "@" or spaces]]></title>
    <url>%2Fbower%20error.html</url>
    <content type="text"><![CDATA[在运行bower install安装第三方JS的时候，遇到以下错误提示： 12345E:\nginx-1.10.2\html\parkhero2.0\master&gt;bower installbower EINVALID Failed to read E:\nginx-1.10.2\html\parkhero2.0\master\bower.jsonAdditional error details:Name must be lowercase, can contain digits, dots, dashes, "@" or spaces 看到这个错误有点懵比，因为一直是可以正常运行的，突然遇到这个错误，然后去检查了一下bower.json文件，发现错误的原因是：12"name": "Park", // 错误就在这里，上面提示了name必须小写，可以包含数字、点、破折号、@和空格"version": "2.0.0", 好吧，至此问题就解决了。12&quot;name&quot;: &quot;park&quot;, // 改成小写&quot;version&quot;: &quot;2.0.0&quot;, 修改完之后运行bower install,正常运行了。这是个小错误，记录一下。]]></content>
      <categories>
        <category>错误收集</category>
      </categories>
      <tags>
        <tag>Bower</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Crypto-JS进行加密，以及使用angular的方式进行封装调用]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Crypto-JS%E8%BF%9B%E8%A1%8CAES%E5%8A%A0%E5%AF%86.html</url>
    <content type="text"><![CDATA[## 使用Crypto-JS进行AES加密 在最近的项目中，调用登录接口，需要对账号密码数据进行AES加密后再进行传输，使用的是AES/ECB/PKCS5Padding,我前端部分使用选择了CryptoJS,现在把使用的过程记录如下。 需要注意的点 Crypto-JS的encrypt函数不会返回字符串，需要调用对象的toString方法，或者通过Crypto-js转码才能得到真实的结果。 使用步骤 引入Crypto-JS中的 aes.js及相关模块 1234&quot;bower_components/cryptojs/aes.js&quot;,&quot;bower_components/cryptojs/enc-utf8.js&quot;,&quot;bower_components/cryptojs/pad-pkcs7.js&quot;,&quot;bower_components/cryptojs/mode-ecb.js&quot; 调用CryptoJS.AES 12345678910111213141516// 官方示例, 每次输出的密文都不一样,这样使用的话是错误的CryptoJS.AES.encrypt("Message", "Secret Passphrase");/* 正确的使用姿势！！ */// 使用用户名进行MD5，32位，作为keyvar key_str = md5.createHash(username);// 将key转换成128 bitvar key = CryptoJS.enc.Utf8.parse(key_str);// 对password进行AES加密var AESPass = CryptoJS.AES.encrypt(password, key, &#123; mode: CryptoJS.mode.ECB, //补齐方式 CBC,ECB,etc. padding: CryptoJS.pad.Pkcs7 // 偏移规则设定 pack5，pkcs7，nopadding,etc.&#125;);// CryptoJS 的 encrypt函数不会直接返回字符串，需要toString或者Crypto-JS进行转码才能得到真实的结果。var pass = AESPass.toString();var authData = Base64.encode(username + ':' + pass).replace(/[\r\n]/g, ''); // 去除回车换行符 使用AngularJS的方式调用CryptoJS.AES 使用Angular将AES封装成一个provider 提供两种方式设置key 12345// 1. 一种为在angular.module('xxxx').config中进行设置，此种方式适用于key为一个固定值的情况 CryptoKeyProvider.setCryptofraphyKey('key') // 在config中设置key $crypto.encrypto('plaintext') // 在业务逻辑处直接传入需要加密的明文进行调用// 2. 第二种方式,每次都设置不同的key $crypto.encrypto('plaintext','key') 具体源码如下： 注意：解密时，需要先将密文转换成Base64的编码的格式。 使用CryptoJS.enc.Hex.parse转换成十六进制 使用CryptoJS.enc.Base64.stringify将其变成Base64编码的字符串 最后才能传入CryptoJS.AES.decrypt方法对其解密]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>AES</tag>
        <tag>Web开发</tag>
        <tag>CryptoJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基本常识]]></title>
    <url>%2Fpython%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86.html</url>
    <content type="text"><![CDATA[Python的语法格式Python是一种计算机编程语言，有着自己的一套语法格式。Python的语法格式非常简单，采用缩进的方式： 123456# print absolute value of an integer:a = 100if a &gt;= 0: print(a)else: print(-a) 以#开头的语句是注释，解释器会自动忽略。 当语句以：结束时，缩进的语句视为代码块。 缩进有利有弊，好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是tab。按照约定俗成的习惯，应该使用4个空格的缩进。缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把很长的一段代码拆分成若干函数，从而得到缩进较少的代码。缩进的坏处就是“复制-粘贴”功能失效了，当我们重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像Java代码那样格式化Python代码。 Python程序是大小写敏感的，如果写错了大小写，程序会报错。 Python的数据类型在Python中，能够直接处理的数据类型有以下几种： 整数Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 浮点数浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。 字符串字符串是以单引号’或双引号”括起来的任意文本，比如&#39;abc&#39;，&quot;xyz&quot;等等。请注意，&#39;&#39;或&quot;&quot;本身只是一种表示方式，不是字符串的一部分，因此，字符串&#39;abc&#39;只有a，b，c这3个字符。如果&#39;本身也是一个字符，那就可以用&quot;&quot;括起来，比如&quot;I&#39;m OK&quot;包含的字符是I，&#39;，m，空格，O，K这6个字符。 如果字符串内部既包含&#39;又包含”怎么办？可以用转义字符\来标识，比如：1'I\'m \"OK\"!' 表示的字符串内容是：1I'm "OK"! 转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：12345678&gt;&gt;&gt; print('I\'m ok.')I'm ok.&gt;&gt;&gt; print('I\'m learning\nPython.')I'm learningPython.&gt;&gt;&gt; print('\\\n\\')\\ 如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r&#39;&#39;表示&#39;&#39;内部的字符串默认不转义，可以自己试试：1234&gt;&gt;&gt; print('\\\t\\')\ \&gt;&gt;&gt; print(r'\\\t\\')\\\t\\ 如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&#39;&#39;&#39;...&#39;&#39;&#39;的格式表示多行内容，可以自己试试：123456&gt;&gt;&gt; print('''line1... line2... line3''')line1line2line3 上面是在交互式命令行内输入，注意在输入多行内容时，提示符由&gt;&gt;&gt;变为...，提示你可以接着上一行输入。如果写成程序，就是：123print('''line1line2line3''') 多行字符串&#39;&#39;&#39;...&#39;&#39;&#39;还可以在前面加上r使用，请自行测试。 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：12345678&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse&gt;&gt;&gt; 3 &gt; 2True&gt;&gt;&gt; 3 &gt; 5False 布尔值可以用and、or和not运算。 and运算是与运算，只有所有都为True，and运算结果才是True：12345678&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; False and FalseFalse&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1True or运算是或运算，只要其中有一个为True，or运算结果就是True：12345678&gt;&gt;&gt; True or TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; False or FalseFalse&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3True not运算是非运算，它是一个单目运算符，把True变成False，False变成True：123456&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not FalseTrue&gt;&gt;&gt; not 1 &gt; 2True 布尔值经常用在条件判断中，比如：1234if age &gt;= 18: print('adult')else: print('teenager') 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。 变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：1a = 1 变量a是一个整数。1t_007 = &apos;T007&apos; 变量t_007是一个字符串。1Answer = True 变量Answer是一个布尔值True。 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如： 1234a = 123 # a是整数print(a)a = &apos;ABC&apos; # a变为字符串print(a) 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）： 12int a = 123; // a是整数类型变量a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量 和静态语言相比，动态语言更灵活，就是这个原因。 请不要把赋值语句的等号等同于数学的等号。比如下面的代码： 12x = 10x = x + 2 如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。 最后，理解变量在计算机内存中的表示也非常重要。当我们写： 1a = &apos;ABC&apos; 时，Python解释器干了两件事情： 在内存中创建了一个’ABC’的字符串； 在内存中创建了一个名为a的变量，并把它指向’ABC’。 也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码： 1234a = &apos;ABC&apos;b = aa = &apos;XYZ&apos;print(b) 常量所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量： 1PI = 3.14159265359 但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。 最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/： 12&gt;&gt;&gt; 10 / 33.3333333333333335 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： 12&gt;&gt;&gt; 9 / 33.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数： 12&gt;&gt;&gt; 10 // 33 你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。 因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数： 12&gt;&gt;&gt; 10 % 31 无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。 字符串和编码在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如： 12&gt;&gt;&gt; print(&apos;包含中文的str&apos;)包含中文的str 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符： 12345678&gt;&gt;&gt; ord(&apos;A&apos;)65&gt;&gt;&gt; ord(&apos;中&apos;)20013&gt;&gt;&gt; chr(66)&apos;B&apos;&gt;&gt;&gt; chr(25991)&apos;文&apos; 如果知道字符的整数编码，还可以用十六进制这么写str： 12&gt;&gt;&gt; &apos;\u4e2d\u6587&apos;&apos;中文&apos; 两种写法完全是等价的。 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示： 1x = b&apos;ABC&apos; 要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如： 12345678&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)b&apos;ABC&apos;&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。 在bytes中，无法显示为ASCII字符的字节，用\x##显示。 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法： 1234&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)&apos;ABC&apos;&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)&apos;中文&apos; 要计算str包含多少个字符，可以用len()函数： 1234&gt;&gt;&gt; len(&apos;ABC&apos;)3&gt;&gt;&gt; len(&apos;中文&apos;)2 len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数： 123456&gt;&gt;&gt; len(b&apos;ABC&apos;)3&gt;&gt;&gt; len(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)6&gt;&gt;&gt; len(&apos;中文&apos;.encode(&apos;utf-8&apos;))6 可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。 在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码.如果.py文件本身使用UTF-8编码，并且也申明了# -- coding: utf-8 --，打开命令提示符测试就可以正常显示中文。 ##格式化 最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似’亲爱的xxx你好！你xx月的话费是xx，余额是xx’之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。 1py-str-format 在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下： 1234&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;&apos;Hello, world&apos;&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)&apos;Hi, Michael, you have $1000000.&apos; 你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。 常见的占位符有： 1234%d 整数%f 浮点数%s 字符串%x 十六进制整数 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数： 1234&gt;&gt;&gt; &apos;%2d-%02d&apos; % (3, 1)&apos; 3-01&apos;&gt;&gt;&gt; &apos;%.2f&apos; % 3.1415926&apos;3.14&apos; 如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串： 12&gt;&gt;&gt; &apos;Age: %s. Gender: %s&apos; % (25, True)&apos;Age: 25. Gender: True&apos; 有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%： 12&gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7&apos;growth rate: 7 %&apos;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发中乱码问题的解决]]></title>
    <url>%2Fweb%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3.html</url>
    <content type="text"><![CDATA[web开发中乱码问题的解决由于楼主刚刚接触web不久，自然而然的就遇到了乱码问题。下面就记录一下乱码问题的解决。 表单的提交分为GET和POST两种请求方式。两种方式的乱码解决又不一样，用post提交请求时，只需要在接受的时候加上request.setCharacterEncoding(&quot;utf-8&quot;); 而GET的请求方法在处理时，应该将接收过来的值打碎成 ISO-8859-1编码，然后再组装成utf-8:new String(request.getParameter(param).getBytes(&quot;iso-8859-1&quot;),&quot;UTF-8&quot;); 过滤器的乱码处理问题 如果每次接收都像上面那样去处理的话肯定是太麻烦了，用过滤器来处理请求的乱码问题很方便，只需要写一个过滤器，就可以过滤所有请求页面的乱码问题了。至于如何用过滤器处理乱码请参考用过滤器来解决JSP中的乱码问题。不过值得注意的是，如果使用Struts的话，在web.xml里面处理编码的过滤器必须在struts过滤器前面注册，否则所有页面都不会经过过滤器。 AJAX请求的乱码问题 如果使用ajax出现了乱码问题这样解决：前端ajax函数的请求的url里面中文参数用两个encodeURI()函数处理，var url=&quot;user.do?p=checkUser&amp;name=&quot;+encodingURI(encodingURI(username.value))&quot;而服务器端则用 URLDecoder.decode()函数去接收，string userName = URLDecoder.decode(request.getParameter(&quot;name&quot;),&quot;utf-8&quot;); 这样就能够解决ajax请求中乱码的问题了。 PS:以上几条是摘自网上的。我暂时还没遇到。 在我的项目中，遇到的问题是发送get请求时出现乱码，导致这个问题的原因是，我在web.xml 文件中之配置了针对post请求的编码设置，但是tomcat对POST和GET请求的处理方式是不一样的，我们要针对GET请求出现乱码问题的解决，就需要修改tomcat下的server.xml文件，如下所示：将原来的配置：1&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 改为：1&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; useBodyEncodingForURI=&quot;true&quot;/&gt; 然而，如果你修改的是tomcat安装目录下的server.xml文件的话，那么你在eclipse当中运行项目时会发现配置并没有起作用，这是因为eclipse在运行时用的是eclipse当中配置的tomact，所以我们需要打开左侧项目列表server文件夹--&gt;tomcat--&gt;server.xml按照以上的方式做同样的修改. ！这里需要注意的是：配置useBodyEncodingForURI=&quot;true&quot;后，可以解决普通get请求的中文乱码问题，但是对于通过ajax发起的get请求中文依然会乱码，请把useBodyEncodingForURI=&quot;true&quot;改为URIEncoding=&quot;UTF-8&quot;即可。 然而经过了以上的设置之后，博主的乱码问题依然没有解决，如下图所示： 在建立一条新数据之后，显示出来的是一串的？？？？。好吧，这时候自然而然的想到了数据库的编码问题了。于是， 1234567891011121314sudo /ect/init.d/mysql startmysql&gt; show variables like &quot;%char%&quot;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+ 根据上面的显示我们可以发现character-set-server和character-set-database的编码是latin1，所以，接下来我就要将其修改为utf8了。 12345// 1. 打开mysql的配置文件，ubuntu下是my.cnflucas@lucas-ThinkPad-PC:~$ sudo vim /etc/mysql/my.cnf// 2. 在配置文件中加入以下一句character-set-server=utf8 // 自己根据对应的需要修改的在对应的节点下添加。// 3. 这样问题就解决了。 我是使用命令行进行修改的： 12345678910111213141516171819202122232425262728293031323334353637lucas@lucas-ThinkPad-PC:~$ suroot@lucas-ThinkPad-PC:/home/lucas# mysql -u root -pmysql&gt; set character_set_client=utf8;Query OK, 0 rows affected (0.00 sec)mysql&gt; set character_set_connection=utf8;Query OK, 0 rows affected (0.00 sec)mysql&gt; set character_set_database=utf8;Query OK, 0 rows affected (0.00 sec)mysql&gt; set character_set_results=utf8;Query OK, 0 rows affected (0.00 sec)mysql&gt; set character_set_server=utf8;Query OK, 0 rows affected (0.00 sec)mysql&gt; set character_set_system=utf8;Query OK, 0 rows affected (0.01 sec)mysql&gt; set collation_connection=utf8;Query OK, 0 rows affected (0.01 sec)mysql&gt; set collation_database=utf8;Query OK, 0 rows affected (0.01 sec)mysql&gt; set collation_server=utf8;Query OK, 0 rows affected (0.01 sec)mysql&gt; show variables like &apos;character_set_%&apos;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec)// 经过一番折腾之后，修改完毕，重启数据库，再运行一下项目，发现添加数据再也没有乱码了。 当然，除此之外，还有一些乱码的问题，例如浏览器的默认编码啊什么的。这些直接设置一下浏览器的编码就行了。还有许多我暂时还没接触到的。等博主接触到了再加上去吧。继续上班。。。。]]></content>
      <categories>
        <category>错误收集</category>
      </categories>
      <tags>
        <tag>utf-8</tag>
        <tag>编码</tag>
        <tag>乱码</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven加入json-lib.jar报错Missing artifact net.sf.json-lib:json-lib:jar:2.4:compile]]></title>
    <url>%2Fmaven%E5%8A%A0%E5%85%A5json-lib-jar%E6%8A%A5%E9%94%99Missing-artifact-net-sf-json-lib-json-lib-jar-2-4-compile.html</url>
    <content type="text"><![CDATA[在pom.xml文件中添加json-lib： 12345&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 出现错误： Missing artifact net.sf.json-lib:json-lib:jar:2.4:compile 出现错误的原因：json-lib是区分jdk版本的，pom.xml中的配置应该加上标签classifiter指定jdk版本: 1234567&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;!-- 加上jdk版本,如jdk15 --&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt;&lt;/dependency&gt; 这样，错误就解决了。]]></content>
      <categories>
        <category>错误收集</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volley 源码解析]]></title>
    <url>%2Fvolley-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[2015年11月24日 05:45:10转自：https://github.com/android-cn/android-open-project-analysis/tree/master/volley Volley 源码解析==================================== ###1. 功能介绍 ####1.1. VolleyVolley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。 名字由来：a burst or emission of many things or a large amount at once发布演讲时候的配图 从名字由来和配图中无数急促的火箭可以看出 Volley 的特点：特别适合数据量小，通信频繁的网络操作。（个人认为 Android 应用中绝大多数的网络操作都属于这种类型）。 ####1.2 Volley 的主要特点(1). 扩展性强。Volley 中大多是基于接口的设计，可配置性强。(2). 一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。(3). 默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现，这两者的区别及优劣在4.2.1 Volley中具体介绍。(4). 提供简便的图片加载工具。 ###2. 总体设计 ####2.1 总体设计图上面是 Volley 的总体设计图，主要是通过两种Dispatch Thread不断从RequestQueue中取出请求，根据是否已缓存调用Cache或Network这两类数据获取接口之一，从内存缓存或是服务器取得请求的数据，然后交由ResponseDelivery去做结果分发及回调处理。 ####2.2 Volley 中的概念简单介绍一些概念，在详细设计中会仔细介绍。Volley 的调用比较简单，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue后，只需要往这个RequestQueue不断 add Request 即可。 Volley：Volley 对外暴露的 API，通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue。 Request：表示一个请求的抽象类。StringRequest、JsonRequest、ImageRequest 都是它的子类，表示某种类型的请求。 RequestQueue：表示请求队列，里面包含一个CacheDispatcher(用于处理走缓存请求的调度线程)、NetworkDispatcher数组(用于处理走网络请求的调度线程)，一个ResponseDelivery(返回结果分发接口)，通过 start() 函数启动时会启动CacheDispatcher和NetworkDispatchers。 CacheDispatcher：一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。 NetworkDispatcher：一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理，并判断结果是否要进行缓存。 ResponseDelivery：返回结果分发接口，目前只有基于ExecutorDelivery的在入参 handler 对应线程内进行分发。 HttpStack：处理 Http 请求，返回请求结果。目前 Volley 中有基于 HttpURLConnection 的HurlStack和 基于 Apache HttpClient 的HttpClientStack。 Network：调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。 Cache：缓存请求结果，Volley 默认使用的是基于 sdcard 的DiskBasedCache。NetworkDispatcher得到请求结果后判断是否需要存储在 Cache，CacheDispatcher会从 Cache 中取缓存结果。 ###3. 流程图Volley 请求流程图 上图是 Volley 请求时的流程图，在 Volley 的发布演讲中给出，我在这里将其用中文重新画出。 ###4. 详细设计 ####4.1 类关系图这是 Volley 框架的主要类关系图 图中红色圈内的部分，组成了 Volley 框架的核心，围绕 RequestQueue 类，将各个功能点以组合的方式结合在了一起。各个功能点也都是以接口或者抽象类的形式提供。红色圈外面的部分，在 Volley 源码中放在了 toolbox 包中，作为 Volley 为各个功能点提供的默认的具体实现。通过类图我们看出， Volley 有着非常好的拓展性。通过各个功能点的接口，我们可以给出自定义的，更符合我们需求的具体实现。 多用组合，少用继承；针对接口编程，不针对具体实现编程。 优秀框架的设计，令人叫绝，受益良多。 ###4.2 核心类功能介绍 ####4.2.1 Volley.java这个和 Volley 框架同名的类，其实是个工具类，作用是构建一个可用于添加网络请求的RequestQueue对象。(1). 主要函数Volley.java 有两个重载的静态方法。123public static RequestQueue newRequestQueue(Context context)public static RequestQueue newRequestQueue(Context context, HttpStack stack) 第一个方法的实现调用了第二个方法，传 HttpStack 参数为 null。第二个方法中，如果 HttpStatck 参数为 null，则如果系统在 Gingerbread 及之后(即 API Level &gt;= 9)，采用基于 HttpURLConnection 的 HurlStack，如果小于 9，采用基于 HttpClient 的 HttpClientStack。1234567if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; stack = new HurlStack(); &#125; else &#123; stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); &#125;&#125; 得到了 HttpStack,然后通过它构造一个代表网络（Network）的具体实现BasicNetwork。接着构造一个代表缓存（Cache）的基于 Disk 的具体实现DiskBasedCache。最后将网络（Network）对象和缓存（Cache）对象传入构建一个 RequestQueue，启动这个 RequestQueue，并返回。1234Network network = new BasicNetwork(stack);RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);queue.start();return queue; 我们平时大多采用Volly.newRequestQueue(context)的默认实现，构建 RequestQueue。通过源码可以看出，我们可以抛开 Volley 工具类构建自定义的 RequestQueue，采用自定义的HttpStatck，采用自定义的Network实现，采用自定义的 Cache 实现等来构建RequestQueue。优秀框架的高可拓展性的魅力来源于此啊 (2). HttpURLConnection 和 AndroidHttpClient(HttpClient 的封装)如何选择及原因：在 Froyo(2.2) 之前，HttpURLConnection 有个重大 Bug，调用 close() 函数会影响连接池，导致连接复用失效，所以在 Froyo 之前使用 HttpURLConnection 需要关闭 keepAlive。另外在 Gingerbread(2.3) HttpURLConnection 默认开启了 gzip 压缩，提高了 HTTPS 的性能，Ice Cream Sandwich(4.0) HttpURLConnection 支持了请求结果缓存。再加上 HttpURLConnection 本身 API 相对简单，所以对 Android 来说，在 2.3 之后建议使用 HttpURLConnection，之前建议使用 AndroidHttpClient。 (3). 关于 User Agent通过代码我们发现如果是使用 AndroidHttpClient，Volley 还会将请求头中的 User-Agent 字段设置为 App 的 ${packageName}/${versionCode}，如果异常则使用 “volley/0”，不过这个获取 User-Agent 的操作应该放到 if else 内部更合适。而对于 HttpURLConnection 却没有任何操作，为什么呢？如果用 Fiddler 或 Charles 对数据抓包我们会发现，我们会发现 HttpURLConnection 默认是有 User-Agent 的，类似：1Dalvik/1.6.0 (Linux; U; Android 4.1.1; Google Nexus 4 - 4.1.1 - API 16 - 768x1280_1 Build/JRO03S) 经常用 WebView 的同学会也许会发现似曾相识，是的，WebView 默认的 User-Agent 也是这个。实际在请求发出之前，会检测 User-Agent 是否为空，如果不为空，则加上系统默认 User-Agent。在 Android 2.1 之后，我们可以通过1String userAgent = System.getProperty("http.agent"); 得到系统默认的 User-Agent，Volley 如果希望自定义 User-Agent，可在自定义 Request 中重写 getHeaders() 函数1234567891011121314151617@Overridepublic Map&lt;String, String&gt; getHeaders() throws AuthFailureError &#123; // self-defined user agent Map&lt;String, String&gt; headerMap = new HashMap&lt;String, String&gt;(); headerMap.put("User-Agent", "android-open-project-analysis/1.0"); return headerMap;&#125;``` ####4.2.2 Request.java代表一个网络请求的抽象类。我们通过构建一个`Request`类的非抽象子类(StringRequest、JsonRequest、ImageRequest 或自定义)对象，并将其加入到·RequestQueue·中来完成一次网络请求操作。 Volley 支持 8 种 Http 请求方式 **GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE, PATCH** Request 类中包含了请求 url，请求请求方式，请求 Header，请求 Body，请求的优先级等信息。 **因为是抽象类，子类必须重写的两个方法。** ```javaabstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response); 子类重写此方法，将网络返回的原生字节内容，转换成合适的类型。此方法会在工作线程中被调用。 1abstract protected void deliverResponse(T response); 子类重写此方法，将解析成合适类型的内容传递给它们的监听回调。 以下两个方法也经常会被重写1public byte[] getBody() 重写此方法，可以构建用于 POST、PUT、PATCH 请求方式的 Body 内容。1protected Map&lt;String, String&gt; getParams() 在上面getBody函数没有被重写情况下，此方法的返回值会被 key、value 分别编码后拼装起来转换为字节码作为 Body 内容。 ####4.2.3 RequestQueue.javaVolley 框架的核心类，将请求 Request 加入到一个运行的RequestQueue中，来完成请求操作。 ####(1). 主要成员变量RequestQueue 中维护了两个基于优先级的 Request 队列，缓存请求队列和网络请求队列。放在缓存请求队列中的 Request，将通过缓存获取数据；放在网络请求队列中的 Request，将通过网络获取数据。12private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue = new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;(); 维护了一个正在进行中，尚未完成的请求集合。1private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;(); 维护了一个等待请求的集合，如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列。1private final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = new HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;(); ####(2). 启动队列创建出 RequestQueue 以后，调用 start 方法，启动队列。 1234567891011121314151617/** * Starts the dispatchers in this queue. */public void start() &#123; stop(); // Make sure any currently running dispatchers are stopped. // Create the cache dispatcher and start it. mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // Create network dispatchers (and corresponding threads) up to the pool size. for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125;&#125; start 方法中，开启一个缓存调度线程CacheDispatcher和 n 个网络调度线程NetworkDispatcher，这里 n 默认为 4，存在优化的余地，比如可以根据 CPU 核数以及网络类型计算更合适的并发数。缓存调度线程不断的从缓存请求队列中取出 Request 去处理，网络调度线程不断的从网络请求队列中取出 Request 去处理。 ####(3). 加入请求1public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request); 流程图如下： ####(4). 请求完成1void finish(Request&lt;?&gt; request) Request 请求结束 (1). 首先从正在进行中请求集合mCurrentRequests中移除该请求。(2). 然后查找请求等待集合mWaitingRequests中是否存在等待的请求，如果存在，则将等待队列移除，并将等待队列所有的请求添加到缓存请求队列中，让缓存请求处理线程CacheDispatcher自动处理。 ####(5). 请求取消12public void cancelAll(RequestFilter filter)public void cancelAll(final Object tag) 取消当前请求集合中所有符合条件的请求。filter 参数表示可以按照自定义的过滤器过滤需要取消的请求。tag 表示按照Request.setTag设置好的 tag 取消请求，比如同属于某个 Activity 的。 ####4.2.4 CacheDispatcher.java一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery 去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。 ####(1). 成员变量BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue 缓存请求队列BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue 网络请求队列Cache mCache 缓存类，代表了一个可以获取请求结果，存储请求结果的缓存ResponseDelivery mDelivery 请求结果传递类 ####(2). 处理流程图 ####4.2.5 NetworkDispatcher.java一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给 ResponseDelivery 去执行后续处理，并判断结果是否要进行缓存。 ####(1). 成员变量BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue 网络请求队列Network mNetwork 网络类，代表了一个可以执行请求的网络Cache mCache 缓存类，代表了一个可以获取请求结果，存储请求结果的缓存ResponseDelivery mDelivery 请求结果传递类，可以传递请求的结果或者错误到调用者 ####(2). 处理流程图 ####4.2.6 Cache.java缓存接口，代表了一个可以获取请求结果，存储请求结果的缓存。 ####(1). 主要方法：public Entry get(String key); 通过 key 获取请求的缓存实体public void put(String key, Entry entry); 存入一个请求的缓存实体public void remove(String key); 移除指定的缓存实体public void clear(); 清空缓存 ####(2). 代表缓存实体的内部类 Entry成员变量和方法byte[] data 请求返回的数据（Body 实体）String etag Http 响应首部中用于缓存新鲜度验证的 ETaglong serverDate Http 响应首部中的响应产生时间long ttl 缓存的过期时间long softTtl 缓存的新鲜时间Map&lt;String, String&gt; responseHeaders 响应的 Headersboolean isExpired() 判断缓存是否过期，过期缓存不能继续使用boolean refreshNeeded() 判断缓存是否新鲜，不新鲜的缓存需要发到服务端做新鲜度的检测 ####4.2.7 DiskBasedCache.java继承 Cache 类，基于 Disk 的缓存实现类。 ####(1). 主要方法：public synchronized void initialize() 初始化，扫描缓存目录得到所有缓存数据摘要信息放入内存。public synchronized Entry get(String key) 从缓存中得到数据。先从摘要信息中得到摘要信息，然后读取缓存数据文件得到内容。public synchronized void put(String key, Entry entry) 将数据存入缓存内。先检查缓存是否会满，会则先删除缓存中部分数据，然后再新建缓存文件。private void pruneIfNeeded(int neededSpace) 检查是否能再分配 neededSpace 字节的空间，如果不能则删除缓存中部分数据。public synchronized void clear() 清空缓存。public synchronized void remove(String key) 删除缓存中某个元素。 ####(2). CacheHeader 类CacheHeader 是缓存文件摘要信息，存储在缓存文件的头部，与上面的Cache.Entry相似。 ####4.2.8 NoCache.java继承 Cache 类，不做任何操作的缓存实现类，可将它作为构建RequestQueue的参数以实现一个不带缓存的请求队列。 ####4.2.9 Network.java代表网络的接口，处理网络请求。唯一的方法，用于执行特定请求。1public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError; ####4.2.10 NetworkResponse.javaNetwork中方法 performRequest 的返回值，Request的 parseNetworkResponse(…) 方法入参，是 Volley 中用于内部 Response 转换的一级。封装了网络请求响应的 StatusCode，Headers 和 Body 等。 ####(1). 成员变量int statusCode Http 响应状态码byte[] data Body 数据Map&lt;String, String&gt; headers 响应 Headersboolean notModified 表示是否为 304 响应long networkTimeMs 请求耗时 ####(2). Volley 的内部 Response 转换流程图从上到下表示从得到数据后一步步的处理，箭头旁的注释表示该步处理后的实体类。 ####4.2.11 BasicNetwork.java实现 Network，Volley 中默认的网络接口实现类。调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。主要实现了以下功能：(1). 利用 HttpStack 执行网络请求。(2). 如果 Request 中带有实体信息，如 Etag,Last-Modify 等，则进行缓存新鲜度的验证，并处理 304（Not Modify）响应。(3). 如果发生超时，认证失败等错误，进行重试操作，直到成功、抛出异常(不满足重试策略等)结束。 ####4.2.12 HttpStack.java用于处理 Http 请求，返回请求结果的接口。目前 Volley 中的实现有基于 HttpURLConnection 的 HurlStack 和 基于 Apache HttpClient 的 HttpClientStack。唯一方法，执行请求12public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError; 执行 Request 代表的请求，第二个参数表示发起请求之前，添加额外的请求 Headers。 ####4.2.13 HttpClientStack.java实现 HttpStack 接口，利用 Apache 的 HttpClient 进行各种请求方式的请求。基本就是 org.apache.http 包下面相关类的常见用法，不做详解，不过与下面 HttpURLConnection 做下对比就能发现 HttpURLConnection 的 API 相对简单的多。 ####4.2.14 HurlStack.java实现 HttpStack 接口，利用 Java 的 HttpURLConnection 进行各种请求方式的请求。 ####4.2.15 Response.java封装了经过解析后的数据，用于传输。并且有两个内部接口 Listener 和 ErrorListener 分别可表示请求失败和成功后的回调。Response 的构造函数被私有化，而通过两个函数名更易懂的静态方法构建对象。 ####4.2.16 ByteArrayPool.javabyte[] 的回收池，用于 byte[] 的回收再利用，减少了内存的分配和回收。主要通过一个元素长度从小到大排序的ArrayList作为 byte[] 的缓存，另有一个按使用时间先后排序的ArrayList属性用于缓存满时清理元素。1public synchronized void returnBuf(byte[] buf) 将用过的 byte[] 回收，根据 byte[] 长度按照从小到大的排序将 byte[] 插入到缓存中合适位置。1public synchronized byte[] getBuf(int len) 获取长度不小于 len 的 byte[]，遍历缓存，找出第一个长度大于传入参数len的 byte[]，并返回；如果最终没有合适的 byte[]，new 一个返回。1private synchronized void trim() 当缓存的 byte 超过预先设置的大小时，按照先进先出的顺序删除最早的 byte[]。 ####4.2.17 PoolingByteArrayOutputStream.java继承 ByteArrayOutputStream，原始 ByteArrayOutputStream 中用于接受写入 bytes 的 buf，每次空间不足时便会 new 更大容量的 byte[]，而 PoolingByteArrayOutputStream 使用了 ByteArrayPool 作为 Byte[] 缓存来减少这种操作，从而提高性能。 ####4.2.18 HttpHeaderParser.javaHttp header 的解析工具类，在 Volley 中主要作用是用于解析 Header 从而判断返回结果是否需要缓存，如果需要返回 Header 中相关信息。有三个方法1public static long parseDateAsEpoch(String dateStr) 解析时间，将 RFC1123 的时间格式，解析成 epoch 时间 1public static String parseCharset(Map&lt;String, String&gt; headers) 解析编码集，在 Content-Type 首部中获取编码集，如果没有找到，默认返回 ISO-8859-1 1public static Cache.Entry parseCacheHeaders(NetworkResponse response) 比较重要的方法，通过网络响应中的缓存控制 Header 和 Body 内容，构建缓存实体。如果 Header 的 Cache-Control 字段含有no-cache或no-store表示不缓存，返回 null。(1). 根据 Date 首部，获取响应生成时间(2). 根据 ETag 首部，获取响应实体标签(3). 根据 Cache－Control 和 Expires 首部，计算出缓存的过期时间，和缓存的新鲜度时间 两点需要说明下：1.没有处理Last-Modify首部，而是处理存储了Date首部，并在后续的新鲜度验证时，使用Date来构建If-Modified-Since。这与 Http 1.1 的语义有些违背。2.计算过期时间，Cache－Control 首部优先于 Expires 首部。 ####4.2.19 RetryPolicy.java重试策略接口有三个方法：1public int getCurrentTimeout(); 获取当前请求用时（用于 Log）1public int getCurrentRetryCount(); 获取已经重试的次数（用于 Log）1public void retry(VolleyError error) throws VolleyError; 确定是否重试，参数为这次异常的具体信息。在请求异常时此接口会被调用，可在此函数实现中抛出传入的异常表示停止重试。 ####4.2.20 DefaultRetryPolicy.java实现 RetryPolicy，Volley 默认的重试策略实现类。主要通过在 retry(…) 函数中判断重试次数是否达到上限确定是否继续重试。其中mCurrentRetryCount变量表示已经重试次数。mBackoffMultiplier表示每次重试之前的 timeout 该乘以的因子。mCurrentTimeoutMs变量表示当前重试的 timeout 时间，会以mBackoffMultiplier作为因子累计前几次重试的 timeout。 ####4.2.21 ResponseDelivery.java请求结果的传输接口，用于传递请求结果或者请求错误。有三个方法：1public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response); 此方法用于传递请求结果，request 和 response 参数分别表示请求信息和返回结果信息。1public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable); 此方法用于传递请求结果，并在完成传递后执行 Runnable。1public void postError(Request&lt;?&gt; request, VolleyError error); 此方法用于传输请求错误。 ####4.2.22 ExecutorDelivery.java请求结果传输接口具体实现类。在 Handler 对应线程中传输缓存调度线程或者网络调度线程中产生的请求结果或请求错误，会在请求成功的情况下调用 Request.deliverResponse(…) 函数，失败时调用 Request.deliverError(…) 函数。 ####4.2.23 StringRequest.java继承 Request 类,代表了一个返回值为 String 的请求。将网络返回的结果数据解析为 String 类型。通过构造函数的 listener 传参，支持请求成功后的 onResponse(…) 回调。 ####4.2.24 JsonRequest.java抽象类，继承自 Request，代表了 body 为 JSON 的请求。提供了构建 JSON 请求参数的方法。 ####4.2.25 JsonObjectRequest.java继承自 JsonRequest，将网络返回的结果数据解析为 JSONObject 类型。 ####4.2.26 JsonArrayRequest.java继承自 JsonRequest，将网络返回的结果数据解析为 JSONArray 类型。 ####4.2.27 ImageRequest.java继承 Request 类，代表了一个返回值为 Image 的请求。将网络返回的结果数据解析为 Bitmap 类型。可以设置图片的最大宽度和最大高度，并计算出合适尺寸返回。每次最多解析一张图片防止 OOM。 ####4.2.28 ImageLoader.java封装了 ImageRequst 的方便使用的图片加载工具类。 1.可以设置自定义的ImageCache，可以是内存缓存，也可以是 Disk 缓存，将获取的图片缓存起来，重复利用，减少请求。2.可以定义图片请求过程中显示的图片和请求失败后显示的图片。3.相同请求（相同地址，相同大小）只发送一个，可以避免重复请求。// TODO ####4.2.29 NetworkImageView.java利用 ImageLoader，可以加载网络图片的 ImageView有三个公开的方法：1public void setDefaultImageResId(int defaultImage) 设置默认图片，加载图片过程中显示。1public void setErrorImageResId(int errorImage) 设置错误图片，加载图片失败后显示。1public void setImageUrl(String url, ImageLoader imageLoader) 设置网络图片的 Url 和 ImageLoader，将利用这个 ImageLoader 去获取网络图片。 如果有新的图片加载请求，会把这个 ImageView 上旧的加载请求取消。 ####4.2.30 ClearCacheRequest.java用于人为清空 Http 缓存的请求。添加到 RequestQueue 后能很快执行，因为优先级很高，为Priority.IMMEDIATE。并且清空缓存的方法mCache.clear()写在了isCanceled()方法体中，能最早的得到执行。 ClearCacheRequest 的写法不敢苟同，目前看来唯一的好处就是可以将清空缓存操作也当做一个请求。而在isCanceled()中做清空操作本身就造成了歧义，不看源码没人知道在NetworkDispatcher run 方法循环的过程中，isCanceled()这个读操作竟然做了可能造成缓存被清空。只能跟源码的解释一样当做一个 Hack 操作。 ####4.2.31 Authenticator.java身份认证接口，用于基本认证或者摘要认证。这个类是 Volley 用于和身份验证打通的接口，比如 OAuth，不过目前的使用不是特别广泛和 Volley 的内部结合也不是特别紧密。 ####4.2.32 AndroidAuthenticator.java继承 Authenticator，基于 Android AccountManager 的认证交互实现类。 ####4.2.33 VolleyLog.javaVolley 的 Log 工具类。 ####4.2.34 VolleyError.javaVolley 中所有错误异常的父类，继承自 Exception，可通过此类设置和获取 NetworkResponse 或者请求的耗时。 ####4.2.35 AuthFailureError.java继承自 VolleyError，代表请求认证失败错误，如 RespondeCode 的 401 和 403。 ####4.2.36 NetworkError.java继承自 VolleyError，代表网络错误。 ####4.2.37 ParseError.java继承自 VolleyError，代表内容解析错误。 ####4.2.38 ServerError.java继承自 VolleyError，代表服务端错误。 ####4.2.39 TimeoutError.java继承自 VolleyError，代表请求超时错误。 ####4.2.40 NoConnectionError.java继承自 NetworkError，代表无法建立连接错误。 ###5. 杂谈 ####5.1 关于 Http 缓存Volley 构建了一套相对完整的符合 Http 语义的缓存机制。优点和特点(1). 根据Cache-Control和Expires首部来计算缓存的过期时间。如果两个首部都存在情况下，以Cache-Control为准。(2). 利用If-None-Match和If-Modified-Since对过期缓存或者不新鲜缓存，进行请求再验证，并处理 304 响应，更新缓存。(3). 默认的缓存实现，将缓存以文件的形式存储在 Disk，程序退出后不会丢失。 我个人认为的不足之处缓存的再验证方面，在构建If-Modified-Since请求首部时，Volley 使用了服务端响应的Date首部，没有使用Last-Modified首部。整个框架没有使用Last-Modified首部。这与 Http 语义不符。123456789101112131415private void addCacheHeaders(Map&lt;String, String&gt; headers, Cache.Entry entry) &#123; // If there's no cache entry, we're done. if (entry == null) &#123; return; &#125; if (entry.etag != null) &#123; headers.put("If-None-Match", entry.etag); &#125; if (entry.serverDate &gt; 0) &#123; Date refTime = new Date(entry.serverDate); headers.put("If-Modified-Since", DateUtils.formatDate(refTime)); &#125;&#125; 服务端根据请求时通过If-Modified-Since首部传过来的时间，判断资源文件是否在If-Modified-Since时间 以后 有改动，如果有改动，返回新的请求结果。如果没有改动，返回 304 not modified。Last-Modified代表了资源文件的最后修改时间。通常使用这个首部构建If-Modified-Since的时间。Date代表了响应产生的时间，正常情况下Date时间在Last-Modified时间之后。也就是Date&gt;=Last-Modified。通过以上原理，既然Date&gt;=Last-Modified。那么我利用Date构建，也是完全正确的。 可能的问题出在服务端的 Http 实现上，如果服务端完全遵守 Http 语义，采用时间比较的方式来验证If-Modified-Since，判断服务器资源文件修改时间是不是在If-Modified-Since之后。那么使用Date完全正确。可是有的服务端实现不是比较时间，而是直接的判断服务器资源文件修改时间，是否和If-Modified-Since所传时间相等。这样使用Date就不能实现正确的再验证，因为Date的时间总不会和服务器资源文件修改时间相等。 尽管使用Date可能出现的不正确情况，归结于服务端没有正确的实现 Http 语义。但我还是希望 Volley 也能完全正确的实现 Http 语义，至少同时处理Last-Modified和Date,并且优先使用Last-Modified。 ####5.2 Bug #####(1). BasicNetwork.performRequest(…)如下代码：12345678910111213141516171819@Overridepublic NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; …… while (true) &#123; …… try &#123; …… &#125; catch (IOException e) &#123; int statusCode = 0; NetworkResponse networkResponse = null; …… if (responseContents != null) &#123; …… &#125; else &#123; throw new NetworkError(networkResponse); &#125; &#125; &#125;&#125; BasicNetwork.performRequest(…) 最后的1throw new NetworkError(networkResponse); 应该是1throw new NetworkError(e); 更合理。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>开源项目</tag>
        <tag>volley</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 机型适配]]></title>
    <url>%2Fandroid-%E6%9C%BA%E5%9E%8B%E9%80%82%E9%85%8D.html</url>
    <content type="text"><![CDATA[2015/10/21 15:35:54 lucas 初步编辑 2015年11月23日 03:44:59 lucas 参照了CSDN上的一些博客进行了修改。（因为没有找到原博主，所以无法列出链接，抱歉！sorry） 201X年XX月XX日 XX:XX:XX 等待下一次修改，等下次空闲时，再完善一些内容，以及提供样例代码以及部分截图。 Android机型适配 PS：Android机型适配一直以来都折磨着我们这些开发者，本篇文章讲介绍Android的屏幕适配，所谓的屏幕适配往往指的就是屏幕大小和屏幕密度的适配。 需要做好一款软件的屏幕适配方案，我们应该学习以下几个方面的知识： 了解基本的屏幕适配知识。 Google官方的解决方案啊。 与ScrollView的结合。 结合Html5和css3优化界面布局和适配。 与Weight的结合。 .9.png图片的使用。 题外话 基本的屏幕适配知识 屏幕大小 在Android系统中，将屏幕大小划分成以下几种：small、normal、large、extra large。 屏幕密度 在Android系统中，屏幕密度往往是在指定的屏幕大小区域内，有多少个像素，基本单位是dpi(点/每英寸)。 基本包括四种密度：low、dedium（中等）、hign、extra hign（更高的密度） 常见的密度如下：QVGA(240X320)、HVGA(320X480)、WVGA800(480X800) Google官方的解决方案1. 创建不同的布局(Create Different Layouts) 为了让用户在不同的分辨率的设备上的体验得到优化，我们应该为每一个我们所想支持的屏幕尺寸都创建一个自己的layout XML文件，每个文件都保存在相应的资源目录，例如，如果我们想支持large screens，我们就应该在资源目录res文件夹下创建一个layout-large。android系统会根据屏幕的尺寸大小去自动的加载相应的布局。 如下，一个包含这默认的layout和一个供选择的large screen的layout 1234567res/ layout/ main.xml layout-large/ main.xml// 需要注意的是，文件名必须相同，但文件里面的内容可以相同，你可以根据不同的屏幕的尺 寸制定不同的布局以优化用户的体验 在具体的代码中，没有什么变化，android系统会自动调用不同屏幕尺寸的布局 12345@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main);&#125; 系统会根据应用程序所运行在的android设备的屏幕大小加载相同的布局，具体的android如何选择合适的资源将在另外一篇博客关于android资源的详解中介绍到。 下面是一个关于横屏和竖屏的布局： 123456MyProject/ res/ layout/ main.xml layout-land/ main.xml 如果想要提供一个特殊的layout在大屏幕设备横屏的时候，则large和land两个限定符都需要使用。 12345678910MyProject/ res/ layout/ # default (portrait) main.xml layout-land/ # landscape main.xml layout-large/ # large (portrait) main.xml layout-large-land/ # large landscape main.xml 安卓3.2及以上支持定义屏幕尺寸的一种先进方法,允许您指定资源基于最小宽度和高度的屏幕尺寸的密度独立像素。后面我们会详细的解释。 2. 创建不同的位图(Create Different Bitmaps) 因为需要适配不同屏幕，我们需要提供不同的图片来适配，这样才能带来更好的用户体验. [通常我们需要提供下面的资源图片来适配] xhdpi: (dpi=320, density=2)hdpi: (dpi=240, density=1.5)mdpi: (dpi=160, density=1) (baseline)ldpi: (dpi=120, density=0.75) 这意味着如果我们为xhdpi的设备生成了一张200x200的图片，同时也需要为hdpi的设备生成150x150的图片，为mdpi的设备生成100x100的图片，最后为ldpi的设备生成75x75的图片。 12345678910MyProject/ res/ drawable-xhdpi/ awesomeimage.png drawable-hdpi/ awesomeimage.png drawable-mdpi/ awesomeimage.png drawable-ldpi/ awesomeimage.png 这样之后，在任何地方引用@drawable/awesomeimage，系统都会自动根据当前设备的dpi来选择合适的图片进行显示。 3. Android 多屏幕设计(Designing for Multiple Screens)支持不同的屏幕尺寸(Supporting Different Screen Sizes) 确保你的布局可以根据屏幕的大小自适应调整 为不同的屏幕配置提供对应的UI布局 确保正确的布局适合正确的屏幕。 提供缩放正确的位图（ bitmap） 使用“wrap_content”和“match_parent”为了确保你的布局能灵活的适应不同的屏幕尺寸， 针对一些view组件， 你应该使wrap_content和match_parent来设置他们的宽和高。 如果你使用了wrap_content， view的宽和高会被设置该view所包含的内容的大小值。 如果是match_parent（ 在API 8之前是fill_parent） 则会匹配该组件的父控件的大小。通过使用wrap_content和match_parent尺寸值代替硬编码的尺寸， 你的视图将分别只使用控件所需要的空间或者被拓展以填充所有有效的空间。 比如： 12345678910111213141516171819202122232425262728293031&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:id=&quot;@+id/linearLayout1&quot; android:gravity=&quot;center&quot; android:layout_height=&quot;50dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView1&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:src=&quot;@drawable/logo&quot; android:paddingRight=&quot;30dp&quot; android:layout_gravity=&quot;left&quot; android:layout_weight=&quot;0&quot; /&gt; &lt;View android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/view1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;Button android:id=&quot;@+id/categorybutton&quot; android:background=&quot;@drawable/button_bg&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;0&quot; android:layout_width=&quot;120dp&quot; style=&quot;@style/CategoryButtonStyle&quot;/&gt; &lt;/LinearLayout&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; 使用相对布局（ RelativeLayout）你可以使用LinearLayout以及wrap_content和match_parent组合来构建复杂的布局， 但是LinearLayout却不允许你精准的控制它子view的关系，子view在LinearLayout中只能简单一个接一个的排成行。如果你需要你的子view不只是简简单单的排成行的排列，更好的方法是使用RelativeLayout，它允许你指定你布局中控件与控件之间的关系， 比如，你可以指定一个子view在左边， 另一个则在屏幕的右边。 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/label&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Type here:&quot;/&gt; &lt;EditText android:id=&quot;@+id/entry&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/label&quot;/&gt; &lt;Button android:id=&quot;@+id/ok&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/entry&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginLeft=&quot;10dp&quot; android:text=&quot;OK&quot; /&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_toLeftOf=&quot;@id/ok&quot; android:layout_alignTop=&quot;@id/ok&quot; android:text=&quot;Cancel&quot; /&gt;&lt;/RelativeLayout&gt; 使用尺寸限定词(Use Size Qualifiers)PS:这里的限定词主要是指在编写布局文件时， 将布局文件放在加上类似large， sw600dp等这样限定词的文件夹中，以此来告诉系统根据屏幕选择对应的布局文件， 比如下面例子的layout-large文件夹。 res/layout/main.xml,单个窗格布局(默认) 12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout-large/main.xml,两个窗格的布局。 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 注意第二个布局文件的目录名字“large qualifier”， 在大尺寸的设备屏幕时（ 比如7寸平板或者其他大屏幕的设备） 就会选择该布局文件， 而其他比较小的设备则会选择没有限定词的另一个布局（ 也就是第一个布局文件） 。 使用最小宽度限定词在Android 3.2之前， 开发者还有一个困难， 那就是Android设备的“large”屏幕尺寸， 其中包括Dell Streak（ 设备名称），老版Galaxy Tab和一般的7寸平板，有很多的应用都想针对这些不同的设备（ 比如5和7寸的设备） 定义不同的布局， 但是这些设备都被定义为了large尺寸屏幕。 也是因为这个， 所以Android在3.2的时候开始使用最小宽度限定词。 最小宽度限定词允许你根据设备的最小宽度（ dp单位） 来指定不同布局。 比如， 传统的7寸平板最小宽度为600dp， 如果你希望你的UI能够在这样的屏幕上显示两个窗格（ 不是一个窗格显示在小屏幕上），你可以使用上节中提到的使用同样的两个布局文件。 同的是， 使用sw600来指定两个方框的布局使用在最小宽度为600dp的设备上。 res/layout/main.xml,单个窗格布局（默认） 12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout-large/main.xml,两个窗格的布局 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 这样意味着当你的设备的最小宽度等于600dp或者更大时， 系统选择layout-sw600dp/main.xml（两个窗格） 的布局，而小一点的屏幕则会选择layout/main.xml（ 单个窗格） 的布局。 然而，在3.2之前的设备上， 这样做并不是很好的选择。因为3.2之前还没有将sw600dp作为一个限定词出现，所以，你还是需要使用large限定词来做。因此，你还是应该要有一个布局文件名为res/layout-large/main.xml， 和res/layout-sw600dp/main.xml一样。在后续的博客中，我们将介绍到如何避免出现这样重复的布局。 使用布局别名(Use Layout Aliases)最小宽度限定词只能在android3.2或者更高的版本上使用。因此，你还是需要使用抽象尺寸（ small，normal，large，xlarge）来兼容以前的版本。比如，你想要将你的UI设计为在手机上只显示一个方框的布局，而在7寸平板或电视， 或者其他大屏幕设备上显示多个方框的布局， 你可能得提供这些文件： res/layout/main.xml,单个窗格布局 res/layout-large,多个窗格布局 res/layout-sw600dp,多个窗格布局 最后两个文件都是一样的，因为其中一个将会适配Android3.2的设备，而另外一个则会适配其他Android低版本的平板或者电视。为了避免这些重复的文件（ 维护让人感觉头痛就是因为这个），你可以使用别名文件。 比如，你可以定义如下布局：res/layout/main.xml， 单个方框布局 res/layout/main_twopans.xml， 两个方框布局 然后添加这两个文件： res/valueslargelayout.xml： 123&lt;resources&gt; &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;&lt;/resources&gt; res/values-sw600dp/layout.xml: 123&lt;resources&gt; &lt;item name=&quot;main&quot; type=&quot;layout&quot;&gt;@layout/main_twopanes&lt;/item&gt;&lt;/resources&gt; 使用方向限定词(Use Orientation Qualifiers)有一些布局不管是在横向还是纵向的屏幕配置中都能显示的非常好，但是更多的时候，适当的调整一下会更好。 在NewsReader应用例子中， 以下是布局在不同屏幕尺寸和方向的行为： small screen, portrait:,纵向，一个窗格加logo，小屏幕 small screen, landscape:,横向，一个窗格加logo，小屏幕 7&quot; tablet, portrait:,纵向，一个窗格加actionBar，7寸屏幕 7&quot; tablet, landscape:,横向，两个宽窗格加actionBar，7寸屏幕 10&quot; tablet, portrait:,纵向，两个窄窗格加actionBar ，平板 10&quot; tablet, landscape:,横向，两个宽窗格加actionBar，平板 TV, landscape:,两个窗格，宽屏，加actionBar，电视 这些每个布局都会在res/layout目录下定义一个xml文件，如此，应用就能根据屏幕配置的变化根据别名匹配到对应的布局来适应屏幕。 res/layout/onepane.xml: 12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/onepane_with_bar.xml: 1234567891011121314151617181920212223242526272829303132&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:id=&quot;@+id/linearLayout1&quot; android:gravity=&quot;center&quot; android:layout_height=&quot;50dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView1&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:src=&quot;@drawable/logo&quot; android:paddingRight=&quot;30dp&quot; android:layout_gravity=&quot;left&quot; android:layout_weight=&quot;0&quot; /&gt; &lt;View android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/view1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;Button android:id=&quot;@+id/categorybutton&quot; android:background=&quot;@drawable/button_bg&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;0&quot; android:layout_width=&quot;120dp&quot; style=&quot;@style/CategoryButtonStyle&quot;/&gt; &lt;/LinearLayout&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/twopanes.xml: 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; res/layout/twopanes_narrow.xml: 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;200dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 现在所有可能的布局我们都已经定义了，唯一剩下的问题是使用方向限定词来匹配对应的布局给屏幕。这时候，你就可以使用布局别名的功能了： res/values/layouts.xml: 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane_with_bar&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;&lt;/resources&gt; res/values-sw600dp-land/layouts.xml: 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; res/values-sw600dp-port/layouts.xml: 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/onepane&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;false&lt;/bool&gt;&lt;/resources&gt; res/values-large-land/layouts.xml: 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; res/values-large-port/layouts.xml: 1234&lt;resources&gt; &lt;item name=&quot;main_layout&quot; type=&quot;layout&quot;&gt;@layout/twopanes_narrow&lt;/item&gt; &lt;bool name=&quot;has_two_panes&quot;&gt;true&lt;/bool&gt;&lt;/resources&gt; 使用.9.png图片 关于.9图片上下左右四条黑线的含义解释： 上方黑线代表横向拉伸区域。 左边黑线代表纵向拉伸区域。 下方黑线代表横向内容显示区域。 右边黑线代表纵向内容显示区域。 支持不同的屏幕尺寸同时也意味着你的图片资源也必须能兼容不同的屏幕尺寸。比如，一个button的背景图片就必须要适应该button的各种形状。 如果你在使用组件时可以改变图片的大小，你很快就会发现这是一个不明确的选择。 因为运行的时候，图片会被拉伸或者压缩（这样容易造成图片失真）。避免这种情况的解决方案就是使用点9图片，这是一种能够指定哪些区域能够或者不能够拉伸的特殊png文件。 因此， 在设计的图片需要与组件一起变大变小时， 一定要使用点9.若要将位图转换为点9， 你可以用一个普通的图片开始（下图，是在4倍变焦情况下的图片显示） 。 你可以通过sdk中的draw9patch程序（位于tools/directory目录下） 来画点9图片。 通过左侧和顶部边框绘制像素来标记应该被拉伸的区域。 也可以通过沿右侧和底部边界绘制像素来标记。 就像下图所示一样： 请注意， 上图沿边界的黑色像素。在顶部边框和左边框的那些表明图像的可拉伸区域，右边和底部边框则表示内容应该放置的地方。 此外，注意.9.png这个格式，你也必须用这个格式，因为系统会检测这是一个点9图片而不是一个普通PNG图片。 当你将这个应用到组件的背景的时候（通过设置android:background=”@drawable/button”），android框架会自动正确的拉伸图像以适应按钮的大小，下图就是各种尺寸中的显示效果： 支持不同的屏幕密度(Supporting Different Densities)使用密度独立像素(dp)设计布局时， 要避免使用绝对像素（ absolutepixels） 定义距离和尺寸。 使用像素单位来定义布局大小是有问题的。因为，不同的屏幕有不同的像素密度，所以，同样单位的像素在不同的设备上会有不同的物理尺寸。因此，在指定单位的时候，通常使用dp或者sp。一个dp代表一个密度独立像素，也就相当于在160dpi的一个像素的物理尺寸，sp也是一个基本的单位，不过它主要是用在文本尺寸上（它也是一种尺寸规格独立的像素），所以，你在定义文本尺寸的时候应该使用这种规格单位（不要使用在布尺寸上）。 例如，当你是定义两个view之间的空间时，应该使用dp而不是px： 1234&lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/clickme&quot; android:layout_marginTop=&quot;20dp&quot; /&gt; 当指定文本尺寸时，始终应该使用sp： 123&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;20sp&quot; /&gt; 提供可供选择的图片(Provide Alternative Bitmaps)因为Android能运行在很多不同屏幕密度的设备上，所以，你应该针对不同的设备密度提供不同的bitmap资源：小屏幕（low），medium（中），high（高）以及超高（extra-high）密度。这将能帮助你在所有的屏幕密度中得到非常好的图形质量和性能。 为了提供更好的用户体验，你应该使用以下几种规格来缩放图片大小，为不同的屏幕密度提供相应的位图资源： 1234xhdpi: 2.0hdpi: 1.5mdpi: 1.0 (baseline)ldpi: 0.75 这也就意味着如果在xhdpi设备上你需要一个200x200的图片，那么你则需要一张150x150的图片用于hdpi，100x100的用于mdpi以及75x75的用户ldpi设备。 然后将这些图片资源放到res/对应的目录下面，系统会自动根据当前设备屏幕密度自动去选择合适的资源进行加载： 12345678910MyProject/ res/ drawable-xhdpi/ awesomeimage.png drawable-hdpi/ awesomeimage.png drawable-mdpi/ awesomeimage.png drawable-ldpi/ awesomeimage.png 这样放置图片资源后，不论你什么时候使用@drawable/awesomeimage，系统都会给予屏幕的dp来选择合适的图片。 实现可适应的UI流程(Implementing Adaptative UI Flows)根据当前你的应用显示的布局，它的UI流可能会不一样。比如，当你的应用是双窗格模式，点击左边窗格的条目（item）时，内容（content）显示在右边窗格中。如果是单窗格模式中，当你点击某个item的时候，内容则显示在一个新的activity中。 确定当前布局(Determine the Current Layout)由于每种布局的实现会略有差别，首先你可能要确定用户当前可见的布局是哪一个。比如，你可能想知道当前用户到底是处于“单窗格”的模式还是“双窗格”的模式。 你可以通过检查指定的视图（view）是否存在和可见来实现： 12345678910111213public class NewsReaderActivity extends FragmentActivity &#123; boolean mIsDualPane; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main_layout); View articleView = findViewById(R.id.article); mIsDualPane = articleView != null &amp;&amp; articleView.getVisibility() == View.VISIBLE; &#125;&#125; 另一个关于如何适配不同组件是否存在的例子，是在组件执行操作之前先检查它是否是可用的。 比如，在News Reader示例中，有一个按钮点击后打开一个菜单，但是这个按钮仅仅只在Android3.0之后的版本中才能显示（因为这个功能被ActionBar代替，在API 11+中定义）。所以，在给这个按钮添加事件之间，你可以这样做: 12345Button catButton = (Button) findViewById(R.id.categorybutton);OnClickListener listener = /* create your listener here */;if (catButton != null) &#123; catButton.setOnClickListener(listener);&#125; 根据当前布局相应(React According to Current Layout)一些操作会根据当前的布局产生不同的效果。比如，在News Reader示例中，当你点击标题（headlines）列表中的某一条headline时， 如果你的UI是双窗格模式， 内容会显示在右边的窗格中，如果你的UI是单窗格模式，会启动一个分开的Activity并显示： 1234567891011121314@Overridepublic void onHeadlineSelected(int index) &#123; mArtIndex = index; if (mIsDualPane) &#123; /* display article on the right pane */ mArticleFragment.displayArticle(mCurrentCat.getArticle(index)); &#125; else &#123; /* start a separate activity */ Intent intent = new Intent(this, ArticleActivity.class); intent.putExtra(&quot;catIndex&quot;, mCatIndex); intent.putExtra(&quot;artIndex&quot;, index); startActivity(intent); &#125;&#125; 同样，如果你的应用处于多窗格模式，那么它应该在导航栏中设置带有选项卡的action bar。而如果是单窗格模式，那么导航栏应该设置为spinner widget。 所以， 你的代码应该检查哪个方案是最合适的： 12345678910111213141516171819202122final String CATEGORIES[] = &#123; &quot;Top Stories&quot;, &quot;Politics&quot;, &quot;Economy&quot;, &quot;Technology&quot; &#125;;public void onCreate(Bundle savedInstanceState) &#123; .... if (mIsDualPane) &#123; /* use tabs for navigation */ actionBar.setNavigationMode(android.app.ActionBar.NAVIGATION_MODE_TABS); int i; for (i = 0; i &lt; CATEGORIES.length; i++) &#123; actionBar.addTab(actionBar.newTab().setText( CATEGORIES[i]).setTabListener(handler)); &#125; actionBar.setSelectedNavigationItem(selTab); &#125; else &#123; /* use list navigation (spinner) */ actionBar.setNavigationMode(android.app.ActionBar.NAVIGATION_MODE_LIST); SpinnerAdapter adap = new ArrayAdapter(this, R.layout.headline_item, CATEGORIES); actionBar.setListNavigationCallbacks(adap, handler); &#125;&#125; 在其他Activity中复用Fragment在多屏幕设计时经常出现的情况是：在一些屏幕配置上设计一个窗格，而在其他屏幕配置上启动一个独立的Activity。例如，在News Reader中，新闻内容文字在大屏幕上市显示在屏幕右边的方框中，而在小屏幕中，则是由单独的activity显示的。 像这样的情况，你就应该在不同的activity中使用同一个Fragment，以此来避免代码的重复， 而达到代码复用的效果。比如，ArticleFragment在双窗格模式下是这样用的： 1234567891011121314&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;fragment android:id=&quot;@+id/headlines&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.HeadlinesFragment&quot; android:layout_width=&quot;400dp&quot; android:layout_marginRight=&quot;10dp&quot;/&gt; &lt;fragment android:id=&quot;@+id/article&quot; android:layout_height=&quot;fill_parent&quot; android:name=&quot;com.example.android.newsreader.ArticleFragment&quot; android:layout_width=&quot;fill_parent&quot; /&gt;&lt;/LinearLayout&gt; 在小屏幕中，它又是如下方式被复用的（没有布局文件）ArticleActivity： 12ArticleFragment frag = new ArticleFragment();getSupportFragmentManager().beginTransaction().add(android.R.id.content, frag).commit(); 当然，如果将这个fragment定义在XML布局文件中，也有同样的效果 但是在这个例子中则没有必要，因为这个articlefragment是这个activity的唯一组件。 当你在设计fragment的时候，非常重要的一点：不要为某个特定的activity设计耦合度高的fragment。通常的做法是， 通过定义抽象接口，并在接口中定义需要与该fragment进行交互的activity的抽象方法，然后与该fragment进行交互的activity实现这些抽象接口方法。 例如，在News Reader中，HeadlinesFragment就很好的诠释了这一点： 1234567891011121314public class HeadlinesFragment extends ListFragment &#123; ... OnHeadlineSelectedListener mHeadlineSelectedListener = null; /* Must be implemented by host activity */ public interface OnHeadlineSelectedListener &#123; public void onHeadlineSelected(int index); &#125; ... public void setOnHeadlineSelectedListener(OnHeadlineSelectedListener listener) &#123; mHeadlineSelectedListener = listener; &#125;&#125; 然后，当用户选择了一个headline item之后，fragment将通知对应的activity指定监听事件（ 而不是通过硬编码的方式去通知）： 1234567891011public class HeadlinesFragment extends ListFragment &#123; ... @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; if (null != mHeadlineSelectedListener) &#123; mHeadlineSelectedListener.onHeadlineSelected(position); &#125; &#125; ...&#125; 处理屏幕配置变化(Handle Screen Configuration Changes)如果使用的是单独的activity来实现你界面的不同部分，你需要注意的是，屏幕变化（如旋转变化）的时候，你也应该根据屏幕配置的变化来保持你的UI布局的一致性。 例如，在传统的Android3.0或以上版本的7寸平板上，News Reader示例在竖屏的时候使用独立的activity显示文章内容，而在横屏的时候，则使用两个窗格模式（即内容显示在右边的方中） 。 这也就意味着，当用户在竖屏模式下观看文章的时候，你需要检测屏幕是否变成了横屏， 如果改变了，则结束当前activity并返回到主activity中，这样，content就能显示在双窗格模式布局中。 12345678910111213141516public class ArticleActivity extends FragmentActivity &#123; int mCatIndex, mArtIndex; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mCatIndex = getIntent().getExtras().getInt(&quot;catIndex&quot;, 0); mArtIndex = getIntent().getExtras().getInt(&quot;artIndex&quot;, 0); // If should be in two-pane mode, finish to return to main activity if (getResources().getBoolean(R.bool.has_two_panes)) &#123; finish(); return; &#125; ...&#125; PS:关于官方的屏幕适配解决方案就暂时介绍到这，更详细的内容可以去自行查阅官方文档：develop.google.com/training/basics/supporting-devices/screens.html#create-layouts 与ScrollView的结合虽然图片完整的展示出来了，但是却发生了轻微的形状改变。为了顺利解决这个问题，就需要与ScrollView结合来完整的展示整张图片。道理不多讲了，直接用一个实例来说明问题。新建一个工程：test_demo_02。然后将所需要展示的图片添加到drawable-hdpi 文件夹下面。接下来开始在layout文件夹中设计布局。 布局代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;fill_parent&quot;android:orientation=&quot;vertical&quot;&gt; &lt;TextViewandroid:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;wrap_content&quot;android:text=&quot;与ScrollView结合的图片布局&quot;/&gt;&lt;ScrollViewandroid:id=&quot;@+id/myScrollView&quot;android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;wrap_content&quot;android:scrollbars=&quot;vertical&quot;android:layout_weight=&quot;4&quot;&gt;&lt;ImageViewandroid:id=&quot;@+id/myImageView&quot;android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;wrap_content&quot;android:background=&quot;@drawable/guozi3&quot;&gt;&lt;/ImageView&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; 结合Html5 和 css3优化界面布局和配置（这块博主暂时未测试，待测试后更新）采用HTML5和CSS3制作界面，然后在WebView视图上进行显示，然后通过JavaScript进行事件的交互是一种很不错的开发技巧。下面举一个例子说明问题。例如：制作一个“花卉采购计划”的表单，然后在WebView上予以显示。 有以下几项内容需要予以说明：1、电脑的桌面浏览器不同于移动手机浏览器，因此需要在HTML的文件的head元素中设置viewport meta标签。 &lt;meta name=”viewport” content=”width=device; user-scalable=0;”2、可以设置不同的CSS级联样式表，来适应不同宽度的屏幕。 比如：最大宽度为320px,可以这样写： 再比如：最小宽度为480px,可以这么写： 与layout_weight的结合(权重属性的使用)在进行视图布局时，与layout_weight的属性值进行有效的结合，可以达到通用的布局效果。layout_weight其实就是用来控制比例的，在实践操作中，有同学说是正比例控制，也有同学说是反比例控制。其实正比例和反比例的情况都是存在的，就看如何与layout_width和layout_height的属性值进行适当的结合啦！俗话说：没有规矩，不成方圆。个人认为，反比例的控制效果，是无节制，无规范结合layout_width和layout_height的产物，极其不提倡，只会把人带入思维的死循环。就像某位所说，这样做，只会将简单问题复杂化，复杂问题深入化，深入问题模糊化，模糊问题抽象化，从而显示学者的高明，实则愚蠢，只是制造垃圾而已。其实，简单的，往往就是最好的。 .9.png图片的使用PS：在前文的Google官方解决方案中，已经介绍了.9图片，这里就不再介绍。 题外话为了适配更多的机型，并且防止用户因为应用占用内存太多，不得不卸载的问题，就要让应用支持安装的SDCard中。具体代码如下：为manifest元素增加属性：android:installLocation=&quot;preferExternal&quot;切记：应用的开发要基于android2.2及以上进行开发才支持安装到SDCard。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>机型适配</tag>
        <tag>屏幕适配</tag>
        <tag>android进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android开发规范之编码规范]]></title>
    <url>%2Fandroid%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E4%B9%8B%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[编码规范 java代码中不出现中文，最多注释中可以出现中文，中文统一写在strings.xml中； 局部变量命名、静态成员变量命名 只能包含字母，单词首字母大写，其他字母都为小写 常量命名只能包含字母和，字母全部大写，单词之间用隔开 布局文件中的id命名 123456789命名模式为：view缩写_模块名称_view的逻辑名称常用控件的缩写如下LayoutView：lv_RelativeView : rv_TextView : tv_ImageView : iv_ImageButton : im_Button : btn_ strings.xml中的id命名命名模式：activity名称功能模块名称逻辑名称/activity名称逻辑名称/common逻辑名称strings.xml中，使用activity名称注释，将文件内容区分开来 styles.xml：将layout中不断重现的style提炼出通用的style通用组件，放到styles.xml中； 服务端可以实现的，就不要放在客户端； 图片尽量分拆成多个可重用的图片 引用第三方库要慎重，避免应用大容量的第三方库，导致客户端包非常大； 图片要.9.png处理 使用静态变量方式实现界面间共享要慎重； Log(系统名称 模块名称 接口名称，详细描述)； 不要重用父类的handler，对应一个类的handler也不应该让其子类用到，否则会导致message.what冲突 strings.xml中使用%1$s实现字符串的通配 如果多个Activity中包含共同的UI处理，那么可以提炼一个CommonActivity，把通用部分叫由它来处理，其他activity只要继承它即可 数据一定要效验，例如字符型转数字型，如果转换失败一定要有缺省值；服务端响应数据是否有效判断； Android性能的基本优化OK，其次说说，如何提高Android的效率，也就是如何来优化Android的性能： http用gzip压缩，设置连接超时时间和响应超时时间http请求按照业务需求，分为是否可以缓存和不可缓存，那么在无网络的环境中，仍然通过缓存的httpresponse浏览部分数据，实现离线阅读。 listview 性能优化 复用convertView在getItemView中，判断convertView是否为空，如果不为空，可复用。如果couvertview中的view需要添加listerner，代码一定要在if(convertView==null){}之外。 异步加载图片item中如果包含有webimage，那么最好异步加载 快速滑动时不显示图片当快速滑动列表时（SCROLL_STATE_FLING），item中的图片或获取需要消耗资源的view，可以不显示出来；而处于其他两种状态（SCROLL_STATE_IDLE 和SCROLL_STATE_TOUCH_SCROLL），则将那些view显示出来 BaseAdapter避免内存溢出如果BaseAdapter的实体类有属性非常消耗内存，可以将保存到文件；为提高性能，可以进行缓存，并限制缓存大小。 使用线程池，分为核心线程池和普通线程池，下载图片等耗时任务放置在普通线程池，避免耗时任务阻塞线程池后，导致所有异步任务都必须等待 异步任务，分为核心任务和普通任务，只有核心任务中出现的系统级错误才会报错，异步任务的ui操作需要判断原activity是否处于激活状态 尽量避免static成员变量引用资源耗费过多的实例,比如Context 使用WeakReference代替强引用，弱引用可以让您保持对对象的引用，同时允许GC在必要时释放对象，回收内存。对于那些创建便宜但耗费大量内存的对象，即希望保持该对象，又要在应用程序需要时使用，同时希望GC必要时回收时，可以考虑使用弱引用。 超级大胖子Bitmap及时的销毁(Activity的onDestroy时将bitmap回收，在被UI组件使用后马上进行回收会抛 RuntimeException: Canvas: trying to use a recycled bitmap android.graphics.Bitmap)设置一定的采样率(有开发者提供的图片无需进行采样，对于有用户上传或第三方的大小不可控图片，可进行采样减少图片所占的内存)，从服务端返回图片，建议同时反馈图片的size 巧妙的运用软引用drawable对应resid的资源，bitmap对应其他资源任何类型的图片，如果获取不到（例如文件不存在，或者读取文件时跑OutOfMemory异常），应该有对应的默认图片（默认图片放在在apk中，通过resid获取）； 保证Cursor 占用的内存被及时的释放掉，而不是等待GC来处理。并且 Android明显是倾向于编 程者手动的将Cursor close掉 线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程 生命周期的不可控 如果ImageView的图片是来自网络，进行异步加载 应用开发中自定义View的时候，交互部分，千万不要写成线程不断刷新界面显示，而是根据TouchListener事件主动触发界面的更新 Drawable ui组件需要用到的图片是apk包自带的，那么一律用setImageResource或者setBackgroundResource，而不要根据resourceid 注意：get(getResources(), R.drawable.btn_achievement_normal)该方法通过resid转换为drawable，需要考虑回收的问题，如果drawable是对象私有对象，在对象销毁前是肯定不会释放内存的。 复用、回收Activity对象临时的activity及时finish主界面设置为singleTask一般界面设置为singleTop 位置信息获取用户的地理位置信息时，在需要获取数据的时候打开GPS，之后及时关闭掉 在onResume时设置该界面的电源管理，在onPause时取消设置]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>android开发</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Picasso学习笔记]]></title>
    <url>%2FPicasso%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[注：文章转载自文章转载自RowandJJ的博客：http://blog.csdn.net/chdjj/article/details/49964901下面是我在学习Picasso过程中做的笔记. 关于图片加载库的思考 我们为什么要用图片库呢? 图片库通常会对图片加载逻辑进行封装、优化，比如多级缓存/异步线程调度/图片压缩变换,有了这些特性，开发者不再需要关注内存占用、 OOM、网络请求等问题，而只需关注业务本身的逻辑，这对提高生产效率还是很有帮助的。 我通过调研一些图片库，发现一个图片加载库通常有以下模块: 请求分发模块。负责封装请求,对请求进行优先级排序,并按照类型进行分发。 缓存模块。通常包括一个二级的缓存，内存缓存、磁盘缓存。并预置多种缓存策略。 下载模块。负责下载网络图片。 监控模块。负责监控缓存命中率、内存占用、加载图片平均耗时等。 图片处理模块。负责对图片进行压缩、变换等处理。 本地资源加载模块。负责加载本地资源，如assert、drawable、sdcard等。 显示模块。负责将图片输出显示。 Android平台图片加载库现状 目前社区主流的图片加载库有Universal ImageLoader,Picasso,Volley,Fresco,Glide. Picasso简介 A powerful image downloading and caching library for Android,developed by Square wiki:http://square.github.io/picasso/ Picasso的特性 绝对是最轻量的图片加载库,120kb. 自带监控功能，可以检测cache hit/内存大小等等数据 图片预加载 线程并发数依网络状态变化而变化、优先级调度 图片变换 图片压缩、自适应 易扩展 Picasso的使用 加载一张网络图片到ImageView上 12345Picasso.with(context) .load(url) .placeholder(R.drawable.user_placeholder) .error(R.drawable.user_placeholder_error) .into(imageView);//此种策略并不会压缩图片 预加载一张图片 12Picasso.with(this).load(URL).fetch();Picasso.with(this).load(URL).fetch(Callback); 注意哦，如果你以以下面这种方式加上图形变换preload的话: 1Picasso.with(this).load(URL).rotate(20).fetch(); 再下面这种方式是取不到preload的图片的，因为预缓存的是经过变换后的图片，它的cachekey会有rotation标识 1Picasso.with(this).load(URL).into(imageView); 当然我说的是preload到内存中的那份经过旋转的图片，http会缓存旋转前的图片到磁盘（支持缓存的情况下），所以最终还是可以从磁盘缓存拿到图片的。 替换默认的Picasso 12Picasso p = new Picasso.Builder(this).executor().downloader(downloader).memoryCache(cache).build();Picasso.setSingletonInstance(p); 同步call 123456789101112131415161718new AsyncTask&lt;Void,Void,Bitmap&gt;()&#123; @Override protected Bitmap doInBackground(Void... params) &#123; try &#123; return Picasso.with(PicassoTestActivity.this).load(URL).get(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override protected void onPostExecute(Bitmap bitmap) &#123; if(bitmap != null)&#123; imageView.setImageBitmap(bitmap); &#125; &#125; &#125;.execute(); 注意，必须在异步线程调用，否则crash,另外，这个结果并不会缓存到内存里面，所以慎用。 自适应 1Picasso.with(TestImageActivity.this).load(url).fit().into(imageview); fit方法的意思是，让图片的宽高恰好等于imageView的宽高.前提是你的imageView控件不能设置成wrap_content,也就是必须有大小才行。另外，如果使用了fit方法，那么就不能调用resize. 压缩到指定尺寸 12Picasso.with(TestImageActivity.this).load(url).resize(widthPixel,heightPixel).centerInside().into(imageView);Picasso.with(TestImageActivity.this).load(URL).resizeDimen(R.dimen.width,R.dimen.height).centerCrop().into(iv); resize后面通常接centerInside或者centerCrop。注意这跟ImageView的scaleTyoe没有关系，仅仅指的是图片的缩放方式。比如如下代码,iv不压缩，iv_2宽高压缩到40dp并且指定为centerInside. 1234567891011121314&lt;ImageView android:id=&quot;@+id/iv&quot; android:background=&quot;#000&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot;/&gt;&lt;ImageView android:layout_below=&quot;@id/iv&quot; android:id=&quot;@+id/iv_2&quot; android:background=&quot;#000&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot;/&gt;Picasso.with(TestImageActivity.this).load(URL).into(iv);Picasso.with(TestImageActivity.this).load(URL).resizeDimen(R.dimen.width/*40dp*/, R.dimen.height/*40dp*/).centerInside().into(iv_2); 最终显示结果如下: 可以很明显看到下面的图模糊许多，这是因为图片被压缩了，但是显示的时候又被ImageView拉伸了(默认scaleType是fitCenter)，要想不显示拉伸的图,可以给iv_2增加scaleType=&quot;centerInside&quot;,效果如下: 图形变换 1234567891011121314151617181920Picasso.with(TestImageActivity.this).load(URL).rotate(20).into(iv);//自定义变换 Picasso.with(TestImageActivity.this).load(URL).transform(new Transformation() &#123; @Override public Bitmap transform(Bitmap source) &#123;//从原图中间裁剪一个正方形 int size = Math.min(source.getWidth(), source.getHeight()); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; Bitmap result = Bitmap.createBitmap(source, x, y, size, size); if (result != source) &#123; source.recycle(); &#125; return result; &#125; @Override public String key() &#123; return &quot;square()&quot;; &#125; &#125;).into(iv); 各种图形变换:https://github.com/wasabeef/picasso-transformations 暂停/重启请求任务 通常在滑动列表的时候需要暂停请求 123456789101112131415161718192021222324252627282930Picasso.with(context).load(URL).tag(context);public class SampleScrollListener implements AbsListView.OnScrollListener &#123; private final Context context; public SampleScrollListener(Context context) &#123; this.context = context; &#125; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; final Picasso picasso = Picasso.with(context); if (scrollState == SCROLL_STATE_IDLE || scrollState == SCROLL_STATE_TOUCH_SCROLL) &#123; picasso.resumeTag(context); &#125; else &#123; picasso.pauseTag(context); &#125; &#125; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; // Do nothing. &#125; &#125; Picasso源码分析整体架构盗用下Trinea的图: Picasso中的核心类包括 Picasso、Dispatcher、BitmapHunter、RequestHandler、Request、Action、Cache等.Picasso类是一个负责图片下载、变换、缓存的管理器,当它收到一个图片下载请求的时候，它会创建Request并提交给Dispatcher,Dispatcher会寻找对应的处理器RequestHandler,并将请求与该处理器一起提交给线程池执行,图片获取成功后，最终会交给PicassoDrawable显示到Target上。 它将一张图片的加载过程分为八步，依次为: 创建-&gt;入队-&gt;执行-&gt;解码-&gt;变换-&gt;批处理-&gt;完成-&gt;分发-&gt;显示(可选) 也可以从日志中看到这个过程: 1234567811-05 10:39:00.942 2952-2952/com.taobao.paimainews D/Picasso: Main created [R0] Request&#123;http://ww3.sinaimg.cn/mw600/006g34NHgw1exj5c4hmfvj30hs0qoqff.jpg resize(90,300) centerInside rotation(30.0) ARGB_8888&#125;11-05 10:39:00.981 2952-3109/com.taobao.paimainews D/Picasso: Dispatcher enqueued [R0]+40ms11-05 10:39:00.993 2952-3193/com.taobao.paimainews D/Picasso: Hunter executing [R0]+50ms11-05 10:39:01.038 2952-3193/com.taobao.paimainews D/Picasso: Hunter decoded [R0]+97ms11-05 10:39:01.041 2952-3193/com.taobao.paimainews D/Picasso: Hunter transformed [R0]+100ms11-05 10:39:01.042 2952-3109/com.taobao.paimainews D/Picasso: Dispatcher batched [R0]+101ms for completion11-05 10:39:01.279 2952-2952/com.taobao.paimainews D/Picasso: Main completed [R0]+338ms from DISK11-05 10:39:01.280 2952-3109/com.taobao.paimainews D/Picasso: Dispatcher delivered [R0]+338ms 下面是Picasso的类图: 代码分析版本:2.5.2 Picasso类是整个图片加载器的入口，负责初始化各个模块，配置相关参数等等。Picasso.with()方法用于创建全局唯一的Picasso实例,为了确保唯一，使用了单例模式。 Picasso#with() 123456789101112static volatile Picasso singleton = null;public static Picasso with(Context context) &#123; if (singleton == null) &#123; synchronized (Picasso.class) &#123; if (singleton == null) &#123; singleton = new Builder(context).build(); &#125; &#125; &#125; return singleton; &#125; with方法内部通过Builder模式创建Picasso实例，这样做的好处是简洁清晰，通常在构造器参数很多的时候使用。build方法会最终创建Picasso实例: Picasso#Builder#build() 1234567891011121314151617181920212223public Picasso build() &#123; Context context = this.context; if (downloader == null) &#123; downloader = Utils.createDefaultDownloader(context); &#125; if (cache == null) &#123; cache = new LruCache(context); &#125; if (service == null) &#123; service = new PicassoExecutorService(); &#125; if (transformer == null) &#123; transformer = RequestTransformer.IDENTITY; &#125; Stats stats = new Stats(cache); Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats); return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats, defaultBitmapConfig, indicatorsEnabled, loggingEnabled); &#125; 此方法做了如下基本配置: 使用默认的缓存策略，内存缓存基于LruCache,磁盘缓存基于http缓存,HttpResponseCache 创建默认的下载器 创建默认的线程池(3个worker线程) 创建默认的Transformer,这个Transformer什么事情也不干，只负责转发请求 创建默认的监控器(Stats),用于统计缓存命中率、下载时长等等 创建默认的处理器集合,即RequestHandlers.它们分别会处理不同的加载请求 处理器集合的初始化在Picasso的构造器中:Picasso构造器 1234567891011allRequestHandlers.add(new ResourceRequestHandler(context));if (extraRequestHandlers != null) &#123; allRequestHandlers.addAll(extraRequestHandlers);&#125;allRequestHandlers.add(new ContactsPhotoRequestHandler(context));allRequestHandlers.add(new MediaStoreRequestHandler(context));allRequestHandlers.add(new ContentStreamRequestHandler(context));allRequestHandlers.add(new AssetRequestHandler(context));allRequestHandlers.add(new FileRequestHandler(context));allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats));requestHandlers = Collections.unmodifiableList(allRequestHandlers); 从命名就可以看出来，可以从网络、file、assert、contactsphoto等地方加载图片. 另,Picasso支持增加自己的处理器. load()方法用于从不同地方加载图片，比如网络、resource、File等，该方法内部逻辑很简单，只是创建了一个RequestCreator Picasso#load() 123public RequestCreator load(Uri uri) &#123; return new RequestCreator(this, uri, 0); &#125; RequestCreator从名字就可以知道这是一个封装请求的类,请求在Picasso中被抽象成Request。RequestCreator类提供了诸如placeholder、tag、error、memoryPolicy、networkPolicy等方法.由于可配置项太多，所以Request也使用了Builder模式:RequestCreator构造器 12345678RequestCreator(Picasso picasso, Uri uri, int resourceId) &#123; if (picasso.shutdown) &#123; throw new IllegalStateException( &quot;Picasso instance already shut down. Cannot submit new requests.&quot;); &#125; this.picasso = picasso; this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);&#125; 那么可想而知into方法一定会去将Request创建，并丢到线程池或者分发器中执行。into方法有多种重载，因为Picasso不仅仅可以将图片加载到ImageView上，还可以加载到Target或者RemoteView上.这里选取imageView作为分析对象,该方法代码如下： RequestCreator#into() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public void into(ImageView target, Callback callback) &#123; long started = System.nanoTime(); checkMain();//检查是否在主线程中执行 if (target == null) &#123; throw new IllegalArgumentException(&quot;Target must not be null.&quot;); &#125; if (!data.hasImage()) &#123;//检查是否设置uri或者resID //如果没有设置当然取消请求 picasso.cancelRequest(target); if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; return; &#125; if (deferred) &#123;//是否调用了fit(),如果是，代表需要将image调整为ImageView的大小 if (data.hasSize()) &#123;//不能与resize一起用 throw new IllegalStateException(&quot;Fit cannot be used with resize.&quot;); &#125; //既然要适应ImageView，肯定需要拿到ImageView大小 int width = target.getWidth(); int height = target.getHeight(); if (width == 0 || height == 0) &#123; if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; picasso.defer(target, new DeferredRequestCreator(this, target, callback)); return; &#125; data.resize(width, height); &#125; //创建request Request request = createRequest(started); String requestKey = createKey(request); if (shouldReadFromMemoryCache(memoryPolicy)) &#123;//是否需要在缓存里面先查找 Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey); if (bitmap != null) &#123;//cache hit picasso.cancelRequest(target); setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled); if (picasso.loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), &quot;from &quot; + MEMORY); &#125; if (callback != null) &#123; callback.onSuccess(); &#125; return; &#125; &#125; //缓存未命中，那就创建Action，将任务交给dispatcher if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; Action action = new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId, errorDrawable, requestKey, tag, callback, noFade); picasso.enqueueAndSubmit(action); &#125; 逻辑注释写的很清楚了，into方法会先从缓存里面查找图片，如果找不到的话，则会创建Action即一个加载任务，交给Dispatcher执行。那我们就来看看picasso.enqueueAndSubmit方法做了什么.在这之前，先来看下Action是什么鬼，为什么有了Request还要Action. 先看Request有哪些属性: 123456789101112131415161718int id;long started;int networkPolicy;public final Uri uri;public final int resourceId;public final String stableKey;public final List&lt;Transformation&gt; transformations;public final int targetWidth;public final int targetHeight;public final boolean centerCrop;public final boolean centerInside;public final boolean onlyScaleDown;public final float rotationDegrees;public final float rotationPivotX;public final float rotationPivotY;public final boolean hasRotationPivot;public final Bitmap.Config config;public final Priority priority; 再看Action的属性: 123456789101112final Picasso picasso;final Request request;final WeakReference&lt;T&gt; target;final boolean noFade;final int memoryPolicy;final int networkPolicy;final int errorResId;final Drawable errorDrawable;final String key;final Object tag;boolean willReplay;boolean cancelled; Request关注的是请求本身，比如请求的源、id、开始时间、图片变换配置、优先级等等，而Action则代表的是一个加载任务，所以不仅需要Request对象的引用，还需要Picasso实例，是否重试加载等等 Action有个需要关注的点，那就是WeakReference&lt;T&gt; target,它持有的是Target(比如ImageView..)的弱引用，这样可以保证加载时间很长的情况下也不会影响到Target的回收了. 好的，那回到刚才的思路，我们开始分析picasso.enqueueAndSubmit方法: picasso#enqueueAndSubmit() 12345678910111213final Map&lt;Object, Action&gt; targetToAction; ...this.targetToAction = new WeakHashMap&lt;Object, Action&gt;(); ...void enqueueAndSubmit(Action action) &#123; Object target = action.getTarget(); if (target != null &amp;&amp; targetToAction.get(target) != action) &#123; // This will also check we are on the main thread. cancelExistingRequest(target); targetToAction.put(target, action); &#125; submit(action);&#125; 它会先从action任务上拿到对应target，也就是imageView，然后从weakHashMap中通过这个imageView索引到对应的action，如果发现这个action跟传进来的action不一样的话，那就取消掉之前的加载任务。最后将当前加载任务提交. 跟进submit发现最终调用的是Dispatcher的dispatchSubmit(action)方法.这个Dispatcher即任务分发器，它是在Picasso实例创建的时候初始化的.。 那我们在看dispatchSubmit方法之前，必然得了解下Dispatcher. Picasso.Builder.build() 1Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats); 每一个Dispatcher都需要关联线程池(service)、下载器(downloader)、主线程的Handler(HANDLER)、缓存(cache)、监控器(stats). 这里先看线程池,Picasso默认的线程池叫PicassoExecutorService,它继承自ThreadPoolExecutor,默认线程数量为3.但是PicassoExecutorService的特性是可以根据网络情况调整线程数量，wifi下是4个线程，而2g网只有一个线程。具体是通过在Dispatcher中注册了监听网络变化的广播接收者。 另外，PicassoExecutorService中还有一个很重要的方法叫submit,它会去执行一个runnable. 好的，我们回到Dispatcher,这里还需要关注的是Dispatcher中有个内部类叫DispatcherHandler,注意哦，这个handler是Dispatcher自己的，而不是构造器传进来的。而且，这个handler绑定的是子线程的Looper，为什么？请看: Dispatcher#构造器 1this.handler = new DispatcherHandler(dispatcherThread.getLooper(), this); 而dispatcherThread则是一个HandlerThread: Dispatcher内部类 12345static class DispatcherThread extends HandlerThread &#123; DispatcherThread() &#123; super(Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME, THREAD_PRIORITY_BACKGROUND); &#125; &#125; 也就是说，这个handler的消息处理是在子线程进行的!这样就可以避免阻塞主线程的消息队列啦! 好的，再回到刚才的问题，来看下dispatchSubmit方法（不知道大家有没有看晕。。。。）: Dispatcher#dispatchSubmit 123void dispatchSubmit(Action action) &#123; handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action)); &#125; 不用看都知道会发消息给handler。而handler收到这个消息之后调用了这个方法: 1dispatcher.performSubmit(action); 果断跟进去: Dispatcher#performSubmit 1234567891011121314151617181920212223242526272829303132333435void performSubmit(Action action, boolean dismissFailed) &#123;//注意哦，这里已经不在主线程了，而是在dispatcher线程(HandlerThread) if (pausedTags.contains(action.getTag())) &#123;//此任务是否被暂停 pausedActions.put(action.getTarget(), action); if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(), &quot;because tag &apos;&quot; + action.getTag() + &quot;&apos; is paused&quot;); &#125; return; &#125; BitmapHunter hunter = hunterMap.get(action.getKey()); if (hunter != null) &#123; hunter.attach(action); return; &#125; if (service.isShutdown()) &#123;//线程池是否关闭 if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), &quot;because shut down&quot;); &#125; return; &#125; //创建hunter hunter = forRequest(action.getPicasso(), this, cache, stats, action); hunter.future = service.submit(hunter); hunterMap.put(action.getKey(), hunter); if (dismissFailed) &#123; failedActions.remove(action.getTarget()); &#125; if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId()); &#125; &#125; 首先创建了一个BitmapHunter,它继承自Runnable,可以被线程池调用。然后判断线程池有没有关闭，如果没有的话，就会将这个bitmapHunter丢到线程池里面，即调用刚才说的submit方法。 我们先看下forRequest方法里面干了什么: BitmapHunter#forRequest 12345678910111213141516static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats, Action action) &#123; Request request = action.getRequest(); List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers(); // Index-based loop to avoid allocating an iterator. //noinspection ForLoopReplaceableByForEach for (int i = 0, count = requestHandlers.size(); i &lt; count; i++) &#123; RequestHandler requestHandler = requestHandlers.get(i); if (requestHandler.canHandleRequest(request)) &#123; return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler); &#125; &#125; //没有人能处理这个请求，那么交给ERRORING_HANDLER,它会直接抛异常 return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER); &#125; 还记得大明湖畔的Picasso么?在它的构造器中创建了若干RequestHandler,用于处理不同的加载请求，在这里，它会遍历这些requestHandler，看谁可以处理当前请求，如果发现了，那就创建BitmapHandler,并把这个requestHandler传进去， 线程池在收到BitmapHunter之后，会调用其run方法，那么我们就来看下: BitmapHunter#run 1234567891011121314151617181920212223242526272829303132333435363738@Override public void run() &#123; try &#123; updateThreadName(data); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(this)); &#125; result = hunt(); if (result == null) &#123; dispatcher.dispatchFailed(this); &#125; else &#123; dispatcher.dispatchComplete(this); &#125; &#125; catch (Downloader.ResponseException e) &#123; if (!e.localCacheOnly || e.responseCode != 504) &#123; exception = e; &#125; dispatcher.dispatchFailed(this); &#125; catch (NetworkRequestHandler.ContentLengthException e) &#123; exception = e; dispatcher.dispatchRetry(this); &#125; catch (IOException e) &#123; exception = e; dispatcher.dispatchRetry(this); &#125; catch (OutOfMemoryError e) &#123; StringWriter writer = new StringWriter(); stats.createSnapshot().dump(new PrintWriter(writer)); exception = new RuntimeException(writer.toString(), e); dispatcher.dispatchFailed(this); &#125; catch (Exception e) &#123; exception = e; dispatcher.dispatchFailed(this); &#125; finally &#123; Thread.currentThread().setName(Utils.THREAD_IDLE_NAME); &#125; &#125; 核心逻辑是由hunt方法完成的，下面一堆catch语句分别捕捉不同的异常然后上报给dispatcher进行处理。而hunt方法里面肯定会调用RequestHandler的load方法: BitmapHunter#hunt 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Bitmap hunt() throws IOException &#123; Bitmap bitmap = null; //依然先从缓存拿 if (shouldReadFromMemoryCache(memoryPolicy)) &#123; bitmap = cache.get(key); if (bitmap != null) &#123; stats.dispatchCacheHit(); loadedFrom = MEMORY; if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId(), &quot;from cache&quot;); &#125; return bitmap; &#125; &#125; //缓存没有命中的话，再调用requestHandler.load data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy; RequestHandler.Result result = requestHandler.load(data, networkPolicy); //拿到结果 if (result != null) &#123; loadedFrom = result.getLoadedFrom(); exifRotation = result.getExifOrientation(); //从结果中拿bitmap bitmap = result.getBitmap(); // If there was no Bitmap then we need to decode it from the stream. if (bitmap == null) &#123; InputStream is = result.getStream(); try &#123; //压缩 bitmap = decodeStream(is, data); &#125; finally &#123; Utils.closeQuietly(is); &#125; &#125; &#125; if (bitmap != null) &#123; if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId()); &#125; stats.dispatchBitmapDecoded(bitmap); //图片变换 if (data.needsTransformation() || exifRotation != 0) &#123; synchronized (DECODE_LOCK) &#123; if (data.needsMatrixTransform() || exifRotation != 0) &#123; bitmap = transformResult(data, bitmap, exifRotation); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId()); &#125; &#125; if (data.hasCustomTransformations()) &#123; bitmap = applyCustomTransformations(data.transformations, bitmap); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), &quot;from custom transformations&quot;); &#125; &#125; &#125; if (bitmap != null) &#123; stats.dispatchBitmapTransformed(bitmap); &#125; &#125; &#125; return bitmap; &#125; 这里假设是一个网络请求，那么最终NetworkRequestHandler会处理请求： NetworkRequestHandler#load 12345678910111213141516171819202122232425262728293031@Override public Result load(Request request, int networkPolicy) throws IOException &#123; //这个downloader也是Dispatcher创建的时候传进来的 Response response = downloader.load(request.uri, request.networkPolicy); if (response == null) &#123; return null; &#125; //判断是从缓存还是网络拿的 Picasso.LoadedFrom loadedFrom = response.cached ? DISK : NETWORK; //从响应中拿到bitmap Bitmap bitmap = response.getBitmap(); if (bitmap != null) &#123; return new Result(bitmap, loadedFrom); &#125; //如果是从网络返回的，那么拿到的是流对象 InputStream is = response.getInputStream(); if (is == null) &#123; return null; &#125; // Sometimes response content length is zero when requests are being replayed. Haven&apos;t found // root cause to this but retrying the request seems safe to do so. if (loadedFrom == DISK &amp;&amp; response.getContentLength() == 0) &#123; Utils.closeQuietly(is); throw new ContentLengthException(&quot;Received response with 0 content-length header.&quot;); &#125; if (loadedFrom == NETWORK &amp;&amp; response.getContentLength() &gt; 0) &#123; stats.dispatchDownloadFinished(response.getContentLength()); &#125; //将结果封装返回 return new Result(is, loadedFrom); &#125; 现在我们关注下这个downloader的前世今生,如果用户没有自定义的话，那将使用默认downloader: Picasso#Builder#build() 1downloader = Utils.createDefaultDownloader(context); Utils#createDefaultDownloader 12345678static Downloader createDefaultDownloader(Context context) &#123; try &#123; Class.forName(&quot;com.squareup.okhttp.OkHttpClient&quot;); return OkHttpLoaderCreator.create(context); &#125; catch (ClassNotFoundException ignored) &#123; &#125; return new UrlConnectionDownloader(context); &#125; 首先反射下，看有没有依赖okhttp，如果依赖的话，那就使用OkHttpClient喽，否则就使用默认的HttpUrlConnection了。注:其实从4.4开始，okhttp已经作为HttpUrlConnection的实现引擎了。 可以从picasso的pom文件里面看到，okhttp是optional的: 12345&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 以UrlConnectionDownloader为例，看下它的load方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Override public Response load(Uri uri, int networkPolicy) throws IOException &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; installCacheIfNeeded(context); &#125; HttpURLConnection connection = openConnection(uri); connection.setUseCaches(true); if (networkPolicy != 0) &#123; String headerValue; if (NetworkPolicy.isOfflineOnly(networkPolicy)) &#123; headerValue = FORCE_CACHE; &#125; else &#123; StringBuilder builder = CACHE_HEADER_BUILDER.get(); builder.setLength(0); if (!NetworkPolicy.shouldReadFromDiskCache(networkPolicy)) &#123; builder.append(&quot;no-cache&quot;); &#125; if (!NetworkPolicy.shouldWriteToDiskCache(networkPolicy)) &#123; if (builder.length() &gt; 0) &#123; builder.append(&apos;,&apos;); &#125; builder.append(&quot;no-store&quot;); &#125; headerValue = builder.toString(); &#125; connection.setRequestProperty(&quot;Cache-Control&quot;, headerValue); &#125; int responseCode = connection.getResponseCode(); if (responseCode &gt;= 300) &#123; connection.disconnect(); throw new ResponseException(responseCode + &quot; &quot; + connection.getResponseMessage(), networkPolicy, responseCode); &#125; long contentLength = connection.getHeaderFieldInt(&quot;Content-Length&quot;, -1); boolean fromCache = parseResponseSourceHeader(connection.getHeaderField(RESPONSE_SOURCE)); return new Response(connection.getInputStream(), fromCache, contentLength);&#125; 注意哦，Disk Cache功能是在这里做掉的，它基于Http语义来判断是否缓存.另，返回的是inputStream流，而不是Bitmap对象. 好的，现在我们回到BitmapHunter#run(),它在拿到结果后会将结果交给dispatcher BitmapHunter#run() 12345if (result == null) &#123; dispatcher.dispatchFailed(this); &#125; else &#123; dispatcher.dispatchComplete(this); &#125; 我们看dispatcher.dispatchComplete(this),它会把消息发给自己内部的handler，也就是刚才说的Looper在子线程 的handler,handler将做如下处理: 12BitmapHunter hunter = (BitmapHunter) msg.obj;dispatcher.performComplete(hunter); 注意哦，BitmapHunter会持有网络请求回来的Bitmap引用.来看下performComplete: Dispatcher#performComplete 12345678910void performComplete(BitmapHunter hunter) &#123; if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123; cache.set(hunter.getKey(), hunter.getResult()); &#125; hunterMap.remove(hunter.getKey()); batch(hunter); if (hunter.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), &quot;for completion&quot;); &#125; &#125; 首先会根据事先设置的缓存策略决定是否将结果加到内存缓存。然后调用batch方法，从名字就可以知道，这个方法会把结果暂存，然后批量处理(等待200ms)，这样做也是为了防止短时间大量任务阻塞消息队列。到时间后，就会执行performBatchComplete,此方法会将这个批次的所有结果一次性发给主线程的Handler，也就是Picasso中定义的Handler: Dispatcher#performBatchComplete 123456void performBatchComplete() &#123; List&lt;BitmapHunter&gt; copy = new ArrayList&lt;BitmapHunter&gt;(batch); batch.clear(); mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy)); logBatch(copy);&#125; 主线程收到消息后会进行处理: 1234567case HUNTER_BATCH_COMPLETE: &#123; @SuppressWarnings(&quot;unchecked&quot;) List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj; //noinspection ForLoopReplaceableByForEach for (int i = 0, n = batch.size(); i &lt; n; i++) &#123; BitmapHunter hunter = batch.get(i); hunter.picasso.complete(hunter); &#125; 对batch中每个BitmapHunter调用complete方法,而complete方法会调用deliverAction方法,最终其实调用的是具体action的complete方法，如果是ImageView的话，那就是ImageViewAction的complete方法: ImageViewAction#complete 12345678910111213141516171819@Override public void complete(Bitmap result, Picasso.LoadedFrom from) &#123; if (result == null) &#123; throw new AssertionError( String.format(&quot;Attempted to complete action with no result!\n%s&quot;, this)); &#125; ImageView target = this.target.get(); if (target == null) &#123; return; &#125; Context context = picasso.context; boolean indicatorsEnabled = picasso.indicatorsEnabled; PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled); if (callback != null) &#123; callback.onSuccess(); &#125; &#125; 注意看这一句，ImageView target = this.target.get(),因为target是ImageView的弱引用，在下载过程中，ImageView可能已经被销毁了，所以这里要做下判断。 如果没有被回收，那么图片最终通过PicassoDrawable.setBitmap()方法被设置到ImageView上.这个PicassoDrawable提供了fade动画. 好了，分析基本完毕,下面是整个流程的时序图. 简单总结下当我们执行Picasso.with(context).load(url).into(imageview)时，首先会构造Picasso实例，然后会根据url创建请求，然后请求会被交给Dispatcher,Dispatcher将在子线程对请求任务进行调度，将请求任务交给线程池执行，执行完毕后，将结果传给主线程的handler，最后在主线程中将图片设置到ImageView上. 下面是我在测试的时候截的图,注意每张图所在线程都不一样哦: 1.主线程中调用dispatchSubmit 2.Dispatcher线程对请求任务进行调度 3.线程池中执行请求任务 其他需要关注的点 关于缓存策略 Picasso的缓存是内存缓存+磁盘缓存，内存缓存基于LruCache类，可配置替换。磁盘缓存依赖于http缓存，不可配置。先看内存缓存.内存缓存比较简单，是通过LinkedHashMap实现.读缓存时机:生成了请求Request对象，准备创建Action加载任务之前，会先去缓存里面查找下. RequestCreator#into 1234567891011121314if (shouldReadFromMemoryCache(memoryPolicy)) &#123; Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey); if (bitmap != null) &#123; picasso.cancelRequest(target); setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled); if (picasso.loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), &quot;from &quot; + MEMORY); &#125; if (callback != null) &#123; callback.onSuccess(); &#125; return; &#125; &#125; `写缓存时机`:图片从网络或者其他地方加载成功后，即在`BitmapHunter`的run方法执行结束的时候. Dispatcher#performComplete 1234 if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123; cache.set(hunter.getKey(), hunter.getResult()); &#125; 注意哦，缓存的是经过压缩之后的图片（如果你使用了`fit`或者`resize`方法的话）， 再看磁盘缓存。 如果你是使用`UrlConnectionDownloader`的话,那很不幸，缓存只在Api&gt;14上生效，因为缓存依赖于`HttpResponseCache`. 如果你依赖了`okhttp`，那么缓存策略始终是有效的。另外需要说明的是，既然是http缓存，那么缓存的可用性依赖于http响应是 否允许缓存，也就是说得看响应中是否携带`Cache-Control`、`Expires`等字段.对于这块不了解的话，可以参考我的这篇文章: [HttpCache in android](http://blog.csdn.net/chdjj/article/details/49745793) 还有一点，缓存的路径是 应用cache目录/picasso-cache 文件夹.具体代码参考`Utils.createDefaultCacheDir`方法 关于预加载 首先要注意的是Callback是一个强引用，如果你使用带Callback的重载形式的话，只有当Request结束的时候才会释放 引用，在此期间你的Activity/Fragment等组件引用不会被释放.因此你需要注意内存泄露的情形. 怎么实现?很简单拉，调fetch的时候创建了FetchAction,然后其他流程上面描述的一样,最终在Dispatcher.performComplete 的时候将结果写入内存缓存，结果回传到主线程的时候，调用了FetchAction的complete方法，这里面不对Bitmap做 任何处理就行拉: FetchAction#complete 12345@Override void complete(Bitmap result, Picasso.LoadedFrom from) &#123; if (callback != null) &#123; callback.onSuccess(); &#125; &#125; 关于图形变换 图形变换在Picasso中被抽象成Transformation接口，具体的变换操作由transform方法实现.Request维护一个 图形变换的列表List&lt;Transformation&gt;,当图片加载成功后，BitmapHunter中将会遍历这个变换集合，依次进行变换， 最后返回变换后的bitmap.恩，其实是一个回调的思想，将操作封装到接口中交给系统，系统在某个特定时机调用你的接口。 具体代码: BitmapHunter#applyCustomTransformations 1234567891011121314151617181920static Bitmap applyCustomTransformations(List&lt;Transformation&gt; transformations, Bitmap result) &#123; for (int i = 0, count = transformations.size(); i &lt; count; i++) &#123; final Transformation transformation = transformations.get(i); Bitmap newResult; try &#123; newResult = transformation.transform(result); &#125; catch (final RuntimeException e) &#123; Picasso.HANDLER.post(new Runnable() &#123; @Override public void run() &#123; throw new RuntimeException( &quot;Transformation &quot; + transformation.key() + &quot; crashed with exception.&quot;, e); &#125; &#125;); return null; &#125; .... result = newResult; &#125; return result; &#125; 关于CleanupThread Picasso类中有一个内部线程叫CleanupThread,这是一个daemon线程,它的工作是找到那些Target(比如说ImageView)已经被回收但是所对应的Request请求还在继续的任务(Action),找到之后,会取消对应的请求,避免资源浪费. 看下代码: Picasso#CleanupThread 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private static class CleanupThread extends Thread &#123; private final ReferenceQueue&lt;Object&gt; referenceQueue; private final Handler handler; CleanupThread(ReferenceQueue&lt;Object&gt; referenceQueue, Handler handler) &#123;//关联主线程的handler,refreenceQueue this.referenceQueue = referenceQueue; this.handler = handler; setDaemon(true); setName(THREAD_PREFIX + &quot;refQueue&quot;); &#125; @Override public void run() &#123; Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND); while (true) &#123; try &#123; // Prior to Android 5.0, even when there is no local variable, the result from // remove() &amp; obtainMessage() is kept as a stack local variable. // We&apos;re forcing this reference to be cleared and replaced by looping every second // when there is nothing to do. // This behavior has been tested and reproduced with heap dumps. RequestWeakReference&lt;?&gt; remove = (RequestWeakReference&lt;?&gt;) referenceQueue.remove(THREAD_LEAK_CLEANING_MS); Message message = handler.obtainMessage(); if (remove != null) &#123; message.what = REQUEST_GCED; message.obj = remove.action; handler.sendMessage(message); &#125; else &#123; message.recycle(); &#125; &#125; catch (InterruptedException e) &#123; break; &#125; catch (final Exception e) &#123; handler.post(new Runnable() &#123; @Override public void run() &#123; throw new RuntimeException(e); &#125; &#125;); break; &#125; &#125; &#125; void shutdown() &#123; interrupt(); &#125; &#125; 可以看到它会不断轮询`ReferenceQueue`,找到这样的`reference`,就交给`handler`,`handler`会从`reference`中拿到`action`, 并取消请求. 12345678case REQUEST_GCED: &#123; Action action = (Action) msg.obj; if (action.getPicasso().loggingEnabled) &#123; log(OWNER_MAIN, VERB_CANCELED, action.request.logId(), &quot;target got garbage collected&quot;); &#125; action.picasso.cancelExistingRequest(action.getTarget()); break; &#125; 那么这个`ReferenceQueue`又是如何关联`Action`的呢？这个可以从`Action`的构造器中拿到答案: 12this.target =//RequestWeakReference是WeakReference的子类 target == null ? null : new RequestWeakReference&lt;T&gt;(this/*即Action本身*/, target, picasso.referenceQueue); 可以看到两点: 每个Action都会关联Picasso中唯一的referenceQueue实例; 每个RequestWeakReference都会同时关联Target和Action. resume/pause pause 流程如下。 可能会有疑问的地方在于Dispatcher#performPauseTag中遍历所有的hunter，都会调一次cancel,这似乎会取消所有的请求。但其实不是这样的,可以看下BitmapHunter#cancel方法的代码: 123456boolean cancel() &#123; return action == null &amp;&amp; (actions == null || actions.isEmpty()) &amp;&amp; future != null &amp;&amp; future.cancel(false);&#125; 注意到它会判断`action`是否为空，如果不为空就不会取消了。而在`Dispatcher#performPauseTag`中会把`tag`匹配的 `action`与对应的`BitmapHunter`解绑(`detach`),让`BitmapHunter`的action为空.所以这并不影响其他任务的执行。 resume 流程如下。 其实就是遍历pausedActions，挨个重新交给dispatcher分发。 作者的提交记录: https://github.com/square/picasso/pull/665/files#diff-f11286bbae6959a7a5dd74bf99276f1aR229 图片压缩 图片压缩的原理通常都是利用BitmapFactory#Options类，先将injustDecodeBounds设置为true,对Bitmap进行一次解码，拿到outWidth/outHeight，即实际宽高,然后根据期望压缩到的宽和高算出inSampleSize,最后将injustDecodeBounds设置为false，再对Bitmap进行一次解码即可。另一种压缩的方法是设置图片的显示效果,比如ARGB_8888等等.Picasso综合了利用这两种方案. 详细代码参考BitmapHunter#decodeStream、RequestHandler#createBitmapOptions、RequestHandler#calculateInSampleSize这三个方法，有个需要注意的地方，只有当设置图片的宽高时(调用了fit或者resize)才会计算smpleSize进行压缩。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Picasso</tag>
        <tag>图片加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android基础--Android布局相关]]></title>
    <url>%2Fandroid%E5%9F%BA%E7%A1%80-Android%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3.html</url>
    <content type="text"><![CDATA[Android布局相关Android常见的布局 LinearLayout 线性布局 RelativeLatout 相对布局 AbsoluteLayout 绝对布局 TableLayout 桌面布局 FrameLayout 帧布局 LinearLayout线性布局 orientation 属性是指定线性布局的排列方向: horizontal 水平vertical 垂直 gravity属性是指定当前控件内容显示位置: left 左边right 右边top 上边bottom 底边 layout_gravity属性是指定当前控件在父元素的位置: left 左边right 右边top 上边bottom 底边 layout_weightSum(权重)属性是把线性布局中剩余空间分成N份. layout_weight (权重)属性是指定当前控件在父元素(线性布局)中占N份. visibility属性是控制布局是否显示: visible 显示invisible 不显示但占空间gone 隐藏 RelativeLatout相对布局 android:layout_toRightOf 在指定控件的右边 android:layout_toLeftOf 在指定控件的左边 android:layout_above 在指定控件的上边 android:layout_below 在指定控件的下边 android:layout_alignBaseline 跟指定控件水平对齐 android:layout_alignLeft 跟指定控件左对齐 android:layout_alignRight 跟指定控件右对齐 android:layout_alignTop 跟指定控件顶部对齐 android:layout_alignBottom 跟指定控件底部对齐 android:layout_alignParentLeft 是否跟父布局左对齐 android:layout_alignParentTop 是否跟父布局顶部对齐 android:layout_alignParentRight 是否跟父布局右对齐 android:layout_alignParentBottom 是否跟父布局底部对齐 android:layout_centerVertical 在父布局中垂直居中 android:layout_centerHorizontal 在父布局中水平居中 android:layout_centerInParent 在父布局中居中 AbsoluteLayout绝对布局 android:layout_x 指定控件在父布局的x轴坐标 android:layout_y 指定控件在父布局的y轴坐标 FrameLayout 帧布局 帧布局每次添加的控件都显示在最上面，最后显示在界面上的是最后添加的一个控件 TableLayout 桌面布局 android:shrinkColumns 收缩列 android:stretchColumns 拉伸列 android:collapseColumns 隐藏列 android:layout_column 指定列(作用在列的身上) android:layout_span 合并列(作用在列的身上) TableRow单元行里的单元格的宽度小于默认的宽度时就不起作用,其默认是fill_parent，高度可以自定义大小 .]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android基础--Fragment使用方法]]></title>
    <url>%2Fandroid%E5%9F%BA%E7%A1%80-Fragment%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[##添加Fragment的方法 说明：在这里使用的是android-support-v4.jar中的Fragment，而不是系统自带的Fragment，V4包的兼容性更强。 ###静态添加方法 新建一个项目FragmentDemo1，新建一个布局文件fragment_frist.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ffff0a10&quot; &gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Fragment-----1&quot; android:textSize=&quot;20sp&quot; android:textColor=&quot;#f9151208&quot; /&gt; &lt;/LinearLayout&gt; 同样的，我们再新建一个布局文件fragment——second.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ffff0a10&quot; &gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Fragment-----1&quot; android:textSize=&quot;20sp&quot; android:textColor=&quot;#f9151208&quot; /&gt; &lt;/LinearLayout&gt; 然后，新建一个java文件，这里我命名为FirstFragment，这个类是继承Frament（V4包中的，注意导包），代码如下： package com.lucas.fragmentdemo1.fragments; import android.os.Bundle; import android.support.annotation.Nullable; import android.support.v4.app.Fragment; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import com.lucas.fragmentdemo1.R; /** * Created by lucas on 2015/9/10. * Author:lucas * email:huangxiang1992@hotmail.com * &lt;p/&gt; * FragmentDemo1 */ public class FirstFragment extends Fragment { @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.fragment_first, container, false); } } 同样的，在继续新建一个java文件，SecondFragment: package com.lucas.fragmentdemo1.fragments; import android.app.Fragment; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import com.lucas.fragmentdemo1.R; /** * Created by lucas on 2015/9/10. * Author:lucas * email:huangxiang1992@hotmail.com * &lt;p/&gt; * FragmentDemo1 */ public class SecondFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.fragment_second, container, false); } } 接下来就是MainActivity.java及其布局文件的编写了，首先来看java文件： package com.lucas.fragmentdemo1; import android.os.Bundle; import android.support.v4.app.FragmentActivity; public class MainActivity extends FragmentActivity { /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } } 代码非常简单，就是要注意我们的Fragment文件是继承的v4包中的Fragment，那么我们的Activity也要继承v4包中的FragmentActivity，而不是Activity，不然会产生类型转换异常。 接下来，我们来看布局文件main.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; &gt; &lt;fragment android:id=&quot;@+id/fragment_one&quot; android:name=&quot;com.lucas.fragmentdemo1.fragments.FirstFragment&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;fragment android:id=&quot;@+id/fragment_two&quot; android:name=&quot;com.lucas.fragmentdemo1.fragments.SecondFragment&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;/LinearLayout&gt; 静态添加fragment，即是在Activity的布局文件中，指定其要加入的Fragment的完整名称即可。 ###动态添加方法 相比与静态添加，我们更倾向于动态的添加Fragment，下面索要说的就是如何在代码中动态的添加Fragment。 我们继续引用上述的Fragment文件，稍作修改即可。 首先对main.xml文件修改一下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 下面是MainActivity的代码，比较简单，如下： package com.lucas.fragmentdemo1; import android.os.Bundle; import android.support.v4.app.FragmentActivity; import android.support.v4.app.FragmentManager; import android.support.v4.app.FragmentTransaction; import android.view.View; import android.widget.Button; import com.lucas.fragmentdemo1.fragments.FirstFragment; import com.lucas.fragmentdemo1.fragments.SecondFragment; public class MainActivity extends FragmentActivity { private Button btnFirst; private Button btnSecond; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); btnFirst = (Button) findViewById(R.id.fragment_one); btnSecond = (Button) findViewById(R.id.fragment_two); btnFirst.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { FragmentManager manager = getSupportFragmentManager(); FragmentTransaction transaction = manager.beginTransaction(); FirstFragment firstFragment = new FirstFragment(); transaction.add(R.id.fragment_show,firstFragment); transaction.commit(); } }); btnSecond.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { FragmentManager manager1 = getSupportFragmentManager(); FragmentTransaction transaction1 = manager1.beginTransaction(); SecondFragment secondFragment = new SecondFragment(); transaction1.add(R.id.fragment_show,secondFragment); transaction1.commit(); } }); } } 动态添加Fragment的步骤 获取FragmentManager，在V4包中是通过getSupportFragmentManager获取的。开启一个事务，beginTransaction()。向容器内加入Fragment，通过add或者replace，传入容器的id和fragment的实例。commit(),提交事务。是事务的操作生效。关于事务的提交，注意：一个transaction只能提交一次。 ###Fragment事务 事务，就是用来管理Fragment的。 add(int containerID，Fragment)添加Fragment到容器 replace(int containerId, Fragment) 将container中，原有的Fragment移动和remove,之后，再添加指定的Fragment. remove(Fragment) 删除 Fragment。 commit() 使事务的操作⽣效。 事务的提交，一个transaction 只能提交一次； ####Fragment回退栈 每一个FragmentManager都会保留一个回退栈，这个回退栈记录的是事务的操作步骤 当Activity按返回键的时候，如果内部的回退栈有多个事务记录，那么就回一步一步的后退，直到回退栈清空，才退出。 应用场景，通常都是一个功能的内部延伸，才会采用回退栈，例如：“联系人列表–&gt;联系人详情 –&gt;联系人编辑”这种，当用户点击返回键，就需要一步一步后退。 ####FragmentTransaction事务回滚方法及回退栈内容监听 Fragment的回退栈，是一种记录，记录事务的操作，如果事务被添加到回退栈，那么一般情况下，当返回的时候，会对事务的操作进行一个逆转，从而恢复事务执行之前的内容。 若想使用回滚功能，我们只需要在commit之前，使用addToBackStack()将其添加到回退栈之中。在需要回退的时候，使用PopBackStack()将最上层的操作弹出回退栈。 回退栈的原理： 当事务被添加到回退栈的时候，FragmentManager会将事务的操作，添加到回退栈中，作为一个记录存在。 当返回的时候，查找回退栈，如果有内容，那么对记录进行反转的操作。如add反转为remove，replace调整为remove和add，从而还原事务之前之前的状态。 FragmentManager.PopBackStack() 弹出回退栈，相当于后退键的操作。 使用FragmentManager.PopBackStack(String name,int flags)可以回退到指定的位置。 ####回退栈主动返回的操作 通常，Activity点击返回键，会触发回退栈的返回操作，返回的方式是一个记录一个记录的返回 对于FragmentManager可以手动的管理回退栈，通过方法，进行弹出记录，跳跃返回两种操作。 当事务添加返回栈操作的时候，使用addToBackStack(String name)这个方法，如果指定名称，就可以从其它回退栈记录跳到指定名称的记录位置。 ####回退栈操作的API 回退栈可以通过事务 addToBackStack(String name)来记录， name 给记录指定名称； 回退栈由 FragmentManager 来管理，通过这个类可以直接进⾏回退栈的控制，包括获取回退栈个数，直接弹出回退栈记录，以及跳转到指定记录上。这个记录之上的内容，全部弹出。 FragmentTransaction.addToBackStack(String name) FragmentManager.popBackStack() 返回上一个记录 popBackStack(String name, int flags) 返回到指定的记录上， flags 代表是否将指定名称的记录也弹出。 boolean popBackStackImmediate(String name , int flags)立即弹出，如果弹出成功，返回true，否则返回false。 ####关于事务的注意事项 事务只能够执行一次commit()；每次进行Fragment操作的时候，都需要使用FragmentManager.beginTransaction()返回一个新的事务，才能够正确进行操作。 不要将事务声明为成员变量。！！！ ####Fragment事务操作与生命周期 事务操作，对于生命周期，会有直接的影响。 事务在添加Fragment的时候， Fragment 生命周期从onAttach 开始执行，直到显示位置 onResume状态； 事务在进⾏replace的时候，会将在容器中存在Fragment ，进行移除操作， 从 onPause() 状态，执行 到 onDetach()，最终这个Fragment与Activity没有任何关系了；新的Fragment和添加这样的生命周期。 ####关于Fragment的查找 findFragmentById(int id);用于查找xml布局中包含的Fragment，就是为什么 &lt; fragment &gt; 标签必须要有id, 或者tag属性。 findFragmentByTag(String tag); 用于查找 xml中，或者是代码添加的Fragment，这些Fragment 通过tag命名的。 在add的时候，可以指定 tag参数： add(int, Fragment,String tag) 将Fragment命名，需要获取的时候，findFragmentByTag就可以找到了。 ####Fragment增删改查方法介绍 add方法 FragmentTransaction add(int containerViewId, Fragment f)将Fragment 添加到当前Activity布局中 指定id的ViewGroup中.containerViewId代表：Fragment添加到哪里，一定是一个容器。 replace方法 replace(int containerViewId, Fragment f) 将指定ID的容器内部的内容替换为 fragment。 remove方法 删除方法：用于删除特定的Fragment, 指定的Fragment将会从布局中直接删掉。不需要指定容器，因为：一个Fragment只能够在一个容器中存在，不会同时在多个容器中存在。删除的方法使用的场景： replace() 方法实际上进行的是 先删除旧的Fragment的内容，再进行add()方法的操作。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android基础--AsyncTask]]></title>
    <url>%2Fandroid%E5%9F%BA%E7%A1%80-AsyncTask.html</url>
    <content type="text"><![CDATA[##AsyncTask详解 ###android中的线程问题 在android中，通常将线程分为两种，一种是main线程，一种是worker线程。main thread通常也称为UI Thread。当我们需要完成一个耗时的操作的时候，UI Thread可能会被阻塞，当阻塞超过5秒时，会出现ANR（Application Not Respoding）现象。另外由于Android UI控件是不安全的。所以我们不能在UI Thread之外的线程中对我们的UI控件进行操作，因此在android的多线程编程中，有两条非常的重要的原则必须遵守： 绝对不能在UI Thread中进行耗时的操作，不能阻塞我们的UI Thread。 不能在UI之外的线程中操作我们的UI元素。 ###AsyncTask——三个泛型，四个步骤 异步任务，从字面上来说，就是我们的UI主线程运行的时候，异步的完成一些操作。AsyncTask允许我们执行一个异步的任务在后台，我们可以将耗时的操作放在异步任务中执行，并随时将任务执行的结果返回给我们的UI线程来更新我们的控件。 通俗的来讲，AsyncTask就相当于android给我们提供了一个多线程编程的框架，介乎于Thread和Handler之间，我们如果需要定义一个AsyncTask，那么就需要定义一个类来继承AsyncTask这个抽象类，并且实现其唯一的一个doInBackgroud抽象方法。 ####三个泛型 三个泛型指的是当我们定义一个类来继承AsyncTask这个类的时候，我们需要为其指定三个泛型参数。 AsyncTask &lt;Params, Progress, Result&gt; params：这个泛型指的是我们传递给异步任务执行时参数类型。 Progress：这个泛型指定的是我们的异步任务在执行的时候将执行的进度返回给UI线程的参数的类型。 Result：这个泛型指定的异步任务执行完后返回给UI线程的结果的类型。 我们在顶一个一个类继承AsyncTask类的时候，必须指定好这三个泛型的类型，如果不指定的话，则将其写成Void。####四个步骤 onPreExecute():这个方法是在执行异步任务之前的时候执行，并且是在UI Thread当中执行的，通常我们在这个方法里做一些UI空间初始化的动作。 doInBackground(Params… params):在onPreExecute()方法执行完之后，会马上执行这个方法，这个方法就是来处理异步任务的方法，Android操作系统会在后台的线程池当中开启一个worker thread来执行我们的这个方法，所以这个方法是在worker thread当中执行的，这个方法执行完之后就可以将我们的执行结果发送给我们的最后一个 onPostExecute 方法，在这个方法里，我们可以从网络当中获取数据等一些耗时的操作。 onProgressUpdate(Progess… values):这个方法也是在UI Thread当中执行的，我们在异步任务执行的时候，有时候需要将执行的进度返回给我们的UI界面，例如下载一张网络图片，我们需要时刻显示其下载的进度，就可以使用这个方法来更新我们的进度。这个方法在调用之前，我们需要在 doInBackground 方法中调用一个 publishProgress(Progress) 的方法来将我们的进度时时刻刻传递给 onProgressUpdate 方法来更新。 onPostExecute(Result… result):当我们的异步任务执行完之后，就会将结果返回给这个方法，这个方法也是在UI Thread当中调用的，我们可以将返回的结果显示在UI控件上。 为什么我们的AsyncTask抽象类只有一个 doInBackground 的抽象方法呢？？ 原因是，我们如果要做一个异步任务，我们必须要为其开辟一个新的Thread，让其完成一些操作，而在完成这个异步任务时，我可能并不需要弹出要给ProgressDialog，我并不需要随时更新我的ProgressDialog的进度条，我也并不需要将结果更新给我们的UI界面，所以除了 doInBackground 方法之外的三个方法，都不是必须有的，因此我们必须要实现的方法是 doInBackground 方法。 通过AsyncTask来从网络上下载一张图片(不显示下载进度) 布局文件 1234567891011121314151617181920212223&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;ImageView android:id="@+id/imageView" android:layout_width="wrap_content" android:layout_height="200dp" android:layout_alignParentRight="true" android:layout_alignParentTop="true" android:scaleType="fitCenter"/&gt; &lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@+id/imageView" android:layout_centerHorizontal="true" android:layout_marginTop="41dp" android:text="从网络上下载一张图片" /&gt;&lt;/RelativeLayout&gt; AndroidManifest.xml文件： 就是很简单的一个ImageView控件和一个Button控件，当点击Button控件时，弹出一个ProgressDialog，然后开启一个异步任务，从网络中下载一张图片，并更新到我们的ImageView上。这里还要注意一点，如果我们要使用手机访问网络，必须还要给其授权才行，在后续的学习当中，将会详细讲解Android当中的授权的知识。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.xiaoluo.android_asynctast" android:versionCode="1" android:versionName="1.0" &gt; &lt;uses-sdk android:minSdkVersion="8" android:targetSdkVersion="18" /&gt; &lt;!-- 授权手机能够访问网络 --&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;application android:allowBackup="true" android:icon="@drawable/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme" &gt; &lt;activity android:name="com.xiaoluo.android_asynctast.MainActivity" android:label="@string/app_name" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt;``` &gt;* Activity代码：```java public class MainActivity extends Activity &#123; private Button button; private ImageView imageView; private ProgressDialog progressDialog; private final String IMAGE_PATH = "http://developer.android.com/images/home/kk-hero.jpg"; // private final String IMAGE_PATH2 = "http://ww2.sinaimg.cn/mw690/69c7e018jw1e6hd0vm3pej20fa0a674c.jpg"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button); imageView = (ImageView)findViewById(R.id.imageView); // 弹出要给ProgressDialog progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setTitle("提示信息"); progressDialog.setMessage("正在下载中，请稍后......"); // 设置setCancelable(false); 表示我们不能取消这个弹出框，等下载完成之后再让弹出框消失 progressDialog.setCancelable(false); // 设置ProgressDialog样式为圆圈的形式 progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 在UI Thread当中实例化AsyncTask对象，并调用execute方法 new MyAsyncTask().execute(IMAGE_PATH); &#125; &#125;); &#125; /** * 定义一个类，让其继承AsyncTask这个类 * Params: String类型，表示传递给异步任务的参数类型是String，通常指定的是URL路径 * Progress: Integer类型，进度条的单位通常都是Integer类型 * Result：byte[]类型，表示我们下载好的图片以字节数组返回 * @author xiaoluo * */ public class MyAsyncTask extends AsyncTask&lt;String, Integer, byte[]&gt; &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); // 在onPreExecute()中我们让ProgressDialog显示出来 progressDialog.show(); &#125; @Override protected byte[] doInBackground(String... params) &#123; // 通过Apache的HttpClient来访问请求网络中的一张图片 HttpClient httpClient = new DefaultHttpClient(); HttpGet httpGet = new HttpGet(params[0]); byte[] image = new byte[]&#123;&#125;; try &#123; HttpResponse httpResponse = httpClient.execute(httpGet); HttpEntity httpEntity = httpResponse.getEntity(); if(httpEntity != null &amp;&amp; httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; image = EntityUtils.toByteArray(httpEntity); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; httpClient.getConnectionManager().shutdown(); &#125; return image; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); &#125; @Override protected void onPostExecute(byte[] result) &#123; super.onPostExecute(result); // 将doInBackground方法返回的byte[]解码成要给Bitmap Bitmap bitmap = BitmapFactory.decodeByteArray(result, 0, result.length); // 更新我们的ImageView控件 imageView.setImageBitmap(bitmap); // 使ProgressDialog框消失 progressDialog.dismiss(); &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main, menu); return true; &#125; &#125; 通过AsyncTask来从网络上下载一张图片(显示下载进度) 布局文件不变 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public class MainActivity extends Activity&#123; private Button button; private ImageView imageView; private ProgressDialog progressDialog; private final String IMAGE_PATH = "http://developer.android.com/images/home/kk-hero.jpg";// private final String IMAGE_PATH2 = "http://ww2.sinaimg.cn/mw690/69c7e018jw1e6hd0vm3pej20fa0a674c.jpg"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button); imageView = (ImageView)findViewById(R.id.imageView); // 弹出要给ProgressDialog progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setTitle("提示信息"); progressDialog.setMessage("正在下载中，请稍后......"); // 设置setCancelable(false); 表示我们不能取消这个弹出框，等下载完成之后再让弹出框消失 progressDialog.setCancelable(false); // 设置ProgressDialog样式为水平的样式 progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; new MyAsyncTask().execute(IMAGE_PATH); &#125; &#125;); &#125; /** * 定义一个类，让其继承AsyncTask这个类 * Params: String类型，表示传递给异步任务的参数类型是String，通常指定的是URL路径 * Progress: Integer类型，进度条的单位通常都是Integer类型 * Result：byte[]类型，表示我们下载好的图片以字节数组返回 * @author xiaoluo * */ public class MyAsyncTask extends AsyncTask&lt;String, Integer, byte[]&gt; &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); // 在onPreExecute()中我们让ProgressDialog显示出来 progressDialog.show(); &#125; @Override protected byte[] doInBackground(String... params) &#123; // 通过Apache的HttpClient来访问请求网络中的一张图片 HttpClient httpClient = new DefaultHttpClient(); HttpGet httpGet = new HttpGet(params[0]); byte[] image = new byte[]&#123;&#125;; try &#123; HttpResponse httpResponse = httpClient.execute(httpGet); HttpEntity httpEntity = httpResponse.getEntity(); InputStream inputStream = null; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); if(httpEntity != null &amp;&amp; httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; // 得到文件的总长度 long file_length = httpEntity.getContentLength(); // 每次读取后累加的长度 long total_length = 0; int length = 0; // 每次读取1024个字节 byte[] data = new byte[1024]; inputStream = httpEntity.getContent(); while(-1 != (length = inputStream.read(data))) &#123; // 每读一次，就将total_length累加起来 total_length += length; // 边读边写到ByteArrayOutputStream当中 byteArrayOutputStream.write(data, 0, length); // 得到当前图片下载的进度 int progress = ((int)(total_length/(float)file_length) * 100); // 时刻将当前进度更新给onProgressUpdate方法 publishProgress(progress); &#125; &#125; image = byteArrayOutputStream.toByteArray(); inputStream.close(); byteArrayOutputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; httpClient.getConnectionManager().shutdown(); &#125; return image; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); // 更新ProgressDialog的进度条 progressDialog.setProgress(values[0]); &#125; @Override protected void onPostExecute(byte[] result) &#123; super.onPostExecute(result); // 将doInBackground方法返回的byte[]解码成要给Bitmap Bitmap bitmap = BitmapFactory.decodeByteArray(result, 0, result.length); // 更新我们的ImageView控件 imageView.setImageBitmap(bitmap); // 使ProgressDialog框消失 progressDialog.dismiss(); &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main, menu); return true; &#125;&#125; ###AsyncTask的重要知识点 ####Cancelling a Task 我们可以在任何时刻来取消我们的异步任务的执行，通过调用 cancel(boolean)方法，调用完这个方法后系统会随后调用 isCancelled() 方法并且返回true。如果调用了这个方法，那么在 doInBackgroud() 方法执行完之后，就不会调用 onPostExecute() 方法了，取而代之的是调用 onCancelled() 方法。为了确保Task已经被取消了，我们需要经常调用 isCancelled() 方法来判断，如果有必要的话。 ####在使用AsyncTask做异步任务的时候必须要遵循的原则： AsyncTask类必须在UI Thread当中加载，在Android Jelly_Bean版本后这些都是自动完成的. AsyncTask的对象必须在UI Thread当中实例化 execute方法必须在UI Thread当中调用 不要手动的去调用AsyncTask的onPreExecute, doInBackground, publishProgress, onProgressUpdate, onPostExecute方法，这些都是由Android系统自动调用的. AsyncTask任务只能被执行一次]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>AsyncTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础--初识java中的设计模式]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80-%E5%88%9D%E8%AF%86java%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[面向对象思想设计原则在实际的开发中，我们想要更深入的了解面向对象的思想，就必须熟悉前人总结过的面向对象的思想的设计原则。 单一职责原则单一职责原则其实也就是开发人员经常说的“高内聚、低耦合”。也就是说，每一个类应该只有一个职责，对外只能提供一种功能，而引起该类变化的原因应该只有一个。在设计模式中，所有的设计模式都遵循这一原则。 开闭原则 核心思想：一个对象对扩展开方，对修改关闭。 开闭原则的意思是，对类的改动是通过增加代码进行的，而不是修改现有代码。也就是说软件开发人员一旦写出了可以运行的代码，就不应该去改动它，而是要保证它能一直运行下去，如何能够做到这一点呢?这就需要借助于抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现则是可以改变和扩展的。 里氏替换原则 核心思想：在任何父类出现的地方都可以用它的子类来替代。 换而言之，同一继承体系中的对象都应该有共同的行为特征。依赖注入原则 核心思想：要依赖于抽象，不要依赖于具体实现。 其实就是说，在应用程序中，所有的类如果使用或依赖于其他的类，则应该依赖这些其他类的抽象类，而不是这些其他类的具体类。为了实现这一原则，就要求我们在编程的时候针对抽象类或者接口编程，而不是针对具体实现编程。 接口分离原则 核心思想：不应该强迫程序依赖它们不需要使用的方法。 其实就是说，一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。 ####迪米特原则 核心思想：一个对象应当对其他对象尽可能少的了解。 其实就是说：降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用。 设计模式概述 设计模式的概念 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 设计模式不是一种方法和技术，而是一种思想。 设计模式和具体的语言无关，学习设计模式就是要建立面向对象的思想，尽可能的面向接口编程，低耦合，高内聚，是设计的程序可复用。 学习设计模式能够促进对面向对象思想的理解，反之亦然。它们相辅相成。 设计模式的几个要素 名字 必须有一个简单，有意义的名字 问题 描述在何时使用模式 解决方案 描述设计的组成部分以及如何解决问题 效果 描述模式的效果以及优缺点 设计模式的分类设计模式目前有23种，分为3大类型。 创建型模式——对象的创建：简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式，单例模式。(6个) 结构型模式——外观模式、适配器模式、代理模式、装饰模式、桥接模式、组合模式、享元模式。(7个) 行为型模式——模版方法模式、观察者模式、状态模式、职责链模式、命令模式、访问者模式、策略模式、备忘录模式、迭代器模式、解释器模式。(10个)本文讲对其中的几种模式做一个简单介绍。单例设计模式什么是单例设计模式单例设计模式就是要确保在内存中只有一个对象，该实例必须自动创建，并且对外提供。 单例设计模式的优缺点优点：在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。缺点：没有抽象层，因此扩展很难。职责过重，在一定程序上违背了单一职责。 单例设计模式的原则单例设计模式的原则就是要保证一个类在内存中只有一个对象，要确保对象唯一，我们可以这么来做： 为了避免其它程序过多建立该类对象，需要先禁止其它程序建立对象。 为了保证其它程序可以访问该类对象，需在本类中先定义一个对象。 为了方便其它程序对自定义对象的访问，可以对外提供一些访问方式。 单例设计模式的实现步骤 因为创建对象都需要构造函数初始化，只要将本类的构造函数私有化，其它程序就无法再创建该类对象。 就在类中创建一个本类的对象。 定义一个方法，返回该对象，让其它程序可以通过方法就得到本类对象。 单例设计模式之饿汉式饿汉式就是一进内存就创建对象。代码示例如下： 12345678910111213141516171819/* 单例模式之懒汉式*/class single&#123; //构造函数初始化 private single()&#123;&#125; //在本类中创建一个本类对象 private static single s = new single(); //提供一个公共的获取本类对象的方法 public static single getInstance()&#123; return s ; &#125;&#125;public class SingleDemo&#123; public static void main(String[] args)&#123; //通过类名.方法的方式获取对象。 single ss = single.getInstance(); &#125;&#125; 单例设计模式之懒汉式懒汉式是类的对象延迟加载。代码示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 单例设计模式之懒汉式*/class Single&#123; private String name = "黄祥"; public static Single s = new Single(); private Single()&#123;&#125; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; /* public static Single getInstance()&#123; return s; &#125; */ /* 为了防止多线程同时进入getInstance方法，导致多个对象的存在。 加入同步锁。 */ public static Single getInstance()&#123; if(s == null)&#123; synchronized(Single.class)&#123; if(s == null)&#123; s = new Single(); &#125; &#125; &#125; return s; &#125;&#125;public class SingleDemo2&#123; public static void main(String[] args)&#123; Single s1 = Single.getInstance(); System.out.println(s1.getName()); Single s2 = Single.getInstance(); &#125;&#125; 装饰设计模式什么是装饰设计模式装饰模式就是使用被装饰类的一个子类的实例，在客户端将这个子类的实例交给装饰类。是继承的替代方案。 装饰模式的优缺点优点：使用装饰模式，可以提供比继承更灵活的扩展对象的功能，它可以动态的添加对象的功能，并且可以随意的组合这些功能。缺点：正因为可以随意组合，所以就可能出现一些不合理的逻辑。 当我们需要对已有的对象进行功能增强时，可以定义一个类，将已有对象传入，基于已有的功能进行增强。那么可以称这个自定义的类为装饰类。下面通过一个代码小例子引入：1234567891011121314151617181920212223242526272829class Person&#123; public void eat()&#123; System.out.println("吃饭"); &#125;&#125;public class PersonDemo&#123; public static void main(String[] args)&#123; Person p = new Person(); p.eat(); SuperPerson sp = new SuperPerson(p); sp.superEat(); &#125;&#125;//当我们需要对上面的吃饭功能进行增强时class SuperPerson&#123; private Person p ; SuperPerson(Person p)&#123; this.p = p; &#125; public void superEat()&#123; System.out.println("饭前来杯开胃酒"); p.eat(); System.out.println("吃完饭再吃点甜点"); System.out.println("饭后一根烟"); &#125;&#125; 其实呢装饰模式就是通过构造函数传递进行功能增强，但是使用继承可以达到同样的目的，但相比之下就会发现真正构建出来的体系会非常臃肿。如：假设有一个专门用于读操作的类MyReader，然后它会有一些列的子类： 12345|----MyTextReader |----MyBufferTextReader|----MyMediaReader |----MyBufferMediaReader………………………… 一直下去，整个体系就回变得非常臃肿。如进行一次装饰，那么体系结构就会变得清晰灵活得多。 模板设计模式什么是模板设计模式模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现。 模板设计模式的优缺点 优点：使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求。 缺点：如果算法骨架有修改的话，则需要修改抽象类。 在定义功能时，功能的一部分是确定的，但是有一部分是不确定的，而确定的部分在使用不确定的部分，那么这时就将不确定的部分暴露出去。由该类的子类去完成。代码演示如下所示： 123456789101112131415161718192021222324//例子：模板方法设计模式,获得代码的运行时间abstract class GetTime &#123; public final void getTime() &#123; long start = System.currentTimeMills(); runcode(); long end = System.currentTimeMills(); System.out.println("毫秒："+(end-start)); &#125; public abstract void runcode();&#125;class Test extends GetTime&#123; public void runcode() &#123; .... &#125;&#125; 工厂方法模式什么是工厂方法模式工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。 工厂方法模式的优缺点 优点：客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性。 缺点：需要额外的编写代码，增加了工作量。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java概述]]></title>
    <url>%2Fjava%E6%A6%82%E8%BF%B0.html</url>
    <content type="text"><![CDATA[Java语言概述Java是由sun公司推出的java面向对象程序设计语言和java平台的的总称。由James Gosling和同事们共同研发，于1995年正式推出。java最初称为Oak，1995年更名。其特点是：面向对象、通用性、高效性、安全性、跨平台。随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。 java语言的发展java自从1996年发布1.0版本起，经过近20年的发展，于2014年已发布了java 8版本。 java语言的三个版本java语言共有三个版本： javase（J2SE，Java2 Platform Standard Edition，标准版）：是在java基础阶段主要学习的内容，包含了构成java语言核心的类，比如：数据库连接、接口定义、输入/输出、网络编程等。 javaee（J2EE，Java 2 Platform, Enterprise Edition，企业版）：用于服务端处理的企业版。该技术体系中包含的技术如Servlet Jsp等，主要针对于Web应用程序开发。 javame（J2ME，Java 2 Platform Micro Edition，微型版）：用于手机等嵌入式设备的“微型版”。其中，Javame目前使用较少，市场上的大多数为android系统和ios系统的手机，都有自己的开发工具来完成软件的开发。 Java程序设计环境Java虚拟机(JVM) JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 JVM是java的核心和基础，在java编译器和os平台之间的虚拟处理器，它是一种基于下层的操作系统和硬件平台并利用软件方法来实现的抽象计算机，可在上面执行java的字节码程序。 JVM是java实现跨平台性的一个关键，JVM本身并不能跨平台，正是由于JVM在不同的操作系统上有着不同的版本，使得java程序可以“一次编译，反复运行”。 Java开发环境的搭建 JDK和JRE JDK(Java development kit):java开发工具包，其中包含了JRE和java开发工具。安装了JDK之后就能运行Java程序。 JRE(Java runtime environment):java运行环境。其中包含了JVM和核心类库，如果只是单独的运行java程序，安装JRE即可。 JDK的下载与安装 JDK开发工具箱的下载，可以到Oracle网站，地址是www.oracle.com/technetwork/javajavase/downloads，根据自己电脑的操作系统选择Windows、Linux、Mac OS X等相对应的版本。 环境变量的配置在完成了JDK的安装之后，我们还需要进行环境变量的配置：即将jdk/bin目录添加到执行路径中，在bin目录下存放着一些可执行程序，如javac，java，javadoc等。配置环境变量的详细过程： 首先，右击【我的电脑】—【属性】—–【高级】—【环境变量】，如图： 将你jdk/bin目录加入进path中，以分号结束，但为了以后避免jdk重新安装时又要重新配置变量，我们可以在环境变量中新建一个名为%JAVA_HOME%的变量，变量值为jdk安装目录，再将%JAVA_HOME%/BIN加入到path中，如图： 测试环境变量是否配置成功，在DOS命令行下输入“javac”，输出帮助信息即为配置正确。如图： 下面提供一下临时配置环境变量的方法：当我们需要用别人的电脑进行开发，不能对别人电脑的环境变量进行随意更改时，我们可以使用临时配置的方式。临时的配置方式需要用到DOS命令行中的set命令，例如set path=” D:\Program Files\Java\jdk1.6.0_18\bin”就可以把配置临时的path变量，但是当我们再重新开启一个命令提示符窗口，该path就失去了效果。classpath也是相同的道理。 java程序编译运行方法 使用命令行方式java程序的编译和运行可以通过dos命令行的方式： 打开一个dos命令行窗口，可通过“win+R”的快捷键组合输入“cmd”的方式打开。 进入到java文件保存的目录。 执行javac文件名.java，对.java文件进行编译，生成.clss文件。 执行java文件名，即可执行该java程序。 下面用一个小程序做一个示范： 12345public class HelloWorld&#123; public static void main(String []args)&#123; System.out.println("HelloWorld"); &#125;&#125; 编译运行结果如图所示：下面是一些dos命令行常用的命令： dir：列出当前文件夹目录md：创建文件夹rd：删除文件夹（必须保证文件夹是空的）cd：进入文件目录cd..：退回到上一级目录cd/：退回到根目录del：删除文件exit：退出dos命令行 使用集成开发工具 我们还可以通过使用java集成工具来进行java程序的开发，这里主要介绍的是如和使用Eclipse编译运行一个程序。Eclipse可以从网站http://eclipse.org上免费下载。使用eclipse的步骤如下： 启动eclipse，从菜单栏选择File—&gt;New—&gt;Java Project，打开新建的这个文件，在其中右键new—&gt;class文件。进行java文件的编写编写完java文件之后，右键Run–&gt;Run As–&gt;Java Application即可。 Java中的注释 注释的作用: 1.注解，说明解释我们的程序，提高代码的阅读性 2.调试程序。当程序出现错误时，通过注释可以方便的查找出错的地方。 注释的类型：单行注释、多行注释和文档注释三种。 单行注释：//注释文字 多行注释：/注释文字（可多行）/ ，多行注释中不能嵌套多行注释 文档注释：/*注释内容/，是Java特有的注释，通常书写在类、域、构造函数、方法、定义之前。注释内容可以被JDK中的工具javadoc.exe所解析，生成一套以网页文件形式体现的该程序分说明文档。 格式如图所示：]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础,java,java概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基本语法(上)]]></title>
    <url>%2Fjava%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[java语言基础构成java的基础由关键字、标识符、注释、常量和变量、运算符、语句、函数、数组构成。 java关键字和保留字关键字定义：被java语言赋予了特殊涵义的单词。特点：关键字中所有字母均为小写。 关键字共有50个，分为以下类型，都有其特殊含义。 用于定义数据类型的关键字 用于定义流程控制的关键字 用于定义访问权限修饰符的关键字 用于定义类、函数、变量修饰符的关键字 用于定义类与类之间关系的关键字 用于建立实例及引用实例、判断实例的关键字 用于异常处理的关键字 用于包的关键字 其它修饰符关键字 保留字const，goto java中的常量和变量常量常量：表示不能改变的值。 java中常量的分类 整数常量：所有整数 小数常量：所有小数 布尔型常量：较为特有，只有两个数值，true和false 字符常量：将一个数字或字符使用单引号&#39;&#39;标识 字符串常量：将一个或多个字符使用双引号&quot;&quot;标识 null常量：只有一个数值，null 对于整数，java有三种表现形式 二进制：0和1表示，满2进1 十进制：0~9,满10进1 八进制：0~7，满8进1 十六进制：0~9，A~F，满16进1，开头用0x表示 计算机采用二进制的原因 技术实现简单，计算机由逻辑电路组成，逻辑电路通常只有两个状态，开关的接通与断开，这两种状态正好可以使用0和1来表示。 简化运算规则，两个二进制数和、积运算组合各有三种，运算规则简单，有利于简化计算机内部结构，提高运算速度。 适合逻辑运算，逻辑代数是逻辑运算的理论依据，二进制只有两个数码，正好与逻辑代数的”真”和”假”相吻合。 易于进行转换，二进制与十进制数易于相互转换。 用二进制表示数据具有抗干扰能力强，可靠性高等优点。因为每位数据只有高低两个状态，当受到一定程度的干扰时，仍能可靠的分辨出它是高是低。 变量java中的运算符标识符定义：在java语言中，对于变量、常量、函数、语句块也有名字，我们通通称之为标识符。标识符是用来给类、对象、方法、]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基本语法</tag>
        <tag>java运算符</tag>
      </tags>
  </entry>
</search>
