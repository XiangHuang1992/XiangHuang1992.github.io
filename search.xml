<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac OS下使用pyenv管理Python版本]]></title>
    <url>%2FMac-OS%E4%B8%8B%E4%BD%BF%E7%94%A8pyenv%E7%AE%A1%E7%90%86Python%E7%89%88%E6%9C%AC.html</url>
    <content type="text"></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pyenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下关于将普通用户权限提升为root的问题]]></title>
    <url>%2FUbuntu%E4%B8%8B%E5%85%B3%E4%BA%8E%E5%B0%86%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E4%B8%BAroot%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[问题的由来 博主一个好奇就想把自己的那个用户提升为root级别的，所以进行了如下操作。1234567suvi etc/passwd然后将自己创建的那个用户（博主的用户名为lucas），对应的值lucas:x:1000:0:lucas,,,:/home/lucas:/bin/bash中的1000修改成了和root用户一样的0.好吧，这下lucas确实成了root用户了，但是问题就来了，你下次登录的适合界面上只剩下客人会话了。其它会话都没了。 解决措施1234567在用户登录界面，按下 `ctrl+alt+f7`进入命令行界面。按照如下操作进行：输入用户名：lucas（博主的）输入密码：xxxxxx然后使用vi命令打开我们修改过的文件：/etc/passwd将0修改成原来的数值。这样我们的登录界面又会出现用户登录啦！好吧。。至此，问题解决。 PS：博主的Linux系统的Ubuntu kylin 15.10 的版本。具体的原因是ubuntu从12.04开始，添加了额外的root保护，不允许直接开启root账户，强制使账户改为root账户会被屏蔽。所以以后不能再继续作死了。老老实实的用sudo吧。%&gt;_&lt;%。 记录时间：2015年12月10日19:05:05。下班吃饭。]]></content>
      <categories>
        <category>问题搜集整理</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>root权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器是如何工作的]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84.html</url>
    <content type="text"><![CDATA[why？ Web浏览器是世界上使用最广泛的软件。 浏览器提供web资源并创建可以允许web应用程序的沙箱环境。 浏览器实现这一点的方式非常复杂，并且由许多不同的标准决定。 浏览器的一些机制其实是具有着欺骗性和反直觉性。 了解浏览器的工作原理为我们提高网站/网页类应用程序的效率和代码的组织结构提供了理论依据。 复杂 这里无法讲解浏览器工作原理的所有细节。 每个浏览器都有自己的实现方式。 一般和模块化的方法 浏览器遵循相同的标准 大多数浏览器有着相同的总体结构和同样的模块 本文将讨论这些共同行为。 浏览器的两个主要模块 渲染引擎（也成为布局引擎） Javascript解释器 不同浏览器使用的渲染引擎不一样 Mozilla Firefox 使用 Gecko Safari 和 Google Chrome（version 27之前）使用Webkit。 Chrome使用Blink在version 27之后 一个web页面的组成 HTML：应用程序的内容 CSS： 内容的样式 Javascript： 应用程序的逻辑部分，有时也是一些动画(animations)等等。 其它 渲染引擎（rendering engine）的工作从HTML,CSS,JS开始，将网页呈现在用户屏幕上，大概需要经过四个阶段： 处理HTML构建DOM，处理CSS构建CSSOM 将DOM和CSSOM合并到一个渲染树中 布局渲染树（render tree）,通过几何计算]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器从请求发出到返回经历了什么]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%AF%B7%E6%B1%82%E5%8F%91%E5%87%BA%E5%88%B0%E8%BF%94%E5%9B%9E%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88.html</url>
    <content type="text"><![CDATA[一个最简单的http请求，没有代理，ipv4和以下任何步骤都没有问题的情况下： 浏览器检查缓存，如果请求的对象在缓存中并且是新的，跳到步骤9。 浏览器从OS获取服务器的ip地址。 OS进行DNS查找，并将IP地址返回给浏览器。 浏览器打开到服务器的TCP连接（如果是https则步骤更复杂点,后面再分析）。 浏览器通过TCP连接发送HTTP请求。 浏览器接受http响应，并可能关闭TCP连接或将其重新用于另一个请求。 浏览器检查响应是重定向还是条件响应（3xx的状态码）,授权请求（401），错误（4xx或5xx）等。这些与正常响应（2xx）的处理方式不同。 如果允许缓存，响应将存储在缓存中。 浏览器解码响应（比如响应是gzip的需要解压缩） 浏览器决定如何处理响应（它可能是一个HTML页面，可能是一张图片，也可能是一个声音片段）。 浏览器渲染响应，或者提示无法识别的类型弹出框警告。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hibernate学习教程（二）----ORM 概述]]></title>
    <url>%2FHibernate%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89-ORM-%E6%A6%82%E8%BF%B0.html</url>
    <content type="text"><![CDATA[什么是JDBC JDBC:Java Database Connectivity，提供一组Java API，用于java程序中访问关系数据库。通过这些API，Java程序能够执行SQL语句并与任何SQL兼容的数据库进行交互。 JDBC提供了一种灵活的架构，可以编写一个独立于数据库的应用程序，该应用程序可以在不同的平台上并与不同的DBMS进行修改。 JDBC的优点和缺点 优点 缺点 简洁的SQL处理 用于大型应用程序时比较复杂 处理大量数据有着良好的性能 资源占用开销比较大 非常适用于小型应用程序 没有进行封装抽象 语法简单，学习成本较低 很难用于MVC模式开发 只能用于DBMS查询 为什么要进行ORM关系映射(Object Relational Mapping)当我们使用面向对象的系统时，对象模型与关系数据库之间存在不匹配。RDBMS以表格形式表示数据，而面向对象的语言（如Java和C#）将其表现为对象的互联图。如下所示： 12345678910111213141516171819202122232425public class Employee &#123; private int id; private String first_name; private String last_name; private int salary; public Employee() &#123;&#125; public Employee(String fname, String lname, int salary) &#123; this.first_name = fname; this.last_name = lname; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public String getFirstName() &#123; return first_name; &#125; public String getLastName() &#123; return last_name; &#125; public int getSalary() &#123; return salary; &#125;&#125; 上面的对象需要被存储和检索到下面的RDBMS表： 1234567create table EMPLOYEE ( id INT NOT NULL auto_increment, first_name VARCHAR(20) default NULL, last_name VARCHAR(20) default NULL, salary INT default NULL, PRIMARY KEY (id)); 那么就会存在以下两个问题： 如果我们需要在开发了几个页面之后或在应用程序中修改数据库的设计时，应该怎么处理？ 在关系数据库加载和存储对象会暴露以下不匹配问题： 不匹配问题 描述 Granularity（粒度） 有时，您将有一个对象模型，它具有比数据库中对应表数量更多的类。 Inheritance（继承） RDBMS不定义类似于继承的任何东西，它是面向对象编程语言中的自然范例。 Identity（对象同一性） RDBMS正好定义了“同一性”的一个概念：主键。然而，Java定义了对象标识（a == b）和对象相等（a.equals（b）） Associations 面向对象语言使用对象引用表示Associations，RDBMS使用外键列表示 Navigation 在Java和RDBMS中访问对象的方式是完全不同的 对象关系映射（ORM）是处理所有上述不匹配问题的解决方案。 粒度问题 粒度：是指你正在使用的类型的大小。 继承（子类型问题） 在Java中，使用超类(superclass)和子类(subclass)来实现继承模型。 在Java中，继承是类型继承(type Inheritance)，而数据库表并不是一种类型。 数据库产品一般不实现类型或者表继承。而且即使实现了，我们也会遇到数据完整性的问题（对可更新视图的有限完整性规则）。 一旦把继承进入到模型当中，就有了多态(polymorphism)的可能。SQL数据库缺乏一种明显的表示多态关联的方式，一个外键约束精确的引用一张目标表，定义一个引用多表的外键并不容易。必须编写一个程序化的约束来加强这种完整性规则。 子类型的这种不匹配的结果是：模型中的继承结构必须在一个不提供继承策略的SQL数据库中被持久化。 对象同一性如果当我们需要检查两个对象是否为同一个对象的时候。解决方法有三种： 在java中： 对象同一性（粗略等同于内存位置，用a==b检查） 等同性，通过equals()方法（也成为值等同）的实现来确定。 数据库的同一性用主键值来表达。如果使用java中的方法来判断，那么主键值必然会不相等。 什么是ORM ORM（对象关系映射），是一种用于关系数据库和面向对象编程语言（如Java、C#）之间转换数据的编程技术。相对于JDBC，ORM具有以下优点： 序号 优点 1 允许业务逻辑代码访问对象而不是数据库表 2 从面向对象的角度考虑隐藏SQL查询的详细信息 3 底层基于JDBC 4 无需处理数据库实现 5 基于业务概念而不是数据库结构的实体 6 事务管理和秘钥自动生成 7 应用快速开发 ORM解决方案由以下四个模块组成： 序号 解决方案 1 用于对持久化类的对象进行基本CRUD操作的API 2 用于指定引用类的类和属性的查询的语言或API 3 用于指定映射元数据的可配置工具 4 用于实现ORM的一项技术，与事务对象交互，执行脏检查、延迟关联抓取以及其它优化功能 Java中的ORM框架Java中有几个持久化框架和ORM选项。持久化框架是一种将对象存储和检索到关系数据库中的ORM服务。 Enterprise JavaBeans Entity Beans Java Data Objects Castor TopLink Spring DAO Hibernate ……. etc. ORM和Hibernate的一些好处生产力与持久化相关的代码可能会是java中最冗长的一部分代码，Hibernate除去了许多琐碎的工作，让我们可以把更多的精力集中于业务问题的处理上。无论我们喜欢哪一种应用程序开发策略——自上而下，从一个领域模型开始；或者自底而上，从一个现有的数据库Schema开始——Hibernate与适当的工具一起使用，将明显减少开发时间。 可维护性更少的代码行使得系统更易于理解，因为它强调业务逻辑甚于那些费力的基础性工作。更重要的是，系统包含的代码越少则越利于重构。自动的对象/关系持久化充分减少了代码行。 Hibernate更易于维护还有其它原因，在手工编码的持久化系统中，关系表示法和对象模型实现领域之间存在一种必然的压力。改变一个，通常都要改变另一个，并且一个表示法设计通常需要妥协以便适应另一个的存在。ORM提供了两个模型之间的一个缓冲，允许面向对象在Java方面进行更优雅的利用，并且每个模型的微小变化都不会传递到另一个模型。 性能手工编码的持久化和自动的持久化相比总是可以一样快，并且经常更快。这是事实。但是在实际开发中，会受到时间和预算的约束。 在有限时间的项目中，手工编码的持久化通常允许你进行一些优化；Hibernate始终允许使用更多的优化。 自动的持久化能够大大提高开发人员的工作效率，使得开发人员能够花更多的时间对其它少数瓶颈进行手工优化。 实现ORM框架的人，可能在性能优化方面比我们做的更好。 供应商独立性ORM从底层的SQL数据库和SQL方言中把应用程序抽象出来。如果这个工具支持不同的数据库，这会给我们的应用程序带来一定程度的可移植性。可以帮我们减少一些被供应商锁定的风险。 数据库的独立性使得我们可以在开发时选择一些轻量级的数据库，在部署时，将实际的产品部署在不同的数据库上。]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>ORM框架</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate教程（一）---Hibernate简介]]></title>
    <url>%2FHibernate%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[Hibernate简介 Hibernate是一个Java对象映射关系的解决方案的ORM（Object-Relational Mapping）框架，是一个开源持久框架，由Gavin King于2001年创建。为Java应用提供强大的、高性能对象持久化和查询服务。 Hibernate将Java类映射到数据库表，将Java数据类型映射到SQL数据类型，减轻了开发人员95%的数据持久性相关的编程任务。 Hibernate位于传统的Java对象和数据库服务器之间，基于适当的O/R机制和模式来处理持久化这些对象的所有工作。 Hibernate的优势 Hibernate通过XML配置文件将Java类映射到数据库表，而不需要编写任何代码。 提供简单的API,用于直接存储和检索数据库中的Java对象。 如果数据库或任何表中有更改，只需要修改XML文件。 提取我们不熟悉的SQL类型，并提供我们熟悉的Java对象。 Hibernate不需要应用府服务器来操作。 操作复杂关联的数据库对象。 使用智能抓取策略简化数据库操作。 提供简单的数据查询。 Hibernate支持的数据库Hibernate几乎支持所有的关系型数据库管理系统(RDBMS),支持的数据库如下所示： HSQL Database Engine DB2/NT MySQL PostgreSQL FrontBase Oracle Microsoft SQL Server Database Sybase SQL Server nformix Dynamic Server Hibernate架构Hibernate架构是分层的，所以我们不需要知道底层的API，Hibernate利用数据库和配置数据向我们的应用程序提供持久性服务（和持久性对象）。 下图是Hibernate应用结构体系简要视图： 下图是Hibernate应用结构体系详细视图，包含了几个重要的核心类： Hibernate使用各种现有的Java API，如JDBC,JTA,JNDI。 JDBC提供了关系数据库通用的功能抽象层，所有具有JDBC驱动程序的数据库都被Hibernate支持。JTA和JNDI允许Hibernate与J2EE服务器集成。 Hibernate应用结构体系主要类对象Configuration ObjectConfiguration Object是我们在Hibernate应用程序中创建的第一个Hibernate对象，通常在应用程序初始化时且只创建一次。它是Hibernate所需要的配置和属性文件。Configuration对象提供两个关键组件： Database Connection:通过Hibernate支持的一个或多个配置文件来处理。hibernate.properties,hibernate.cfg.xml。 Class Mapping Setup:这个组件用于Java类和数据库表之间创建连接。 SessionFactory ObjectConfiguration Object用于创建一个SessionFactory Obejct，该对象使用提供的配置文件为应用程序配置Hibernate，并允许实例化一个Session对象。SessionFactory是线程安全对象,供应用程序的所有线程使用。 SessionFactory是重量级对象。因此通常在应用程序启动期间创建并保留供以后使用。 每个数据库都需要使用一个单独的配置文件创建一个SessionFactory对象。如果使用多个数据库，则必须创建多个SessionFactory对象。 Session(会话) ObjectSession（会话）用于获取与数据库的物理连接，Session对象是轻量级的，并且是每当需要与数据库进行交互时才会被实例化。持久化对象通过Session对象进行保存和检索。 Session对象不应该长时间保持打开，因为他们通常不是线程安全的，所以应该根据业务需求创建和销毁它们。 Transaction（事务） Object事务Transaction代表与数据库的工作单元，大多数关系型数据库都支持事务功能。Hibernate中的事务由底层事务管理器和事务（来自JDBC和JTA）处理。 这是一个可选对象，Hibernate应用程序可以选择不使用此接口，而选择在自己的应用程序代码中管理事务。 Query Object查询Query对象使用SQL或者Hibernate查询语言(Hibernate Query Language,HQL)字符串从数据库检索数据并创建对象。Query实例用于绑定查询参数，限制查询返回的结果数量，最后执行查询。 Criteria Object条件对象用于创建和执行面向对象的标准查询以检索对象。 Hibernate 环境配置该章主要介绍如何安装Hibernate以及其它相关包来为Hibernate应用程序准备一个开发环境。本文将使用Mysql数据库来演示Hibernate实例。 Hibernate下载 在windows上下载.zip文件，在Unix上下载.tz文件。 从http://www.hibernate.org/downloads下载最新版的Hibernate。 下载完成之后进行解压。 安装Hibernate下载完Hibernate之后，只需要执行以下两个简单的步骤即可。请确保正确的配置了CLASSPATH环境变量，否则在编译应用程序时会出现问题。 Hibernate的依赖包 S.N. Packages/Libraries 1 dom4j - XML parsing www.dom4j.org/ 2 Xalan - XSLT Processor http://xml.apache.org/xalan-j/ 3 Xerces - The Xerces Java Parser http://xml.apache.org/xerces-j/ 4 cglib - Appropriate changes to Java classes at runtime http://cglib.sourceforge.net/ 5 log4j - Logging Faremwork http://logging.apache.org/log4j 6 Commons - Logging, Email etc. http://jakarta.apache.org/commons 7 SLF4J - Logging Facade for Java http://www.slf4j.org Hibernate配置Hibernate需要提前知道在哪里可以找到定义的Java类和数据库表相关联的映射信息。Hibernate还需要一组与数据库和其它相关参数相关的配置设置。所有这些信息通常作为标准java属性文件hibernate.properties或者名为hibernate.cfg.xml的XML文件提供。 Hibernate属性以下是在独立情况下为一个数据库配置所需要的重要属性列表： S.N. Properties and Description 1 hibernate.dialect:此属性使Hibernate为选定的数据库生成适当的SQL 2 hibernate.connection.driver_class:JDBC驱动程序类 3 hibernate.connection.url:数据库实例的JDBC URL 4 hibernate.connection.username:数据库用户名 5 hibernate.connection.password:数据库密码 6 hibernate.connection.pool_size:限制在Hibernate数据库连接池中的等待连接数 7 hibernate.connection.autocommit:允许JDBC连接自动提交 如果随着应用服务器和JNDI使用同一个服务器，则还需要配置以下属性： S.N. Properties and Description 1 hibernate.connection.datasource:在应用服务器中定义的JNDI名称 2 hibernate.jndi.class:JNDI的InitialContext类 3 hibernate.jndi.&lt;JNDIpropertyname&gt;: 4 hibernate.jndi.url:提供JNDI的url 5 hibernate.connection.username:数据库用户名 6 hibernate.connection.password:数据库密码 Hibernate和Mysql数据库MySQL是目前最流行的开源数据库系统之一，下面我们创建一个hibernate.cfg.xml配置文件，并将其放置于应用程序类路径的根目录下，必须确保已经安装MySQL 并保证已经保证创建了可用的测试数据库。XML配置文件必须符合Hibernate 3 Configuration DTD，该文件可从http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd获得。1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-configuration SYSTEM "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name="hibernate.dialect"&gt; org.hibernate.dialect.MySQLDialect &lt;/property&gt; &lt;property name="hibernate.connection.driver_class"&gt; com.mysql.jdbc.Driver &lt;/property&gt; &lt;!-- Assume test is the database name --&gt; &lt;property name="hibernate.connection.url"&gt; jdbc:mysql://localhost/test &lt;/property&gt; &lt;property name="hibernate.connection.username"&gt; root &lt;/property&gt; &lt;property name="hibernate.connection.password"&gt; root123 &lt;/property&gt; &lt;!-- List of XML mapping files --&gt; &lt;mapping resource="Employee.hbm.xml"/&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 下表是各类数据库的属性类型(Dialect Property)列表： Database Dialect Property DB2 org.hibernate.dialect.DB2Dialect HSQLDB org.hibernate.dialect.HSQLDialect HypersonicSQL org.hibernate.dialect.HSQLDialect Informix org.hibernate.dialect.InformixDialect Ingres org.hibernate.dialect.IngresDialect Interbase org.hibernate.dialect.InterbaseDialect Microsoft SQL Server 2000 org.hibernate.dialect.SQLServerDialect Microsoft SQL Server 2005 org.hibernate.dialect.SQLServer2005Dialect Microsoft SQL Server 2008 org.hibernate.dialect.SQLServer2008Dialect MySQL org.hibernate.dialect.MySQLDialect Oracle (any version) org.hibernate.dialect.OracleDialect Oracle 11g org.hibernate.dialect.Oracle10gDialect Oracle 10g org.hibernate.dialect.Oracle10gDialect Oracle 9i org.hibernate.dialect.Oracle9iDialect PostgreSQL org.hibernate.dialect.PostgreSQLDialect Progress org.hibernate.dialect.ProgressDialect SAP DB org.hibernate.dialect.SAPDBDialect Sybase org.hibernate.dialect.SybaseDialect Sybase Anywhere org.hibernate.dialect.SybaseAnywhereDialect Hibernate实例创建POJO类 首先，我们创建Java POJO类，这取决于将被持久化到数据库的应用程序，生成getXXX()和setXXX()方法，使其成为JavaBeans兼容类。 POJO（java普通对象）是一种java对象，它不扩展或实现一些EJB框架分别需要的一些专门的类或接口。所有正常的Java对象都是POJO。 当你设计一个要被Hibernate持久化的类时，提供符合JavaBeans的代码以及一个在Employee类中像id属性一样用作索引的属性很重要。 12345678910111213141516171819202122232425262728293031323334353637public class Employee &#123; private int id; private String firstName; private String lastName; private int salary; public Employee() &#123;&#125; public Employee(String fname, String lname, int salary) &#123; this.firstName = fname; this.lastName = lname; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public void setId( int id ) &#123; this.id = id; &#125; public String getFirstName() &#123; return firstName; &#125; public void setFirstName( String first_name ) &#123; this.firstName = first_name; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName( String last_name ) &#123; this.lastName = last_name; &#125; public int getSalary() &#123; return salary; &#125; public void setSalary( int salary ) &#123; this.salary = salary; &#125;&#125; 创建数据库表第二步，我们需要在数据库中创建一张表，将表对应我们需要持久化的每一个对象，根据上面的java类我们创建下面这样一个表“ 1234567create table EMPLOYEE ( id INT NOT NULL auto_increment, first_name VARCHAR(20) default NULL, last_name VARCHAR(20) default NULL, salary INT default NULL, PRIMARY KEY (id)); 创建配置映射文件接下来我们需要创建一个配置文件，说明Hibernate如何将定义的类映射至数据库表。 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; &lt;hibernate-mapping&gt; &lt;class name="Employee" table="EMPLOYEE"&gt; &lt;meta attribute="class-description"&gt; This class contains the employee detail. &lt;/meta&gt; &lt;id name="id" type="int" column="id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="firstName" column="first_name" type="string"/&gt; &lt;property name="lastName" column="last_name" type="string"/&gt; &lt;property name="salary" column="salary" type="int"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 我们应该把映射文件保存为&lt;classname&gt;.hbm.xml格式的文件。上面文件保存为Employee.hbm.xml。 映射文件是一个XML格式的文档。&lt;hibernate-mapping&gt;作为包含所有&lt;class&gt;元素的根元素。 &lt;class&gt;元素用于定义从java类到数据库表的特定映射。java类名称使用使用类元素的name属性指定，并且使用table属性指定数据库表名称。 &lt;meta&gt;元素是可选元素，用于创建类描述。 &lt;id&gt;是将类中的唯一ID元素映射到数据库表的主键。id元素中的name属性引用类中的属性，cloumn属性引用数据库表中的列。type属性保存hibernate映射类型，此映射类型将从Java转换成SQL数据类型。 id元素中的&lt;generator&gt;属性用于自动生成主键值，设置class的属性值为native，让hibernate选择identity，sequence,hilo算法来创建主键，这取决于底层数据库的能力。 &lt;property&gt;元素用于将Java类属性映射到数据库表中的列。元素的name属性引用类中的属性，cloumn属性引用数据库表中的列。type属性保存hibernate映射类型，此映射类型将从Java类型转换成SQL数据类型。 创建应用类(java class)完成了以上步骤后，我们来创建一个应用文件来测试一下我们的配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import java.util.List; import java.util.Date;import java.util.Iterator; import org.hibernate.HibernateException; import org.hibernate.Session; import org.hibernate.Transaction;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class ManageEmployee &#123; private static SessionFactory factory; public static void main(String[] args) &#123; try&#123; factory = new Configuration().configure().buildSessionFactory(); &#125;catch (Throwable ex) &#123; System.err.println("Failed to create sessionFactory object." + ex); throw new ExceptionInInitializerError(ex); &#125; ManageEmployee ME = new ManageEmployee(); /* 添加一些employee对象到数据库表中*/ Integer empID1 = ME.addEmployee("Zara", "Ali", 1000); Integer empID2 = ME.addEmployee("Daisy", "Das", 5000); Integer empID3 = ME.addEmployee("John", "Paul", 10000); /* 列出所有employee对象 */ ME.listEmployees(); /* 修改 */ ME.updateEmployee(empID1, 5000); /* 从数据库中删除 */ ME.deleteEmployee(empID2); /* 列出所有对象s */ ME.listEmployees(); &#125; /* 向数据库中添加employee对象的方法 */ public Integer addEmployee(String fname, String lname, int salary)&#123; Session session = factory.openSession(); Transaction tx = null; Integer employeeID = null; try&#123; tx = session.beginTransaction(); Employee employee = new Employee(fname, lname, salary); employeeID = (Integer) session.save(employee); tx.commit(); &#125;catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125;finally &#123; session.close(); &#125; return employeeID; &#125; /* 列出所有employee对象的方法 */ public void listEmployees( )&#123; Session session = factory.openSession(); Transaction tx = null; try&#123; tx = session.beginTransaction(); List employees = session.createQuery("FROM Employee").list(); for (Iterator iterator = employees.iterator(); iterator.hasNext();)&#123; Employee employee = (Employee) iterator.next(); System.out.print("First Name: " + employee.getFirstName()); System.out.print(" Last Name: " + employee.getLastName()); System.out.println(" Salary: " + employee.getSalary()); &#125; tx.commit(); &#125;catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125;finally &#123; session.close(); &#125; &#125; /* 修改employee对象的方法 */ public void updateEmployee(Integer EmployeeID, int salary )&#123; Session session = factory.openSession(); Transaction tx = null; try&#123; tx = session.beginTransaction(); Employee employee = (Employee)session.get(Employee.class, EmployeeID); employee.setSalary( salary ); session.update(employee); tx.commit(); &#125;catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125;finally &#123; session.close(); &#125; &#125; /* 删除employee对象的方法 */ public void deleteEmployee(Integer EmployeeID)&#123; Session session = factory.openSession(); Transaction tx = null; try&#123; tx = session.beginTransaction(); Employee employee = (Employee)session.get(Employee.class, EmployeeID); session.delete(employee); tx.commit(); &#125;catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125;finally &#123; session.close(); &#125; &#125;&#125; 编译和执行编译和执行的步骤（请确保正确配置了环境变量）： 创建hibernate.cfg.xml配置文件。 创建Employee.hbm.xml映射文件。 创建Employee.java文件，并编译它。 创建如上所示的ManageEmployee.java文件，并执行编译。 执行ManageEmployee.class文件，运行程序。]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>ORM框架</tag>
        <tag>javaweb</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java解惑》读书笔记]]></title>
    <url>%2F%E3%80%8AJava%E8%A7%A3%E6%83%91%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[表达式之谜奇数性奇数：被2整除余1的数。表达式i%2是计算i除以2时所产生的余数。这个表达式其实是错误的。在所有的int数值中，有一半的值为负数，当值为负数时，无论该值为奇数还是偶数，结果都会返回false。123456789101112package com.hx.test;public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(isOdd(-5)); &#125; public static boolean isOdd(int i) &#123;// return i % 2 == 1; // 这个表达式是错误的。// return i % 2 != 0; // 正确 return (i &amp; 1) != 0; // 正确 &#125;&#125; 找零时刻1234567891011package com.hx.test;import java.math.BigDecimal;public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(2.00 - 1.10); // 输出结果0.8999999999999999 System.out.println((200-110)+"cents"); //输出结果 90 cents System.out.println(new BigDecimal("2.00").subtract(new BigDecimal("1.10"))); //输出结果0.9 &#125;&#125; 在需要使用精确数值的地方，要避免使用float和double，对于货币计算，要使用int,long,BigDecimal。 长整除123456789101112131415161718package com.hx.test;import java.math.BigDecimal;public class HelloWorld &#123; public static void main(String[] args) &#123; final long MICROS_PRE_DAY = 24*60*60*1000*1000; final long MILLS_PRE_DAY = 24*60*60*1000; //final long MICROS_PRE_DAY = 24L*60*60*1000*1000; //final long MILLS_PRE_DAY = 24L*60*60*1000; System.out.println(MICROS_PRE_DAY/MILLS_PRE_DAY); // 为什么结果会打印5？？？ // &#125;&#125; 当操作很大的数字时，千万要提防溢出。即便用来保存结果的变量足够大，也并不意味着要产生结果的计算具有正确的类型。当拿不准的时候，就使用long运算来执行整个计算。 十六进制的趣事123456789package com.hx.test;public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(Long.toHexString(0x100000000L + 0xcafebabe)); // cafebabe System.out.println(Long.toHexString(0x100000000L + 0xcafebabeL)); // 1cafebabe &#125;&#125; 混合类型的计算可能产生混淆，尤其需要注意的是十六进制和八进制字面常量无需显式的减号符号就可以表示负的数值，为了避免这种窘境，通常最好避免混合类型的计算。]]></content>
      <categories>
        <category>Java解惑</category>
      </categories>
      <tags>
        <tag>java解惑</tag>
        <tag>表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下的cmd神器:Cmder介绍及其设置]]></title>
    <url>%2Fwindows%E4%B8%8B%E7%9A%84cmd%E7%A5%9E%E5%99%A8-Cmder.html</url>
    <content type="text"><![CDATA[Cmder的安装cmder官网： http://cmder.net/Github：https://github.com/cmderdev/cmder 官网安装在官网上,我们可以看到Download模块，分为min版和full版，两者的区别在于：full版集成了msysgit工具，是Git for Windows的标准配置，除了git本身这个命令之外，里面还有大量的linux命令，比如 grep, curl(没有 wget)； 像vim, grep, tar, unzip, ssh, ls, bash, perl 对于爱折腾的Coder更是痛点需求。 将下载的压缩包解压到你想放置的目录。 点击Cmder.exe即可运行。 Cmder配置及相关设置乱码和文字重叠当我们使用ls命令查看文件目录时，发现，中文被显示成了一些奇怪的乱码，将以下几行代码配置在cmder/config/user-aliases下即可解决问题:1234l=ls --show-control-charsla=ls -aF --show-control-charsll=ls -alF --show-control-charsls=ls --show-control-chars -F 如果进行了以上配置还存在乱码问题时，还能尝试进行如下配置： 启动Cmder前文已经说过，Cmder无需安装，解压即可运行。Cmder点击Cmder.exe即可运行，显然，这样打开是非常不方便的，所以，我们可以进行如下配置： 将cmder添加入环境变量将cmder.exe所在的目录添加至系统环境变量。添加完之后，使用win+r输入cmder即可运行Cmder。右键点击我的电脑---&gt;属性,然后如下图所示进行配置即可： 添加cmser至右键菜单能不能将cmder添加到右键，让我们可以在任意文件目录下打开cmder呢？如果能这样使用那么简直是不能太赞了！！答案是完全可以的，因为在上一步骤我们已经将cmder加入了环境变量，所以我们只需要进行如下配置即可： 12// 以系统管理员权限打开cmd窗口，输入以下代码，回车即可。Cmder.exe /REGISTER ALL 默认开启设置作为强大的存在，必然支持私人定制。输入win + alt + p 或者 在底部右击点击 settings, 进入设置页面；可以根据自己的所需进行各种配置(字体，皮肤等等等等)。 目前游走在前端，Gulp已离不开，Cmder+PowerShell这个组合无疑是运行gulp的利器。如下图所示，可以设置PowerShell作为默认开启的选项；也可以更改默认开启是所在目录。 Cmder常用功能介绍Cmder功能非常强大，也有许多功能： Cmder常用快捷键 Tab：自动路径补全 ctrl+T:建立新页签 ctrl+W：关闭页签 ctrl+tab：切换页签 alt_f4:关闭所有页签 alt+shift+1:开启cmd.exe alt+shift+2:开启powershell.exe alt+shift+3:开启powershell.exe（系统管理员权限） ctrl+1:快速切换到第一个页签 ctrl+n:快速切换到第n个页签 alt+enter:切换到全屏状态 ctrl+r:历史命令搜索 可在视窗内搜寻画面上曾经出现过的任意字 新增页签按钮，可透过滑鼠新增页签 切换页签按钮，可透过滑鼠切换页签 锁定视窗，让视窗无法再输入 切换视窗是否提供卷轴功能，启动时可查询之前显示过的内容 按下滑鼠左键可开启系统菜单，滑鼠右键可开启工具选项视窗，win+alt+p开启工具选项视窗。 cmder元件组成Cmder集成了多套软体，其中最重要的是msysgit、ConEmu、Clink。 msysgit除了提供git for windows相关工具之外，还提供了多套Unix/linux环境下常用的指令工具，例如：less、ls、tar、grep等。 ConEmu体验不如cmder Clink将GNU Readline 函式库整合进原生的Windows 命令提示字元视窗，提供命令列模式下强大的编辑与输入能力，这也是用了cmder 之后会这么像在Linux 环境下使用的感觉。 Chocolatey软件包管理系统在 Linux 下，大家喜欢用apt-get(mac下用brew)来安装应用程序，如今在 windows 下，大家可以使用Chocolatey来快速下载搭建一个开发环境。Chocolatey的哲学就是完全用命令行来安装应用程序， 它更像一个包管理工具（背后使用Nuget）另外需要说明的是，Chocolatey只是把官方下载路径封装到了Chocolatey中，所以下载源都是其官方路径，所以下载的一定是合法的，但是如果原软件是需要 Licence 注册的话，那么Chocolatey下载安装好的软件还是需要你去购买注册。不过Chocolatey一般还是会选用免费 Licence 可用的软件。 安装chocolatey , 运行如下命令即可：1@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin 安装软件命令choco install softwareName, 短写是cinst softwareName可安装的应用程序，可以参见其 Package列表以下是window下开发常用的开发环境应用:123456789101112choco install autohotkey.portable #安装 AutoHotkey (Portable)choco install nodejs.install #安装 nodechoco install git.install #安装 gitchoco install ruby #安装 rubychoco install python #安装 pythonchoco install jdk8 #安装 JDK8choco install googlechrome #安装 Chromechoco install google-chrome-x64 #Google Chrome (64-bit only)choco install firefox #安装 firefoxchoco install notepadplusplus.install #安装 notepad++choco install Atom #安装 Atomchoco install SublimeText3 #安装 SublimeText3 其他功能 Cmder还增加了alias功能;他让你用短短的指令执行一些常见但指令超长又难以记忆的语法;比如 ls cls等等；在其控制台输入alias可以查看。 主控台文字自动放大缩小功能，你只要按下Ctrl+滑鼠滚轮就可以办到;果你用支援两点触控的笔电，也可以在触控板上用两指放大的手势调整文字大小。还有：up，向上翻历史命令; Cmder有极为简单的复制粘贴操作。Ctr+V直接粘贴;用鼠标选中你想拷贝的内容，自动就复制到剪切板；天神，这悉数的美感;点赞! 自定义aliases:打开Cmder目录下的config文件夹，里面的aliases文件就是我们可以配置的别名文件，只需将里面ls命令的别名按下列方式修改就可以在ls命令下显示中文。]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>cmder</tag>
        <tag>cmd.linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下jdk环境变量的配置]]></title>
    <url>%2Fubuntu%E4%B8%8Bjdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[Linux下jdk环境变量的配置PS:博主的系统版本是 ubuntu kylin 15.10。 下载、及安装 下载:http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 下载完成之后就是解压了： 进入到文件目录下执行该指令sudo tar zxvf ./jdk-8u65-linux-x64.tar.gz 安装完成之后就是配置环境变量啦2.1 打开/etc/profile文件：sudo gedit /etc/profile2.2 添加如下环境变量123456789#set java environment export JAVA_HOME=/usr/local/java/jdk版本 export JRE_HOME=/usr/local/java/jdk版本/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH 2.3 使得修改生效：一种是使用重启的方式使得修改生效，另一种则是使用source /etc/profile也可以使修改生效。 输入java -version测试是否配置成功。3.1 出现以下代码表示配置成功： 1234lucas@lucas-ThinkPad-PC:~/java$ java -versionjava version &quot;1.8.0_65&quot;Java(TM) SE Runtime Environment (build 1.8.0_65-b17)Java HotSpot(TM) 64-Bit Server VM (build 25.65-b01, mixed mode) 3.2 如出现如下代码：1234567程序 &apos;java&apos; 已包含在下列软件包中： * default-jre * gcj-4.6-jre-headless * gcj-4.7-jre-headless * openjdk-7-jre-headless * openjdk-6-jre-headless请尝试：sudo apt-get install &lt;选定的软件包&gt; 则可以通过以下方式来解决： 在终端输入如下命令：1234// 这里是输入你的jdk安装目录以及版本号，具体的根据自己的设置去配。sudo update-alternatives --install /usr/bin/java java /home/lester/develop/jdk1.6.0_37/bin/java 300sudo update-alternatives --install /usr/bin/javac javac /home/lester/develop/jdk1.6.0_37/bin/javac 300 在配置完以上信息之后，再去java -version 进行测试。就能看到成功配置的信息啦！～ 好了，初次接触linux下的开发，确实会遇到许多的问题，博主会将这些常见的问题一一记录下来，以便自己查看，也为了让其他和我一样刚入门的新手一些参考。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>java环境变量</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下Apache2服务器的搭建]]></title>
    <url>%2FUbuntu%E4%B8%8BApache2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[Apache服务器的下载与安装博主选择的是使用apt-get开发包打包的方式安装的。下面是安装步骤： 安装apache，在命令行终端中输入以下命令： 1$ sudo apt-get install apache2 如果网络连接正常的话，应该是会顺利安装好的，在安装完成之后，需要重启apache服务，在命令行终端中输入如下命令： 1234$ sudo /etc/init.d/apache2 restart``` &gt; 如果重启之后出现如下提示，则表示服务器已经启动成功了。 lucas@lucas-ThinkPad-PC:~$ sudo /etc/init.d/apache2 restart[ ok ] Restarting apache2 (via systemctl): apache2.service.``` 可能出现的问题1： NameVirtualHost * :80 has no VirtualHost. 出现上述问题的原因：定义了多个NameVirtualHost，我们只需要将/etc/apahce2/ports.conf 中的NameVirtualHost * :80注释掉即可。 可能出现的问题2： Could not reliably determine the server’s fully qualified domain name, using 127.0.1.1 for ServerName 原因：根据提示，无法可靠的确定服务器的有效域名，使用127.0.1.1作为服务器域名。因此在下面的测试中，应该使用127.0.1.1，而不是127.0.0.1。 解决方法：终端输入vim /etc/apache2/httpd.conf，在文件中添加ServerName localhost:80 ，再次restart apache2,就可以使用127.0.0.1来访问web服务器了。 Apache服务器的测试既然已经安装好了，name我们当然应该测试一下了。 在浏览器中输入http://localhost或者http://127.0.0.1，如果看到了It works，那么就说明服务器成功安装了。Apache的默认安装，会在var/www/的目录，这个就是我们的web目录了，所有需要能够浏览器访问的web文件都要放在这个目录里。 下面是楼主的测试结果： PS:好了。至此Ubuntu下Apache服务器的安装就已经完成，下面的文章中，我将继续Apache服务器配置文件的详解。]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>Apache2</tag>
        <tag>服务器</tag>
        <tag>ubuntu</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bower:Additional error details:Name must be lowercase, can contain digits, dots, dashes, "@" or spaces]]></title>
    <url>%2Fbower%20error.html</url>
    <content type="text"><![CDATA[在运行bower install安装第三方JS的时候，遇到以下错误提示： 12345E:\nginx-1.10.2\html\parkhero2.0\master&gt;bower installbower EINVALID Failed to read E:\nginx-1.10.2\html\parkhero2.0\master\bower.jsonAdditional error details:Name must be lowercase, can contain digits, dots, dashes, "@" or spaces 看到这个错误有点懵比，因为一直是可以正常运行的，突然遇到这个错误，然后去检查了一下bower.json文件，发现错误的原因是：12"name": "Park", // 错误就在这里，上面提示了name必须小写，可以包含数字、点、破折号、@和空格"version": "2.0.0", 好吧，至此问题就解决了。12&quot;name&quot;: &quot;park&quot;, // 改成小写&quot;version&quot;: &quot;2.0.0&quot;, 修改完之后运行bower install,正常运行了。这是个小错误，记录一下。]]></content>
      <categories>
        <category>错误收集</category>
      </categories>
      <tags>
        <tag>Bower</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Crypto-JS进行加密，以及使用angular的方式进行封装调用]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Crypto-JS%E8%BF%9B%E8%A1%8CAES%E5%8A%A0%E5%AF%86.html</url>
    <content type="text"><![CDATA[## 使用Crypto-JS进行AES加密 在最近的项目中，调用登录接口，需要对账号密码数据进行AES加密后再进行传输，使用的是AES/ECB/PKCS5Padding,我前端部分使用选择了CryptoJS,现在把使用的过程记录如下。 需要注意的点 Crypto-JS的encrypt函数不会返回字符串，需要调用对象的toString方法，或者通过Crypto-js转码才能得到真实的结果。 使用步骤 引入Crypto-JS中的 aes.js及相关模块 1234&quot;bower_components/cryptojs/aes.js&quot;,&quot;bower_components/cryptojs/enc-utf8.js&quot;,&quot;bower_components/cryptojs/pad-pkcs7.js&quot;,&quot;bower_components/cryptojs/mode-ecb.js&quot; 调用CryptoJS.AES 12345678910111213141516// 官方示例, 每次输出的密文都不一样,这样使用的话是错误的CryptoJS.AES.encrypt("Message", "Secret Passphrase");/* 正确的使用姿势！！ */// 使用用户名进行MD5，32位，作为keyvar key_str = md5.createHash(username);// 将key转换成128 bitvar key = CryptoJS.enc.Utf8.parse(key_str);// 对password进行AES加密var AESPass = CryptoJS.AES.encrypt(password, key, &#123; mode: CryptoJS.mode.ECB, //补齐方式 CBC,ECB,etc. padding: CryptoJS.pad.Pkcs7 // 偏移规则设定 pack5，pkcs7，nopadding,etc.&#125;);// CryptoJS 的 encrypt函数不会直接返回字符串，需要toString或者Crypto-JS进行转码才能得到真实的结果。var pass = AESPass.toString();var authData = Base64.encode(username + ':' + pass).replace(/[\r\n]/g, ''); // 去除回车换行符 使用AngularJS的方式调用CryptoJS.AES 使用Angular将AES封装成一个provider 提供两种方式设置key 12345// 1. 一种为在angular.module('xxxx').config中进行设置，此种方式适用于key为一个固定值的情况 CryptoKeyProvider.setCryptofraphyKey('key') // 在config中设置key $crypto.encrypto('plaintext') // 在业务逻辑处直接传入需要加密的明文进行调用// 2. 第二种方式,每次都设置不同的key $crypto.encrypto('plaintext','key') 具体源码如下： 注意：解密时，需要先将密文转换成Base64的编码的格式。 使用CryptoJS.enc.Hex.parse转换成十六进制 使用CryptoJS.enc.Base64.stringify将其变成Base64编码的字符串 最后才能传入CryptoJS.AES.decrypt方法对其解密]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>AES</tag>
        <tag>Web开发</tag>
        <tag>CryptoJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基本常识]]></title>
    <url>%2Fpython%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86.html</url>
    <content type="text"><![CDATA[Python的语法格式Python是一种计算机编程语言，有着自己的一套语法格式。Python的语法格式非常简单，采用缩进的方式：123456# print absolute value of an integer:a = 100if a &gt;= 0: print(a)else: print(-a) 以#开头的语句是注释，解释器会自动忽略。 当语句以：结束时，缩进的语句视为代码块。 缩进有利有弊，好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是tab。按照约定俗成的习惯，应该使用4个空格的缩进。缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把很长的一段代码拆分成若干函数，从而得到缩进较少的代码。缩进的坏处就是“复制-粘贴”功能失效了，当我们重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像Java代码那样格式化Python代码。 Python程序是大小写敏感的，如果写错了大小写，程序会报错。 Python的数据类型在Python中，能够直接处理的数据类型有以下几种： 整数Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 浮点数浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。 字符串字符串是以单引号’或双引号”括起来的任意文本，比如&#39;abc&#39;，&quot;xyz&quot;等等。请注意，&#39;&#39;或&quot;&quot;本身只是一种表示方式，不是字符串的一部分，因此，字符串&#39;abc&#39;只有a，b，c这3个字符。如果&#39;本身也是一个字符，那就可以用&quot;&quot;括起来，比如&quot;I&#39;m OK&quot;包含的字符是I，&#39;，m，空格，O，K这6个字符。 如果字符串内部既包含&#39;又包含”怎么办？可以用转义字符\来标识，比如：1'I\'m \"OK\"!' 表示的字符串内容是：1I'm "OK"! 转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：12345678&gt;&gt;&gt; print('I\'m ok.')I'm ok.&gt;&gt;&gt; print('I\'m learning\nPython.')I'm learningPython.&gt;&gt;&gt; print('\\\n\\')\\ 如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r&#39;&#39;表示&#39;&#39;内部的字符串默认不转义，可以自己试试：1234&gt;&gt;&gt; print('\\\t\\')\ \&gt;&gt;&gt; print(r'\\\t\\')\\\t\\ 如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&#39;&#39;&#39;...&#39;&#39;&#39;的格式表示多行内容，可以自己试试：123456&gt;&gt;&gt; print('''line1... line2... line3''')line1line2line3 上面是在交互式命令行内输入，注意在输入多行内容时，提示符由&gt;&gt;&gt;变为...，提示你可以接着上一行输入。如果写成程序，就是：123print('''line1line2line3''') 多行字符串&#39;&#39;&#39;...&#39;&#39;&#39;还可以在前面加上r使用，请自行测试。 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：12345678&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse&gt;&gt;&gt; 3 &gt; 2True&gt;&gt;&gt; 3 &gt; 5False 布尔值可以用and、or和not运算。 and运算是与运算，只有所有都为True，and运算结果才是True：12345678&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; False and FalseFalse&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1True or运算是或运算，只要其中有一个为True，or运算结果就是True：12345678&gt;&gt;&gt; True or TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; False or FalseFalse&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3True not运算是非运算，它是一个单目运算符，把True变成False，False变成True：123456&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not FalseTrue&gt;&gt;&gt; not 1 &gt; 2True 布尔值经常用在条件判断中，比如：1234if age &gt;= 18: print('adult')else: print('teenager') 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。 变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：1a = 1 变量a是一个整数。1t_007 = &apos;T007&apos; 变量t_007是一个字符串。1Answer = True 变量Answer是一个布尔值True。 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：1234a = 123 # a是整数print(a)a = &apos;ABC&apos; # a变为字符串print(a) 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：12int a = 123; // a是整数类型变量a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量 和静态语言相比，动态语言更灵活，就是这个原因。 请不要把赋值语句的等号等同于数学的等号。比如下面的代码：12x = 10x = x + 2 如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。 最后，理解变量在计算机内存中的表示也非常重要。当我们写：1a = &apos;ABC&apos; 时，Python解释器干了两件事情： 在内存中创建了一个’ABC’的字符串； 在内存中创建了一个名为a的变量，并把它指向’ABC’。 也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：1234a = &apos;ABC&apos;b = aa = &apos;XYZ&apos;print(b) 常量所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：1PI = 3.14159265359 但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。 最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：12&gt;&gt;&gt; 10 / 33.3333333333333335 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：12&gt;&gt;&gt; 9 / 33.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数：12&gt;&gt;&gt; 10 // 33 你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。 因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：12&gt;&gt;&gt; 10 % 31 无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。 字符串和编码在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：12&gt;&gt;&gt; print(&apos;包含中文的str&apos;)包含中文的str 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：12345678&gt;&gt;&gt; ord(&apos;A&apos;)65&gt;&gt;&gt; ord(&apos;中&apos;)20013&gt;&gt;&gt; chr(66)&apos;B&apos;&gt;&gt;&gt; chr(25991)&apos;文&apos; 如果知道字符的整数编码，还可以用十六进制这么写str：12&gt;&gt;&gt; &apos;\u4e2d\u6587&apos;&apos;中文&apos; 两种写法完全是等价的。 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示：1x = b&apos;ABC&apos; 要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：12345678&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)b&apos;ABC&apos;&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128) 纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。 在bytes中，无法显示为ASCII字符的字节，用\x##显示。 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：1234&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)&apos;ABC&apos;&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)&apos;中文&apos; 要计算str包含多少个字符，可以用len()函数：1234&gt;&gt;&gt; len(&apos;ABC&apos;)3&gt;&gt;&gt; len(&apos;中文&apos;)2 len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：123456&gt;&gt;&gt; len(b&apos;ABC&apos;)3&gt;&gt;&gt; len(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)6&gt;&gt;&gt; len(&apos;中文&apos;.encode(&apos;utf-8&apos;))6 可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。 在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码.如果.py文件本身使用UTF-8编码，并且也申明了# -- coding: utf-8 --，打开命令提示符测试就可以正常显示中文。 ##格式化 最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似’亲爱的xxx你好！你xx月的话费是xx，余额是xx’之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。1py-str-format 在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：1234&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;&apos;Hello, world&apos;&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)&apos;Hi, Michael, you have $1000000.&apos; 你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。 常见的占位符有：1234%d 整数%f 浮点数%s 字符串%x 十六进制整数 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：1234&gt;&gt;&gt; &apos;%2d-%02d&apos; % (3, 1)&apos; 3-01&apos;&gt;&gt;&gt; &apos;%.2f&apos; % 3.1415926&apos;3.14&apos; 如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：12&gt;&gt;&gt; &apos;Age: %s. Gender: %s&apos; % (25, True)&apos;Age: 25. Gender: True&apos; 有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：12&gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7&apos;growth rate: 7 %&apos;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java概述]]></title>
    <url>%2Fjava%E6%A6%82%E8%BF%B0.html</url>
    <content type="text"><![CDATA[Java语言概述Java是由sun公司推出的java面向对象程序设计语言和java平台的的总称。由James Gosling和同事们共同研发，于1995年正式推出。java最初称为Oak，1995年更名。其特点是：面向对象、通用性、高效性、安全性、跨平台。随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。 java语言的发展java自从1996年发布1.0版本起，经过近20年的发展，于2014年已发布了java 8版本。 java语言的三个版本java语言共有三个版本： javase（J2SE，Java2 Platform Standard Edition，标准版）：是在java基础阶段主要学习的内容，包含了构成java语言核心的类，比如：数据库连接、接口定义、输入/输出、网络编程等。 javaee（J2EE，Java 2 Platform, Enterprise Edition，企业版）：用于服务端处理的企业版。该技术体系中包含的技术如Servlet Jsp等，主要针对于Web应用程序开发。 javame（J2ME，Java 2 Platform Micro Edition，微型版）：用于手机等嵌入式设备的“微型版”。其中，Javame目前使用较少，市场上的大多数为android系统和ios系统的手机，都有自己的开发工具来完成软件的开发。 Java程序设计环境Java虚拟机(JVM) JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 JVM是java的核心和基础，在java编译器和os平台之间的虚拟处理器，它是一种基于下层的操作系统和硬件平台并利用软件方法来实现的抽象计算机，可在上面执行java的字节码程序。 JVM是java实现跨平台性的一个关键，JVM本身并不能跨平台，正是由于JVM在不同的操作系统上有着不同的版本，使得java程序可以“一次编译，反复运行”。 Java开发环境的搭建 JDK和JRE JDK(Java development kit):java开发工具包，其中包含了JRE和java开发工具。安装了JDK之后就能运行Java程序。 JRE(Java runtime environment):java运行环境。其中包含了JVM和核心类库，如果只是单独的运行java程序，安装JRE即可。 JDK的下载与安装 JDK开发工具箱的下载，可以到Oracle网站，地址是www.oracle.com/technetwork/javajavase/downloads，根据自己电脑的操作系统选择Windows、Linux、Mac OS X等相对应的版本。 环境变量的配置在完成了JDK的安装之后，我们还需要进行环境变量的配置：即将jdk/bin目录添加到执行路径中，在bin目录下存放着一些可执行程序，如javac，java，javadoc等。配置环境变量的详细过程： 首先，右击【我的电脑】—【属性】—–【高级】—【环境变量】，如图： 将你jdk/bin目录加入进path中，以分号结束，但为了以后避免jdk重新安装时又要重新配置变量，我们可以在环境变量中新建一个名为%JAVA_HOME%的变量，变量值为jdk安装目录，再将%JAVA_HOME%/BIN加入到path中，如图： 测试环境变量是否配置成功，在DOS命令行下输入“javac”，输出帮助信息即为配置正确。如图： 下面提供一下临时配置环境变量的方法：当我们需要用别人的电脑进行开发，不能对别人电脑的环境变量进行随意更改时，我们可以使用临时配置的方式。临时的配置方式需要用到DOS命令行中的set命令，例如set path=” D:\Program Files\Java\jdk1.6.0_18\bin”就可以把配置临时的path变量，但是当我们再重新开启一个命令提示符窗口，该path就失去了效果。classpath也是相同的道理。 java程序编译运行方法 使用命令行方式java程序的编译和运行可以通过dos命令行的方式： 打开一个dos命令行窗口，可通过“win+R”的快捷键组合输入“cmd”的方式打开。 进入到java文件保存的目录。 执行javac文件名.java，对.java文件进行编译，生成.clss文件。 执行java文件名，即可执行该java程序。 下面用一个小程序做一个示范： 12345public class HelloWorld&#123; public static void main(String []args)&#123; System.out.println("HelloWorld"); &#125;&#125; 编译运行结果如图所示：下面是一些dos命令行常用的命令： dir：列出当前文件夹目录md：创建文件夹rd：删除文件夹（必须保证文件夹是空的）cd：进入文件目录cd..：退回到上一级目录cd/：退回到根目录del：删除文件exit：退出dos命令行 使用集成开发工具 我们还可以通过使用java集成工具来进行java程序的开发，这里主要介绍的是如和使用Eclipse编译运行一个程序。Eclipse可以从网站http://eclipse.org上免费下载。使用eclipse的步骤如下： 启动eclipse，从菜单栏选择File—&gt;New—&gt;Java Project，打开新建的这个文件，在其中右键new—&gt;class文件。进行java文件的编写编写完java文件之后，右键Run–&gt;Run As–&gt;Java Application即可。 Java中的注释 注释的作用: 1.注解，说明解释我们的程序，提高代码的阅读性 2.调试程序。当程序出现错误时，通过注释可以方便的查找出错的地方。 注释的类型：单行注释、多行注释和文档注释三种。 单行注释：//注释文字 多行注释：/注释文字（可多行）/ ，多行注释中不能嵌套多行注释 文档注释：/*注释内容/，是Java特有的注释，通常书写在类、域、构造函数、方法、定义之前。注释内容可以被JDK中的工具javadoc.exe所解析，生成一套以网页文件形式体现的该程序分说明文档。 格式如图所示：]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础,java,java概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基本语法(上)]]></title>
    <url>%2Fjava%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[java语言基础构成java的基础由关键字、标识符、注释、常量和变量、运算符、语句、函数、数组构成。 java关键字和保留字关键字定义：被java语言赋予了特殊涵义的单词。特点：关键字中所有字母均为小写。 关键字共有50个，分为以下类型，都有其特殊含义。 用于定义数据类型的关键字 用于定义流程控制的关键字 用于定义访问权限修饰符的关键字 用于定义类、函数、变量修饰符的关键字 用于定义类与类之间关系的关键字 用于建立实例及引用实例、判断实例的关键字 用于异常处理的关键字 用于包的关键字 其它修饰符关键字 保留字const，goto java中的常量和变量常量常量：表示不能改变的值。 java中常量的分类 整数常量：所有整数 小数常量：所有小数 布尔型常量：较为特有，只有两个数值，true和false 字符常量：将一个数字或字符使用单引号&#39;&#39;标识 字符串常量：将一个或多个字符使用双引号&quot;&quot;标识 null常量：只有一个数值，null 对于整数，java有三种表现形式 二进制：0和1表示，满2进1 十进制：0~9,满10进1 八进制：0~7，满8进1 十六进制：0~9，A~F，满16进1，开头用0x表示 计算机采用二进制的原因 技术实现简单，计算机由逻辑电路组成，逻辑电路通常只有两个状态，开关的接通与断开，这两种状态正好可以使用0和1来表示。 简化运算规则，两个二进制数和、积运算组合各有三种，运算规则简单，有利于简化计算机内部结构，提高运算速度。 适合逻辑运算，逻辑代数是逻辑运算的理论依据，二进制只有两个数码，正好与逻辑代数的”真”和”假”相吻合。 易于进行转换，二进制与十进制数易于相互转换。 用二进制表示数据具有抗干扰能力强，可靠性高等优点。因为每位数据只有高低两个状态，当受到一定程度的干扰时，仍能可靠的分辨出它是高是低。 变量java中的运算符标识符定义：在java语言中，对于变量、常量、函数、语句块也有名字，我们通通称之为标识符。标识符是用来给类、对象、方法、]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基本语法</tag>
        <tag>java运算符</tag>
      </tags>
  </entry>
</search>
